<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
	<xs:simpleType name="NoitaBool">
		<xs:restriction base="xs:string">
			<xs:enumeration value="0" />
			<xs:enumeration value="1" />
		</xs:restriction>
	</xs:simpleType>
	<xs:attributeGroup name="CommonComponentAttributes">
		<xs:attribute name="_tags" type="xs:string" default="" />
		<xs:attribute name="_enabled" type="NoitaBool" default="1" />
	</xs:attributeGroup>
	<xs:complexType name="Transform">
		<xs:annotation>
			<xs:documentation><![CDATA[```cpp<br>class types::xform {<br>&emsp;&emsp;&emsp;&emsp;vec2 position; // EntityLoad doesn't respect this on entities, mostly used for relative offsets in InheritTransformComponent<br>&emsp;&emsp;&emsp;&emsp;vec2 scale = {.x = 1, .y = 1}; // A stretching factor, most components don't work with this<br>&emsp;&emsp;&emsp;&emsp;float rotation = 0; // [0, 360] Measured in degrees<br>};```]]></xs:documentation>
		</xs:annotation>
		<xs:attribute name="position.x" type="xs:decimal" default="0" >
			<xs:annotation>
					<xs:documentation><![CDATA[```cpp<br>vec2 position; // EntityLoad doesn't respect this on entities, mostly used for relative offsets in InheritTransformComponent<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="position.y" type="xs:decimal" default="0" >
			<xs:annotation>
					<xs:documentation><![CDATA[```cpp<br>vec2 position; // EntityLoad doesn't respect this on entities, mostly used for relative offsets in InheritTransformComponent<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="scale.x" type="xs:decimal" default="1" >
			<xs:annotation>
					<xs:documentation><![CDATA[```cpp<br>vec2 scale = {.x = 1, .y = 1}; // A stretching factor, most components don't work with this<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="scale.y" type="xs:decimal" default="1" >
			<xs:annotation>
					<xs:documentation><![CDATA[```cpp<br>vec2 scale = {.x = 1, .y = 1}; // A stretching factor, most components don't work with this<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="rotation" type="xs:decimal" default="0" >
			<xs:annotation>
					<xs:documentation><![CDATA[```cpp<br>float rotation = 0; // [0, 360] Measured in degrees<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
		<xs:simpleType name="MOVETOSURFACE_TYPE">
		<xs:restriction base="xs:string">
			<xs:enumeration value="ENTITY"/>
			<xs:enumeration value="VERLET_ROPE_ONE_JOINT"/>
			<xs:enumeration value="VERLET_ROPE_TWO_JOINTS"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="RAGDOLL_FX">
		<xs:restriction base="xs:string">
			<xs:enumeration value="NONE"/>
			<xs:enumeration value="NORMAL"/>
			<xs:enumeration value="BLOOD_EXPLOSION"/>
			<xs:enumeration value="BLOOD_SPRAY"/>
			<xs:enumeration value="FROZEN"/>
			<xs:enumeration value="CONVERT_TO_MATERIAL"/>
			<xs:enumeration value="CUSTOM_RAGDOLL_ENTITY"/>
			<xs:enumeration value="DISINTEGRATED"/>
			<xs:enumeration value="NO_RAGDOLL_FILE"/>
			<xs:enumeration value="PLAYER_RAGDOLL_CAMERA"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="INVENTORY_KIND">
		<xs:restriction base="xs:string">
			<xs:enumeration value="QUICK"/>
			<xs:enumeration value="FULL"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="DAMAGE_TYPES">
		<xs:restriction base="xs:string">
			<xs:enumeration value="DAMAGE_MELEE"/>
			<xs:enumeration value="DAMAGE_PROJECTILE"/>
			<xs:enumeration value="DAMAGE_EXPLOSION"/>
			<xs:enumeration value="DAMAGE_BITE"/>
			<xs:enumeration value="DAMAGE_FIRE"/>
			<xs:enumeration value="DAMAGE_MATERIAL"/>
			<xs:enumeration value="DAMAGE_FALL"/>
			<xs:enumeration value="DAMAGE_ELECTRICITY"/>
			<xs:enumeration value="DAMAGE_DROWNING"/>
			<xs:enumeration value="DAMAGE_PHYSICS_BODY_DAMAGED"/>
			<xs:enumeration value="DAMAGE_DRILL"/>
			<xs:enumeration value="DAMAGE_SLICE"/>
			<xs:enumeration value="DAMAGE_ICE"/>
			<xs:enumeration value="DAMAGE_HEALING"/>
			<xs:enumeration value="DAMAGE_PHYSICS_HIT"/>
			<xs:enumeration value="DAMAGE_RADIOACTIVE"/>
			<xs:enumeration value="DAMAGE_POISON"/>
			<xs:enumeration value="DAMAGE_MATERIAL_WITH_FLASH"/>
			<xs:enumeration value="DAMAGE_OVEREATING"/>
			<xs:enumeration value="DAMAGE_CURSE"/>
			<xs:enumeration value="DAMAGE_HOLY"/>
			<xs:enumeration value="NONE"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="AUDIO_LAYER">
		<xs:restriction base="xs:string">
			<xs:enumeration value="EFFECT_GAME"/>
			<xs:enumeration value="EFFECT_UI"/>
			<xs:enumeration value="AMBIENCE"/>
			<xs:enumeration value="MUSIC"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="GAME_EFFECT">
		<xs:restriction base="xs:string">
			<xs:enumeration value="NONE"/>
			<xs:enumeration value="ELECTROCUTION"/>
			<xs:enumeration value="FROZEN"/>
			<xs:enumeration value="ON_FIRE"/>
			<xs:enumeration value="POISON"/>
			<xs:enumeration value="BERSERK"/>
			<xs:enumeration value="CHARM"/>
			<xs:enumeration value="POLYMORPH"/>
			<xs:enumeration value="POLYMORPH_RANDOM"/>
			<xs:enumeration value="BLINDNESS"/>
			<xs:enumeration value="TELEPATHY"/>
			<xs:enumeration value="TELEPORTATION"/>
			<xs:enumeration value="REGENERATION"/>
			<xs:enumeration value="LEVITATION"/>
			<xs:enumeration value="MOVEMENT_SLOWER"/>
			<xs:enumeration value="FARTS"/>
			<xs:enumeration value="DRUNK"/>
			<xs:enumeration value="BREATH_UNDERWATER"/>
			<xs:enumeration value="RADIOACTIVE"/>
			<xs:enumeration value="WET"/>
			<xs:enumeration value="OILED"/>
			<xs:enumeration value="BLOODY"/>
			<xs:enumeration value="SLIMY"/>
			<xs:enumeration value="CRITICAL_HIT_BOOST"/>
			<xs:enumeration value="CONFUSION"/>
			<xs:enumeration value="MELEE_COUNTER"/>
			<xs:enumeration value="WORM_ATTRACTOR"/>
			<xs:enumeration value="WORM_DETRACTOR"/>
			<xs:enumeration value="FOOD_POISONING"/>
			<xs:enumeration value="FRIEND_THUNDERMAGE"/>
			<xs:enumeration value="FRIEND_FIREMAGE"/>
			<xs:enumeration value="INTERNAL_FIRE"/>
			<xs:enumeration value="INTERNAL_ICE"/>
			<xs:enumeration value="JARATE"/>
			<xs:enumeration value="KNOCKBACK"/>
			<xs:enumeration value="KNOCKBACK_IMMUNITY"/>
			<xs:enumeration value="MOVEMENT_SLOWER_2X"/>
			<xs:enumeration value="MOVEMENT_FASTER"/>
			<xs:enumeration value="STAINS_DROP_FASTER"/>
			<xs:enumeration value="SAVING_GRACE"/>
			<xs:enumeration value="DAMAGE_MULTIPLIER"/>
			<xs:enumeration value="HEALING_BLOOD"/>
			<xs:enumeration value="RESPAWN"/>
			<xs:enumeration value="PROTECTION_FIRE"/>
			<xs:enumeration value="PROTECTION_RADIOACTIVITY"/>
			<xs:enumeration value="PROTECTION_EXPLOSION"/>
			<xs:enumeration value="PROTECTION_MELEE"/>
			<xs:enumeration value="PROTECTION_ELECTRICITY"/>
			<xs:enumeration value="TELEPORTITIS"/>
			<xs:enumeration value="STAINLESS_ARMOUR"/>
			<xs:enumeration value="GLOBAL_GORE"/>
			<xs:enumeration value="EDIT_WANDS_EVERYWHERE"/>
			<xs:enumeration value="EXPLODING_CORPSE_SHOTS"/>
			<xs:enumeration value="EXPLODING_CORPSE"/>
			<xs:enumeration value="EXTRA_MONEY"/>
			<xs:enumeration value="EXTRA_MONEY_TRICK_KILL"/>
			<xs:enumeration value="HOVER_BOOST"/>
			<xs:enumeration value="PROJECTILE_HOMING"/>
			<xs:enumeration value="ABILITY_ACTIONS_MATERIALIZED"/>
			<xs:enumeration value="NO_DAMAGE_FLASH"/>
			<xs:enumeration value="NO_SLIME_SLOWDOWN"/>
			<xs:enumeration value="MOVEMENT_FASTER_2X"/>
			<xs:enumeration value="NO_WAND_EDITING"/>
			<xs:enumeration value="LOW_HP_DAMAGE_BOOST"/>
			<xs:enumeration value="FASTER_LEVITATION"/>
			<xs:enumeration value="STUN_PROTECTION_ELECTRICITY"/>
			<xs:enumeration value="STUN_PROTECTION_FREEZE"/>
			<xs:enumeration value="IRON_STOMACH"/>
			<xs:enumeration value="PROTECTION_ALL"/>
			<xs:enumeration value="INVISIBILITY"/>
			<xs:enumeration value="REMOVE_FOG_OF_WAR"/>
			<xs:enumeration value="MANA_REGENERATION"/>
			<xs:enumeration value="PROTECTION_DURING_TELEPORT"/>
			<xs:enumeration value="PROTECTION_POLYMORPH"/>
			<xs:enumeration value="PROTECTION_FREEZE"/>
			<xs:enumeration value="FROZEN_SPEED_UP"/>
			<xs:enumeration value="UNSTABLE_TELEPORTATION"/>
			<xs:enumeration value="POLYMORPH_UNSTABLE"/>
			<xs:enumeration value="CUSTOM"/>
			<xs:enumeration value="ALLERGY_RADIOACTIVE"/>
			<xs:enumeration value="RAINBOW_FARTS"/>
			<xs:enumeration value="WEAKNESS"/>
			<xs:enumeration value="PROTECTION_FOOD_POISONING"/>
			<xs:enumeration value="NO_HEAL"/>
			<xs:enumeration value="PROTECTION_EDGES"/>
			<xs:enumeration value="PROTECTION_PROJECTILE"/>
			<xs:enumeration value="POLYMORPH_CESSATION"/>
			<xs:enumeration value="_LAST"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="PROJECTILE_TYPE">
		<xs:restriction base="xs:string">
			<xs:enumeration value="PROJECTILE"/>
			<xs:enumeration value="LIGHTNING"/>
			<xs:enumeration value="VERLET"/>
			<xs:enumeration value="MATERIAL_PARTICLE"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="JOINT_TYPE">
		<xs:restriction base="xs:string">
			<xs:enumeration value="REVOLUTE_JOINT"/>
			<xs:enumeration value="WELD_JOINT"/>
			<xs:enumeration value="REVOLUTE_JOINT_ATTACH_TO_NEARBY_SURFACE"/>
			<xs:enumeration value="WELD_JOINT_ATTACH_TO_NEARBY_SURFACE"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ARC_TYPE">
		<xs:restriction base="xs:string">
			<xs:enumeration value="MATERIAL"/>
			<xs:enumeration value="LIGHTNING"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="HIT_EFFECT">
		<xs:restriction base="xs:string">
			<xs:enumeration value="NONE"/>
			<xs:enumeration value="LOAD_ENTITY"/>
			<xs:enumeration value="LOAD_CHILD_ENTITY"/>
			<xs:enumeration value="LOAD_UNIQUE_CHILD_ENTITY"/>
			<xs:enumeration value="LOAD_GAME_EFFECT"/>
			<xs:enumeration value="LOAD_UNIQUE_GAME_EFFECT"/>
			<xs:enumeration value="CONVERT_RAGDOLL_TO_MATERIAL"/>
			<xs:enumeration value="CRITICAL_HIT_BOOST"/>
			<xs:enumeration value="DAMAGE_BOOST"/>
			<xs:enumeration value="SWAPPER"/>
			<xs:enumeration value="LOAD_CHILD_ENTITY_LIMIT_TO_X"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="MATERIALAUDIO_TYPE">
		<xs:restriction base="xs:string">
			<xs:enumeration value="NONE"/>
			<xs:enumeration value="LAVA"/>
			<xs:enumeration value="MAGICAL"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="MATERIALBREAKAUDIO_TYPE">
		<xs:restriction base="xs:string">
			<xs:enumeration value="NONE"/>
			<xs:enumeration value="WOOD"/>
			<xs:enumeration value="CHAIN"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="EDGE_STYLE">
		<xs:restriction base="xs:string">
			<xs:enumeration value="COLOR_EDGE_PIXELS"/>
			<xs:enumeration value="EVERYWHERE"/>
			<xs:enumeration value="CARDINAL_DIRECTIONS"/>
			<xs:enumeration value="NORMAL_BASED"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="EXPLOSION_TRIGGER_TYPE">
		<xs:restriction base="xs:string">
			<xs:enumeration value="ON_CREATE"/>
			<xs:enumeration value="ON_DEATH"/>
			<xs:enumeration value="ON_TIMER"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="LUA_VM_TYPE">
		<xs:restriction base="xs:string">
			<xs:enumeration value="SHARED_BY_MANY_COMPONENTS"/>
			<xs:enumeration value="CREATE_NEW_EVERY_EXECUTION"/>
			<xs:enumeration value="ONE_PER_COMPONENT_INSTANCE"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="FOG_OF_WAR_TYPE">
		<xs:restriction base="xs:string">
			<xs:enumeration value="DEFAULT"/>
			<xs:enumeration value="HEAVY_CLEAR_AT_PLAYER"/>
			<xs:enumeration value="HEAVY_CLEAR_WITH_MAGIC"/>
			<xs:enumeration value="HEAVY_NO_CLEAR"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="NOISE_TYPE">
		<xs:restriction base="xs:string">
			<xs:enumeration value="IQ2_SIMPLEX1234"/>
			<xs:enumeration value="IQ_SIMPLEX"/>
			<xs:enumeration value="SIN_CAPPED_EVERYTHING"/>
			<xs:enumeration value="SIN_CAPPED_SIMPLEX"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="GENERAL_NOISE">
		<xs:restriction base="xs:string">
			<xs:enumeration value="IQNoise"/>
			<xs:enumeration value="DirtyPeeNoise"/>
			<xs:enumeration value="QemNoise"/>
			<xs:enumeration value="WhiteNoise"/>
			<xs:enumeration value="MixNoise"/>
			<xs:enumeration value="SimplexNoise"/>
			<xs:enumeration value="STB_Perlin"/>
			<xs:enumeration value="FastBlockNoise"/>
			<xs:enumeration value="SimplexNoise1234"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="BIOME_TYPE">
		<xs:restriction base="xs:string">
			<xs:enumeration value="BIOME_PROCEDURAL"/>
			<xs:enumeration value="BIOME_BITMAP"/>
			<xs:enumeration value="BIOME_WANG_TILE"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="VERLET_TYPE">
		<xs:restriction base="xs:string">
			<xs:enumeration value="CHAIN"/>
			<xs:enumeration value="CLOTH"/>
			<xs:enumeration value="BLOB"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="PARTICLE_EMITTER_CUSTOM_STYLE">
		<xs:restriction base="xs:string">
			<xs:enumeration value="NONE"/>
			<xs:enumeration value="FIRE"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="PathFindingComponentState">
		<xs:restriction base="xs:string">
			<xs:enumeration value=""/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="TeleportComponentState">
		<xs:restriction base="xs:string">
			<xs:enumeration value=""/>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="EntityBase">
		<xs:sequence minOccurs="0">
			<xs:choice maxOccurs="unbounded" minOccurs="0">
				<xs:element ref="Entity" />
				<xs:element name="Base" type="Base" />
				<xs:element name="Transform" type="Transform" />
				<xs:element name="AIAttackComponent" type="AIAttackComponent" />
				<xs:element name="AIComponent" type="AIComponent" />
				<xs:element name="AbilityComponent" type="AbilityComponent" />
				<xs:element name="AdvancedFishAIComponent" type="AdvancedFishAIComponent" />
				<xs:element name="AltarComponent" type="AltarComponent" />
				<xs:element name="AnimalAIComponent" type="AnimalAIComponent" />
				<xs:element name="ArcComponent" type="ArcComponent" />
				<xs:element name="AreaDamageComponent" type="AreaDamageComponent" />
				<xs:element name="AttachToEntityComponent" type="AttachToEntityComponent" />
				<xs:element name="AudioComponent" type="AudioComponent" />
				<xs:element name="AudioListenerComponent" type="AudioListenerComponent" />
				<xs:element name="AudioLoopComponent" type="AudioLoopComponent" />
				<xs:element name="BiomeTrackerComponent" type="BiomeTrackerComponent" />
				<xs:element name="BlackHoleComponent" type="BlackHoleComponent" />
				<xs:element name="BookComponent" type="BookComponent" />
				<xs:element name="BossDragonComponent" type="BossDragonComponent" />
				<xs:element name="BossHealthBarComponent" type="BossHealthBarComponent" />
				<xs:element name="CameraBoundComponent" type="CameraBoundComponent" />
				<xs:element name="CardinalMovementComponent" type="CardinalMovementComponent" />
				<xs:element name="CellEaterComponent" type="CellEaterComponent" />
				<xs:element name="CharacterCollisionComponent" type="CharacterCollisionComponent" />
				<xs:element name="CharacterDataComponent" type="CharacterDataComponent" />
				<xs:element name="CharacterPlatformingComponent" type="CharacterPlatformingComponent" />
				<xs:element name="CharacterStatsComponent" type="CharacterStatsComponent" />
				<xs:element name="CollisionTriggerComponent" type="CollisionTriggerComponent" />
				<xs:element name="ConsumableTeleportComponent" type="ConsumableTeleportComponent" />
				<xs:element name="ControllerGoombaAIComponent" type="ControllerGoombaAIComponent" />
				<xs:element name="ControlsComponent" type="ControlsComponent" />
				<xs:element name="CrawlerAnimalComponent" type="CrawlerAnimalComponent" />
				<xs:element name="CutThroughWorldDoneHereComponent" type="CutThroughWorldDoneHereComponent" />
				<xs:element name="DamageModelComponent" type="DamageModelComponent" />
				<xs:element name="DamageNearbyEntitiesComponent" type="DamageNearbyEntitiesComponent" />
				<xs:element name="DebugFollowMouseComponent" type="DebugFollowMouseComponent" />
				<xs:element name="DebugLogMessagesComponent" type="DebugLogMessagesComponent" />
				<xs:element name="DebugSpatialVisualizerComponent" type="DebugSpatialVisualizerComponent" />
				<xs:element name="DieIfSpeedBelowComponent" type="DieIfSpeedBelowComponent" />
				<xs:element name="DroneLauncherComponent" type="DroneLauncherComponent" />
				<xs:element name="DrugEffectComponent" type="DrugEffectComponent" />
				<xs:element name="DrugEffectModifierComponent" type="DrugEffectModifierComponent" />
				<xs:element name="ElectricChargeComponent" type="ElectricChargeComponent" />
				<xs:element name="ElectricityComponent" type="ElectricityComponent" />
				<xs:element name="ElectricityReceiverComponent" type="ElectricityReceiverComponent" />
				<xs:element name="ElectricitySourceComponent" type="ElectricitySourceComponent" />
				<xs:element name="EndingMcGuffinComponent" type="EndingMcGuffinComponent" />
				<xs:element name="EnergyShieldComponent" type="EnergyShieldComponent" />
				<xs:element name="ExplodeOnDamageComponent" type="ExplodeOnDamageComponent" />
				<xs:element name="ExplosionComponent" type="ExplosionComponent" />
				<xs:element name="FishAIComponent" type="FishAIComponent" />
				<xs:element name="FlyingComponent" type="FlyingComponent" />
				<xs:element name="FogOfWarRadiusComponent" type="FogOfWarRadiusComponent" />
				<xs:element name="FogOfWarRemoverComponent" type="FogOfWarRemoverComponent" />
				<xs:element name="GameAreaEffectComponent" type="GameAreaEffectComponent" />
				<xs:element name="GameEffectComponent" type="GameEffectComponent" />
				<xs:element name="GameLogComponent" type="GameLogComponent" />
				<xs:element name="GameStatsComponent" type="GameStatsComponent" />
				<xs:element name="GasBubbleComponent" type="GasBubbleComponent" />
				<xs:element name="GenomeDataComponent" type="GenomeDataComponent" />
				<xs:element name="GhostComponent" type="GhostComponent" />
				<xs:element name="GodInfoComponent" type="GodInfoComponent" />
				<xs:element name="GunComponent" type="GunComponent" />
				<xs:element name="HealthBarComponent" type="HealthBarComponent" />
				<xs:element name="HitEffectComponent" type="HitEffectComponent" />
				<xs:element name="HitboxComponent" type="HitboxComponent" />
				<xs:element name="HomingComponent" type="HomingComponent" />
				<xs:element name="HotspotComponent" type="HotspotComponent" />
				<xs:element name="IKLimbAttackerComponent" type="IKLimbAttackerComponent" />
				<xs:element name="IKLimbComponent" type="IKLimbComponent" />
				<xs:element name="IKLimbWalkerComponent" type="IKLimbWalkerComponent" />
				<xs:element name="IKLimbsAnimatorComponent" type="IKLimbsAnimatorComponent" />
				<xs:element name="IngestionComponent" type="IngestionComponent" />
				<xs:element name="InheritTransformComponent" type="InheritTransformComponent" />
				<xs:element name="InteractableComponent" type="InteractableComponent" />
				<xs:element name="Inventory2Component" type="Inventory2Component" />
				<xs:element name="InventoryComponent" type="InventoryComponent" />
				<xs:element name="InventoryGuiComponent" type="InventoryGuiComponent" />
				<xs:element name="ItemAIKnowledgeComponent" type="ItemAIKnowledgeComponent" />
				<xs:element name="ItemActionComponent" type="ItemActionComponent" />
				<xs:element name="ItemAlchemyComponent" type="ItemAlchemyComponent" />
				<xs:element name="ItemChestComponent" type="ItemChestComponent" />
				<xs:element name="ItemComponent" type="ItemComponent" />
				<xs:element name="ItemCostComponent" type="ItemCostComponent" />
				<xs:element name="ItemPickUpperComponent" type="ItemPickUpperComponent" />
				<xs:element name="ItemRechargeNearGroundComponent" type="ItemRechargeNearGroundComponent" />
				<xs:element name="ItemStashComponent" type="ItemStashComponent" />
				<xs:element name="KickComponent" type="KickComponent" />
				<xs:element name="LaserEmitterComponent" type="LaserEmitterComponent" />
				<xs:element name="LevitationComponent" type="LevitationComponent" />
				<xs:element name="LifetimeComponent" type="LifetimeComponent" />
				<xs:element name="LightComponent" type="LightComponent" />
				<xs:element name="LightningComponent" type="LightningComponent" />
				<xs:element name="LimbBossComponent" type="LimbBossComponent" />
				<xs:element name="LiquidDisplacerComponent" type="LiquidDisplacerComponent" />
				<xs:element name="LoadEntitiesComponent" type="LoadEntitiesComponent" />
				<xs:element name="LocationMarkerComponent" type="LocationMarkerComponent" />
				<xs:element name="LooseGroundComponent" type="LooseGroundComponent" />
				<xs:element name="LuaComponent" type="LuaComponent" />
				<xs:element name="MagicConvertMaterialComponent" type="MagicConvertMaterialComponent" />
				<xs:element name="MagicXRayComponent" type="MagicXRayComponent" />
				<xs:element name="ManaReloaderComponent" type="ManaReloaderComponent" />
				<xs:element name="MaterialAreaCheckerComponent" type="MaterialAreaCheckerComponent" />
				<xs:element name="MaterialInventoryComponent" type="MaterialInventoryComponent" />
				<xs:element name="MaterialSeaSpawnerComponent" type="MaterialSeaSpawnerComponent" />
				<xs:element name="MaterialSuckerComponent" type="MaterialSuckerComponent" />
				<xs:element name="MoveToSurfaceOnCreateComponent" type="MoveToSurfaceOnCreateComponent" />
				<xs:element name="MusicEnergyAffectorComponent" type="MusicEnergyAffectorComponent" />
				<xs:element name="NinjaRopeComponent" type="NinjaRopeComponent" />
				<xs:element name="NullDamageComponent" type="NullDamageComponent" />
				<xs:element name="OrbComponent" type="OrbComponent" />
				<xs:element name="ParticleEmitterComponent" type="ParticleEmitterComponent" />
				<xs:element name="PathFindingComponent" type="PathFindingComponent" />
				<xs:element name="PathFindingGridMarkerComponent" type="PathFindingGridMarkerComponent" />
				<xs:element name="PhysicsAIComponent" type="PhysicsAIComponent" />
				<xs:element name="PhysicsBody2Component" type="PhysicsBody2Component" />
				<xs:element name="PhysicsBodyCollisionDamageComponent" type="PhysicsBodyCollisionDamageComponent" />
				<xs:element name="PhysicsBodyComponent" type="PhysicsBodyComponent" />
				<xs:element name="PhysicsImageShapeComponent" type="PhysicsImageShapeComponent" />
				<xs:element name="PhysicsJoint2Component" type="PhysicsJoint2Component" />
				<xs:element name="PhysicsJoint2MutatorComponent" type="PhysicsJoint2MutatorComponent" />
				<xs:element name="PhysicsJointComponent" type="PhysicsJointComponent" />
				<xs:element name="PhysicsKeepInWorldComponent" type="PhysicsKeepInWorldComponent" />
				<xs:element name="PhysicsPickUpComponent" type="PhysicsPickUpComponent" />
				<xs:element name="PhysicsRagdollComponent" type="PhysicsRagdollComponent" />
				<xs:element name="PhysicsShapeComponent" type="PhysicsShapeComponent" />
				<xs:element name="PhysicsThrowableComponent" type="PhysicsThrowableComponent" />
				<xs:element name="PixelSceneComponent" type="PixelSceneComponent" />
				<xs:element name="PixelSpriteComponent" type="PixelSpriteComponent" />
				<xs:element name="PlatformShooterPlayerComponent" type="PlatformShooterPlayerComponent" />
				<xs:element name="PlayerCollisionComponent" type="PlayerCollisionComponent" />
				<xs:element name="PlayerStatsComponent" type="PlayerStatsComponent" />
				<xs:element name="PositionSeedComponent" type="PositionSeedComponent" />
				<xs:element name="PotionComponent" type="PotionComponent" />
				<xs:element name="PressurePlateComponent" type="PressurePlateComponent" />
				<xs:element name="ProjectileComponent" type="ProjectileComponent" />
				<xs:element name="RotateTowardsComponent" type="RotateTowardsComponent" />
				<xs:element name="SetLightAlphaFromVelocityComponent" type="SetLightAlphaFromVelocityComponent" />
				<xs:element name="SetStartVelocityComponent" type="SetStartVelocityComponent" />
				<xs:element name="ShotEffectComponent" type="ShotEffectComponent" />
				<xs:element name="SimplePhysicsComponent" type="SimplePhysicsComponent" />
				<xs:element name="SineWaveComponent" type="SineWaveComponent" />
				<xs:element name="SpriteAnimatorComponent" type="SpriteAnimatorComponent" />
				<xs:element name="SpriteComponent" type="SpriteComponent" />
				<xs:element name="SpriteOffsetAnimatorComponent" type="SpriteOffsetAnimatorComponent" />
				<xs:element name="SpriteParticleEmitterComponent" type="SpriteParticleEmitterComponent" />
				<xs:element name="SpriteStainsComponent" type="SpriteStainsComponent" />
				<xs:element name="StatusEffectDataComponent" type="StatusEffectDataComponent" />
				<xs:element name="StreamingKeepAliveComponent" type="StreamingKeepAliveComponent" />
				<xs:element name="TelekinesisComponent" type="TelekinesisComponent" />
				<xs:element name="TeleportComponent" type="TeleportComponent" />
				<xs:element name="TeleportProjectileComponent" type="TeleportProjectileComponent" />
				<xs:element name="TextLogComponent" type="TextLogComponent" />
				<xs:element name="TorchComponent" type="TorchComponent" />
				<xs:element name="UIIconComponent" type="UIIconComponent" />
				<xs:element name="UIInfoComponent" type="UIInfoComponent" />
				<xs:element name="VariableStorageComponent" type="VariableStorageComponent" />
				<xs:element name="VelocityComponent" type="VelocityComponent" />
				<xs:element name="VerletPhysicsComponent" type="VerletPhysicsComponent" />
				<xs:element name="VerletWeaponComponent" type="VerletWeaponComponent" />
				<xs:element name="VerletWorldJointComponent" type="VerletWorldJointComponent" />
				<xs:element name="WalletComponent" type="WalletComponent" />
				<xs:element name="WalletValuableComponent" type="WalletValuableComponent" />
				<xs:element name="WorldStateComponent" type="WorldStateComponent" />
				<xs:element name="WormAIComponent" type="WormAIComponent" />
				<xs:element name="WormAttractorComponent" type="WormAttractorComponent" />
				<xs:element name="WormComponent" type="WormComponent" />
				<xs:element name="WormPlayerComponent" type="WormPlayerComponent" />
			</xs:choice>
		</xs:sequence>
		<xs:attribute name="name" type="xs:string" />
		<xs:attribute name="tags" type="xs:string" />
	</xs:complexType>
	<xs:element name="Entity" type="EntityBase">
		<xs:annotation>
			<xs:documentation>Represents an entity that can be loaded into the world</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="Base">
		<xs:annotation>
			<xs:documentation>Base file</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="EntityBase">
				<xs:attribute name="file" type="xs:string" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Biome" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class Biome {<br>&emsp;&emsp;&emsp;&emsp;std::string name; //  the name that is exposed to lua functions that spawn entities<br>&emsp;&emsp;&emsp;&emsp;std::string background_image; //  path to the image file (texture) that is used for the background<br>&emsp;&emsp;&emsp;&emsp;std::string background_edge_left; //  if not empty, will use this image as the left edge<br>&emsp;&emsp;&emsp;&emsp;std::string background_edge_right; //  if not empty, will use this image as the right edge<br>&emsp;&emsp;&emsp;&emsp;std::string background_edge_top; //  if not empty, will use this image as the top edge<br>&emsp;&emsp;&emsp;&emsp;std::string background_edge_bottom; //  if not empty, will use this image as the bottom edge<br>&emsp;&emsp;&emsp;&emsp;int background_edge_priority; //  if both biomes have edges defined, will use the one with higher priority (if priority is same, will compare (>) background_images)<br>&emsp;&emsp;&emsp;&emsp;bool background_use_neighbor; //  if set will look for neighboring biomes and use their background image<br>&emsp;&emsp;&emsp;&emsp;float background_image_height; //  height were the background image starts<br>&emsp;&emsp;&emsp;&emsp;bool limit_background_image; //  Will limit the background image to start at the cave height<br>&emsp;&emsp;&emsp;&emsp;std::string bitmap_noise_file; //  if set, loads it to mBitmapNoise<br>&emsp;&emsp;&emsp;&emsp;bool noise_biome_edges; //  does the noisy edge for biomes, if either of biomes has this set to 0 will do a straight edge<br>&emsp;&emsp;&emsp;&emsp;bool big_noise_biome_edges; //  if true, will leak onto other biomes and not be carveable<br>&emsp;&emsp;&emsp;&emsp;bool fat_biome_edges; //  if true, will leak onto other biomes and not be carveable<br>&emsp;&emsp;&emsp;&emsp;bool skip_edge_textures; //  skips edge texture generation. Turn of for pixel scenes<br>&emsp;&emsp;&emsp;&emsp;std::string audio_music_enter; //  the music event that plays when player enters this biome (e.g. 'music/desert/enter')<br>&emsp;&emsp;&emsp;&emsp;std::string audio_music_2; //  the music directory that plays while player is in this biome (e.g 'coalmine')<br>&emsp;&emsp;&emsp;&emsp;float audio_music_energy_coeff; //  Multiplier for music energy in this biome<br>&emsp;&emsp;&emsp;&emsp;bool audio_music_no_forced_quietness; //  If 1, music is not quieted by occasional quietness<br>&emsp;&emsp;&emsp;&emsp;int32 audio_music_forced_quietness_duration_seconds; //  If > 0, this is the duration of occasional quietness, else the value from magic numbers is used.<br>&emsp;&emsp;&emsp;&emsp;bool audio_music_trigger_without_danger; //  If 1, music is triggered in this biome no matter what the danger level is<br>&emsp;&emsp;&emsp;&emsp;std::string audio_ambience; //  the ambience event that plays while player is in this biome<br>&emsp;&emsp;&emsp;&emsp;std::string audio_ambience_surface; //  the ambience event that plays while player is in this biome and on surface<br>&emsp;&emsp;&emsp;&emsp;float color_grading_r; //  post fx color grading<br>&emsp;&emsp;&emsp;&emsp;float color_grading_g; //  post fx color grading<br>&emsp;&emsp;&emsp;&emsp;float color_grading_b; //  post fx color grading<br>&emsp;&emsp;&emsp;&emsp;float color_grading_grayscale; //  post fx color grading. [0.0,1.0], larger value means more grayscale<br>&emsp;&emsp;&emsp;&emsp;bool has_rain; //  if 1, rain or snowfall may occur in this biome<br>&emsp;&emsp;&emsp;&emsp;std::string bitmap_filename; //  loads the chunk from this bitmap, the bitmap should be 512x512<br>&emsp;&emsp;&emsp;&emsp;std::string wang_template_file; //  uses this file to create a herringbone wang map<br>&emsp;&emsp;&emsp;&emsp;int wang_map_width; //  the size of the wang map<br>&emsp;&emsp;&emsp;&emsp;int wang_map_height; //  the size of the wang map<br>&emsp;&emsp;&emsp;&emsp;std::string lua_script; //  default is data/scripts/biomes/NAME.lua<br>&emsp;&emsp;&emsp;&emsp;bool pixel_scene; //  for 'pixel scene' biomes, this forces the loading before hand <br>&emsp;&emsp;&emsp;&emsp;bool static_tile; //  if 1, directly blits wang_template_file without wang randomization, kind of like a pixel scene but at the wang tile resolution<br>&emsp;&emsp;&emsp;&emsp;std::string static_tile_bg_mask; //  if set, and static tile is 1, the background_image will use a special shader and this mask to calculate visiblity. should be same size and resolution as 'wang_template_file'<br>&emsp;&emsp;&emsp;&emsp;float static_tile_bg_mask_threshold; //  threshold used in 'sprite_static_tile_bg.frag' shader in conjuction with 'sprite_static_tile_bg_mask' to determine if a background pixel is visible or not<br>&emsp;&emsp;&emsp;&emsp;float game_enemy_hp_scale; //  1.f = default. Will multiply the hp of the camerabounded enemies in the area with hp_scale<br>&emsp;&emsp;&emsp;&emsp;float game_enemy_attack_speed; //  1.f = default. This multiplies AnimalAI's attack_ranged_frames_between in camerabounded enemies<br>&emsp;&emsp;&emsp;&emsp;bool mInsideNoiseFBM; //  will fbm the mInsideNoise if set true<br>&emsp;&emsp;&emsp;&emsp;double mInsidePerlinScaleX; //  the noise inside the stones...<br>&emsp;&emsp;&emsp;&emsp;double mInsidePerlinScaleY; //  the noise inside the stones...<br>&emsp;&emsp;&emsp;&emsp;bool mInsidePerlinSquared;<br>&emsp;&emsp;&emsp;&emsp;bool mInsidePerlinClamped;<br>&emsp;&emsp;&emsp;&emsp;bool mInsidePerlinScaled;<br>&emsp;&emsp;&emsp;&emsp;float mInsidePerlinScaleMin;<br>&emsp;&emsp;&emsp;&emsp;float mInsidePerlinScaleMax;<br>&emsp;&emsp;&emsp;&emsp;bool mInsidePerlinForceInside; //  if set, will multiply the noise_value with the gradient value <br>&emsp;&emsp;&emsp;&emsp;bool mInsidePerlinOffsetBySeed; //  NOTE( Petri ): 17.8.2023 - if set, will add worldseed as an offset to the noise<br>&emsp;&emsp;&emsp;&emsp;double mInsidePerlinOffsetX; //  NOTE( Petri ): 17.8.2023 - perlin noise offset<br>&emsp;&emsp;&emsp;&emsp;double mInsidePerlinOffsetY; //  NOTE( Petri ): 17.8.2023 - perlin noise offset<br>&emsp;&emsp;&emsp;&emsp;float mInsideAddValue; //  added inside the caves the gradient value<br>&emsp;&emsp;&emsp;&emsp;float mMultiplierGradient; //  how much of the gradient is applied<br>&emsp;&emsp;&emsp;&emsp;float mMultiplierPerlin; //  how much of the inside noise<br>&emsp;&emsp;&emsp;&emsp;float mMultiplierExtraPerlin;<br>&emsp;&emsp;&emsp;&emsp;float mGradientStartY;<br>&emsp;&emsp;&emsp;&emsp;float mGradientEndY;<br>&emsp;&emsp;&emsp;&emsp;double mGradientSlopeStartX; //  if addNoise = 3, will use this to the ( x - mGradientSlopeStartX ) * mGradientSlopeDelta<br>&emsp;&emsp;&emsp;&emsp;double mGradientSlopeDelta; //  if addNoise = 3, will use this to the ( x - mGradientSlopeStartX ) * mGradientSlopeDelta<br>&emsp;&emsp;&emsp;&emsp;int mGradientAddNoise; //  fake enum 1=standard noise, 2=fbm noise, 3=slope<br>&emsp;&emsp;&emsp;&emsp;double mGradientNoiseScale;<br>&emsp;&emsp;&emsp;&emsp;float mGradientLowNoise;<br>&emsp;&emsp;&emsp;&emsp;float mGradientHighNoise;<br>&emsp;&emsp;&emsp;&emsp;bool coarse_map_force_terrain; //  if 1, is initially marked as 'terrain' in the coarse map used for sky light calculations etc<br>&emsp;&emsp;&emsp;&emsp;bool coarse_map_not_terrain; //  if 1, is initially never marked as 'terrain' in the coarse map used for sky light calculations etc<br>&emsp;&emsp;&emsp;&emsp;bool coarse_map_cell_count_always_zero; //  if 1, areas in this biome always have a 64x64 cell count of 0<br>&emsp;&emsp;&emsp;&emsp;ceng::CArray2D<uint32>* bitmap_data; //  for bitmap loading, well cache it here<br>&emsp;&emsp;&emsp;&emsp;BitmapNoise* mBitmapNoise; //  load the bitmap noise here<br>&emsp;&emsp;&emsp;&emsp;BiomeMaterials* mBiomeMaterials; //  this is set when the biome is loaded by BiomeHelper<br>&emsp;&emsp;&emsp;&emsp;std::string mModifierUIDescription; //  this should be set when the biome has modifiers. will be displayed when entering the biome<br>&emsp;&emsp;&emsp;&emsp;std::string mModifierUIDecorationFile; //  this should be set when the biome has modifiers. UI 3-piece image to use when displaying modifier message when entering the biome<br>&emsp;&emsp;&emsp;&emsp;std::string mDebugFilename; //  the file this was loaded from<br>&emsp;&emsp;&emsp;&emsp;BIOME_TYPE::Enum type; //  0 = standard, 1 = bitmap level loading, loads the bitmap file<br>&emsp;&emsp;&emsp;&emsp;CavesSetup* BitmapCaves;<br>&emsp;&emsp;&emsp;&emsp;FOG_OF_WAR_TYPE::Enum fog_of_war_type; //  the way removing fog of war works in this biome<br>&emsp;&emsp;&emsp;&emsp;RandomizeMaterials* RandomMaterials; //  for wang tiles allows color -> random color transform<br>&emsp;&emsp;&emsp;&emsp;NOISE_TYPE::Enum noise_type; //  the style of the cave noise<br>&emsp;&emsp;&emsp;&emsp;GENERAL_NOISE::Enum mInsideNoiseType; //  the style of the inside noise<br>&emsp;&emsp;&emsp;&emsp;BiomeModifiers modifiers;<br>};<br>```]]> </xs:documentation> </xs:annotation>
			<xs:all>
				<xs:element name="modifiers" type="BiomeModifiers" minOccurs="0"/>
			</xs:all>
		<xs:attribute name="name" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string name; //  the name that is exposed to lua functions that spawn entities<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="background_image" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string background_image; //  path to the image file (texture) that is used for the background<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="background_edge_left" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string background_edge_left; //  if not empty, will use this image as the left edge<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="background_edge_right" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string background_edge_right; //  if not empty, will use this image as the right edge<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="background_edge_top" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string background_edge_top; //  if not empty, will use this image as the top edge<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="background_edge_bottom" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string background_edge_bottom; //  if not empty, will use this image as the bottom edge<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="background_edge_priority" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int background_edge_priority; //  if both biomes have edges defined, will use the one with higher priority (if priority is same, will compare (>) background_images)<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="background_use_neighbor" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool background_use_neighbor; //  if set will look for neighboring biomes and use their background image<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="background_image_height" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float background_image_height; //  height were the background image starts<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="limit_background_image" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool limit_background_image; //  Will limit the background image to start at the cave height<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="bitmap_noise_file" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string bitmap_noise_file; //  if set, loads it to mBitmapNoise<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="noise_biome_edges" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool noise_biome_edges; //  does the noisy edge for biomes, if either of biomes has this set to 0 will do a straight edge<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="big_noise_biome_edges" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool big_noise_biome_edges; //  if true, will leak onto other biomes and not be carveable<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fat_biome_edges" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool fat_biome_edges; //  if true, will leak onto other biomes and not be carveable<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="skip_edge_textures" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool skip_edge_textures; //  skips edge texture generation. Turn of for pixel scenes<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="audio_music_enter" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string audio_music_enter; //  the music event that plays when player enters this biome (e.g. 'music/desert/enter')<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="audio_music_2" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string audio_music_2; //  the music directory that plays while player is in this biome (e.g 'coalmine')<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="audio_music_energy_coeff" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float audio_music_energy_coeff; //  Multiplier for music energy in this biome<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="audio_music_no_forced_quietness" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool audio_music_no_forced_quietness; //  If 1, music is not quieted by occasional quietness<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="audio_music_forced_quietness_duration_seconds" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int32 audio_music_forced_quietness_duration_seconds; //  If > 0, this is the duration of occasional quietness, else the value from magic numbers is used.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="audio_music_trigger_without_danger" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool audio_music_trigger_without_danger; //  If 1, music is triggered in this biome no matter what the danger level is<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="audio_ambience" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string audio_ambience; //  the ambience event that plays while player is in this biome<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="audio_ambience_surface" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string audio_ambience_surface; //  the ambience event that plays while player is in this biome and on surface<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="color_grading_r" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float color_grading_r; //  post fx color grading<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="color_grading_g" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float color_grading_g; //  post fx color grading<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="color_grading_b" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float color_grading_b; //  post fx color grading<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="color_grading_grayscale" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float color_grading_grayscale; //  post fx color grading. [0.0,1.0], larger value means more grayscale<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="has_rain" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool has_rain; //  if 1, rain or snowfall may occur in this biome<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="bitmap_filename" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string bitmap_filename; //  loads the chunk from this bitmap, the bitmap should be 512x512<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="wang_template_file" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string wang_template_file; //  uses this file to create a herringbone wang map<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="wang_map_width" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int wang_map_width; //  the size of the wang map<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="wang_map_height" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int wang_map_height; //  the size of the wang map<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lua_script" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string lua_script; //  default is data/scripts/biomes/NAME.lua<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="pixel_scene" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool pixel_scene; //  for 'pixel scene' biomes, this forces the loading before hand <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="static_tile" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool static_tile; //  if 1, directly blits wang_template_file without wang randomization, kind of like a pixel scene but at the wang tile resolution<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="static_tile_bg_mask" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string static_tile_bg_mask; //  if set, and static tile is 1, the background_image will use a special shader and this mask to calculate visiblity. should be same size and resolution as 'wang_template_file'<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="static_tile_bg_mask_threshold" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float static_tile_bg_mask_threshold; //  threshold used in 'sprite_static_tile_bg.frag' shader in conjuction with 'sprite_static_tile_bg_mask' to determine if a background pixel is visible or not<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="game_enemy_hp_scale" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float game_enemy_hp_scale; //  1.f = default. Will multiply the hp of the camerabounded enemies in the area with hp_scale<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="game_enemy_attack_speed" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float game_enemy_attack_speed; //  1.f = default. This multiplies AnimalAI's attack_ranged_frames_between in camerabounded enemies<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mInsideNoiseFBM" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mInsideNoiseFBM; //  will fbm the mInsideNoise if set true<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mInsidePerlinScaleX" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>double mInsidePerlinScaleX; //  the noise inside the stones...<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mInsidePerlinScaleY" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>double mInsidePerlinScaleY; //  the noise inside the stones...<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mInsidePerlinSquared" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mInsidePerlinSquared;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mInsidePerlinClamped" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mInsidePerlinClamped;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mInsidePerlinScaled" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mInsidePerlinScaled;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mInsidePerlinScaleMin" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mInsidePerlinScaleMin;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mInsidePerlinScaleMax" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mInsidePerlinScaleMax;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mInsidePerlinForceInside" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mInsidePerlinForceInside; //  if set, will multiply the noise_value with the gradient value <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mInsidePerlinOffsetBySeed" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mInsidePerlinOffsetBySeed; //  NOTE( Petri ): 17.8.2023 - if set, will add worldseed as an offset to the noise<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mInsidePerlinOffsetX" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>double mInsidePerlinOffsetX; //  NOTE( Petri ): 17.8.2023 - perlin noise offset<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mInsidePerlinOffsetY" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>double mInsidePerlinOffsetY; //  NOTE( Petri ): 17.8.2023 - perlin noise offset<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mInsideAddValue" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mInsideAddValue; //  added inside the caves the gradient value<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mMultiplierGradient" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mMultiplierGradient; //  how much of the gradient is applied<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mMultiplierPerlin" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mMultiplierPerlin; //  how much of the inside noise<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mMultiplierExtraPerlin" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mMultiplierExtraPerlin;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mGradientStartY" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mGradientStartY;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mGradientEndY" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mGradientEndY;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mGradientSlopeStartX" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>double mGradientSlopeStartX; //  if addNoise = 3, will use this to the ( x - mGradientSlopeStartX ) * mGradientSlopeDelta<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mGradientSlopeDelta" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>double mGradientSlopeDelta; //  if addNoise = 3, will use this to the ( x - mGradientSlopeStartX ) * mGradientSlopeDelta<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mGradientAddNoise" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mGradientAddNoise; //  fake enum 1=standard noise, 2=fbm noise, 3=slope<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mGradientNoiseScale" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>double mGradientNoiseScale;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mGradientLowNoise" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mGradientLowNoise;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mGradientHighNoise" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mGradientHighNoise;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="coarse_map_force_terrain" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool coarse_map_force_terrain; //  if 1, is initially marked as 'terrain' in the coarse map used for sky light calculations etc<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="coarse_map_not_terrain" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool coarse_map_not_terrain; //  if 1, is initially never marked as 'terrain' in the coarse map used for sky light calculations etc<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="coarse_map_cell_count_always_zero" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool coarse_map_cell_count_always_zero; //  if 1, areas in this biome always have a 64x64 cell count of 0<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: ceng::CArray2D<uint32>* for bitmap_data -->
		<!-- Some Unknown Type: BitmapNoise* for mBitmapNoise -->
		<!-- Some Unknown Type: BiomeMaterials* for mBiomeMaterials -->
		<xs:attribute name="mModifierUIDescription" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string mModifierUIDescription; //  this should be set when the biome has modifiers. will be displayed when entering the biome<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mModifierUIDecorationFile" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string mModifierUIDecorationFile; //  this should be set when the biome has modifiers. UI 3-piece image to use when displaying modifier message when entering the biome<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mDebugFilename" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string mDebugFilename; //  the file this was loaded from<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="type" type="BIOME_TYPE" default="BIOME_PROCEDURAL">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>BIOME_TYPE::Enum type; //  0 = standard, 1 = bitmap level loading, loads the bitmap file<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: CavesSetup* for BitmapCaves -->
		<xs:attribute name="fog_of_war_type" type="FOG_OF_WAR_TYPE" default="DEFAULT">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>FOG_OF_WAR_TYPE::Enum fog_of_war_type; //  the way removing fog of war works in this biome<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: RandomizeMaterials* for RandomMaterials -->
		<xs:attribute name="noise_type" type="NOISE_TYPE" default="IQ2_SIMPLEX1234">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>NOISE_TYPE::Enum noise_type; //  the style of the cave noise<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mInsideNoiseType" type="GENERAL_NOISE" default="SimplexNoise">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>GENERAL_NOISE::Enum mInsideNoiseType; //  the style of the inside noise<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>

	</xs:complexType>
	<xs:complexType name="BiomeModifiers" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class BiomeModifiers {<br>&emsp;&emsp;&emsp;&emsp;float dust_amount; //  amount of dust rendered<br>&emsp;&emsp;&emsp;&emsp;float projectile_drag_coeff; //  projectile velocity is multiplied with this value every frame<br>&emsp;&emsp;&emsp;&emsp;float entity_gravity_y_multiplier; //  affects the VelocityComponents gravity_y<br>&emsp;&emsp;&emsp;&emsp;int8 fog_of_war_delta; //  fog of war change per frame<br>&emsp;&emsp;&emsp;&emsp;uint8 fire_extinguish_chance; //  probability of fire being extinguished per cell update<br>&emsp;&emsp;&emsp;&emsp;uint8 reaction_freeze_chance; //  probability of spontaneous freezing reactions per cell reaction update<br>&emsp;&emsp;&emsp;&emsp;uint8 reaction_unfreeze_chance; //  probability of spontaneous frozen material melting reactions per cell reaction update<br>&emsp;&emsp;&emsp;&emsp;uint8 random_water_stains_chance; //  probability of random water stains being added to characters<br>&emsp;&emsp;&emsp;&emsp;uint8 random_water_stains_amount; //  number of water cells added when adding random water stains<br>&emsp;&emsp;&emsp;&emsp;bool everything_is_conductive; //  if 1, every static material in this place conduct electricity<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="dust_amount" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float dust_amount; //  amount of dust rendered<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="projectile_drag_coeff" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float projectile_drag_coeff; //  projectile velocity is multiplied with this value every frame<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="entity_gravity_y_multiplier" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float entity_gravity_y_multiplier; //  affects the VelocityComponents gravity_y<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fog_of_war_delta" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int8 fog_of_war_delta; //  fog of war change per frame<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fire_extinguish_chance" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint8 fire_extinguish_chance; //  probability of fire being extinguished per cell update<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="reaction_freeze_chance" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint8 reaction_freeze_chance; //  probability of spontaneous freezing reactions per cell reaction update<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="reaction_unfreeze_chance" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint8 reaction_unfreeze_chance; //  probability of spontaneous frozen material melting reactions per cell reaction update<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="random_water_stains_chance" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint8 random_water_stains_chance; //  probability of random water stains being added to characters<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="random_water_stains_amount" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint8 random_water_stains_amount; //  number of water cells added when adding random water stains<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="everything_is_conductive" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool everything_is_conductive; //  if 1, every static material in this place conduct electricity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>

	</xs:complexType>
	<xs:complexType name="CavesSetup" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class CavesSetup {<br>&emsp;&emsp;&emsp;&emsp;std::string name; //  we share these based on the names, so make them unique<br>&emsp;&emsp;&emsp;&emsp;int size_x; //  How big the image is that we generate these from<br>&emsp;&emsp;&emsp;&emsp;int size_y; //  How big the image is that we generate these from<br>&emsp;&emsp;&emsp;&emsp;float spawn_percent; //  0-1 - with what chance do we add a spawn point to a cave<br>&emsp;&emsp;&emsp;&emsp;int cave_count_min; //  generates caves n, where n = random(cave_count_min, cave_count_max)<br>&emsp;&emsp;&emsp;&emsp;int cave_count_max; //  generates caves n, where n = random(cave_count_min, cave_count_max)<br>&emsp;&emsp;&emsp;&emsp;bool do_beginning_paths; //  if set, will do the paths that go down near the center of the image, used for setting up the caves to coal mines near where player starts<br>&emsp;&emsp;&emsp;&emsp;bool do_beginning_down; //  if true, will do a hole straight down<br>&emsp;&emsp;&emsp;&emsp;int surface_caves_count_min; //  generates caves n from the surface, where n = random(surface_caves_count_min, surface_caves_count_max)<br>&emsp;&emsp;&emsp;&emsp;int surface_caves_count_max; //  generates caves n from the surface, where n = random(surface_caves_count_min, surface_caves_count_max)<br>&emsp;&emsp;&emsp;&emsp;float cave_strength_min; //  how strongly do we carve the cave<br>&emsp;&emsp;&emsp;&emsp;float cave_strength_max; //  how strongly do we carve the cave<br>&emsp;&emsp;&emsp;&emsp;int cave_childs_min; //  how many child trails a cave can have<br>&emsp;&emsp;&emsp;&emsp;int cave_childs_max; //  how many child trails a cave can have<br>&emsp;&emsp;&emsp;&emsp;int surface_cave_childs_min; //  how many child trails a cave can have<br>&emsp;&emsp;&emsp;&emsp;int surface_cave_childs_max; //  how many child trails a cave can have<br>&emsp;&emsp;&emsp;&emsp;int mountain_count_min; //  how many child trails a cave can have<br>&emsp;&emsp;&emsp;&emsp;int mountain_count_max; //  how many child trails a cave can have<br>&emsp;&emsp;&emsp;&emsp;float mountain_size_min;<br>&emsp;&emsp;&emsp;&emsp;float mountain_size_max;<br>&emsp;&emsp;&emsp;&emsp;int blob_caves_count_min;<br>&emsp;&emsp;&emsp;&emsp;int blob_caves_count_max;<br>&emsp;&emsp;&emsp;&emsp;float blob_caves_strength_min;<br>&emsp;&emsp;&emsp;&emsp;float blob_caves_strength_max;<br>&emsp;&emsp;&emsp;&emsp;float blob_caves_radius_min;<br>&emsp;&emsp;&emsp;&emsp;float blob_caves_radius_max;<br>&emsp;&emsp;&emsp;&emsp;std::string DEBUG_output_image; //  if set, will save a png of the height map to the file specified here<br>&emsp;&emsp;&emsp;&emsp;std::string mLuaScript; //  this is the Biome::lua_script<br>&emsp;&emsp;&emsp;&emsp;VEC_STRUCTURES structures;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="name" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string name; //  we share these based on the names, so make them unique<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="size_x" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int size_x; //  How big the image is that we generate these from<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="size_y" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int size_y; //  How big the image is that we generate these from<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="spawn_percent" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float spawn_percent; //  0-1 - with what chance do we add a spawn point to a cave<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="cave_count_min" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int cave_count_min; //  generates caves n, where n = random(cave_count_min, cave_count_max)<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="cave_count_max" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int cave_count_max; //  generates caves n, where n = random(cave_count_min, cave_count_max)<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="do_beginning_paths" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool do_beginning_paths; //  if set, will do the paths that go down near the center of the image, used for setting up the caves to coal mines near where player starts<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="do_beginning_down" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool do_beginning_down; //  if true, will do a hole straight down<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="surface_caves_count_min" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int surface_caves_count_min; //  generates caves n from the surface, where n = random(surface_caves_count_min, surface_caves_count_max)<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="surface_caves_count_max" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int surface_caves_count_max; //  generates caves n from the surface, where n = random(surface_caves_count_min, surface_caves_count_max)<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="cave_strength_min" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float cave_strength_min; //  how strongly do we carve the cave<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="cave_strength_max" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float cave_strength_max; //  how strongly do we carve the cave<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="cave_childs_min" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int cave_childs_min; //  how many child trails a cave can have<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="cave_childs_max" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int cave_childs_max; //  how many child trails a cave can have<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="surface_cave_childs_min" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int surface_cave_childs_min; //  how many child trails a cave can have<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="surface_cave_childs_max" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int surface_cave_childs_max; //  how many child trails a cave can have<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mountain_count_min" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mountain_count_min; //  how many child trails a cave can have<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mountain_count_max" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mountain_count_max; //  how many child trails a cave can have<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mountain_size_min" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mountain_size_min;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mountain_size_max" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mountain_size_max;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="blob_caves_count_min" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int blob_caves_count_min;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="blob_caves_count_max" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int blob_caves_count_max;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="blob_caves_strength_min" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float blob_caves_strength_min;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="blob_caves_strength_max" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float blob_caves_strength_max;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="blob_caves_radius_min" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float blob_caves_radius_min;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="blob_caves_radius_max" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float blob_caves_radius_max;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="DEBUG_output_image" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string DEBUG_output_image; //  if set, will save a png of the height map to the file specified here<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLuaScript" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string mLuaScript; //  this is the Biome::lua_script<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: VEC_STRUCTURES for structures -->

	</xs:complexType>
	<xs:complexType name="CaveStructure" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class CaveStructure {<br>&emsp;&emsp;&emsp;&emsp;std::string image_file; //  path to image file that's going to be blitted<br>&emsp;&emsp;&emsp;&emsp;int count_min;<br>&emsp;&emsp;&emsp;&emsp;int count_max;<br>&emsp;&emsp;&emsp;&emsp;int aabb_min_x;<br>&emsp;&emsp;&emsp;&emsp;int aabb_min_y;<br>&emsp;&emsp;&emsp;&emsp;int aabb_max_x;<br>&emsp;&emsp;&emsp;&emsp;int aabb_max_y;<br>&emsp;&emsp;&emsp;&emsp;float strength_min;<br>&emsp;&emsp;&emsp;&emsp;float strength_max;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="image_file" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string image_file; //  path to image file that's going to be blitted<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="count_min" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int count_min;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="count_max" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int count_max;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="aabb_min_x" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int aabb_min_x;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="aabb_min_y" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int aabb_min_y;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="aabb_max_x" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int aabb_max_x;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="aabb_max_y" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int aabb_max_y;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="strength_min" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float strength_min;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="strength_max" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float strength_max;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>

	</xs:complexType>
	<xs:complexType name="ConfigCutThroughWorld" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ConfigCutThroughWorld {<br>&emsp;&emsp;&emsp;&emsp;int32 x;<br>&emsp;&emsp;&emsp;&emsp;int32 y_min;<br>&emsp;&emsp;&emsp;&emsp;int32 y_max;<br>&emsp;&emsp;&emsp;&emsp;int32 radius;<br>&emsp;&emsp;&emsp;&emsp;int32 edge_darkening_width;<br>&emsp;&emsp;&emsp;&emsp;uint32 global_id;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="x" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int32 x;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="y_min" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int32 y_min;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="y_max" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int32 y_max;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="radius" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int32 radius;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="edge_darkening_width" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int32 edge_darkening_width;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="global_id" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint32 global_id;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>

	</xs:complexType>
	<xs:complexType name="ConfigDamageCritical" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ConfigDamageCritical {<br>&emsp;&emsp;&emsp;&emsp;int chance; //  the chance of a critical hit. ]0-100[ - can be higher than 100% - then will multiply the multiplier by the extra<br>&emsp;&emsp;&emsp;&emsp;float damage_multiplier; //  multiplier that is applied to all damage types on a critical hit<br>&emsp;&emsp;&emsp;&emsp;bool mSucceeded;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="chance" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int chance; //  the chance of a critical hit. ]0-100[ - can be higher than 100% - then will multiply the multiplier by the extra<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_multiplier" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float damage_multiplier; //  multiplier that is applied to all damage types on a critical hit<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mSucceeded" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mSucceeded;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>

	</xs:complexType>
	<xs:complexType name="ConfigDamagesByType" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ConfigDamagesByType {<br>&emsp;&emsp;&emsp;&emsp;float melee;<br>&emsp;&emsp;&emsp;&emsp;float projectile;<br>&emsp;&emsp;&emsp;&emsp;float explosion;<br>&emsp;&emsp;&emsp;&emsp;float electricity; //  electricity stun effect is rand[0-1] < electricity<br>&emsp;&emsp;&emsp;&emsp;float fire;<br>&emsp;&emsp;&emsp;&emsp;float drill;<br>&emsp;&emsp;&emsp;&emsp;float slice;<br>&emsp;&emsp;&emsp;&emsp;float ice; //  freezing stun effect is rand[0-1] < ice<br>&emsp;&emsp;&emsp;&emsp;float healing; //  healing aka negative damage. this should be given as a negative value.<br>&emsp;&emsp;&emsp;&emsp;float physics_hit; //  damage from being hit with a physics object<br>&emsp;&emsp;&emsp;&emsp;float radioactive;<br>&emsp;&emsp;&emsp;&emsp;float poison;<br>&emsp;&emsp;&emsp;&emsp;float overeating;<br>&emsp;&emsp;&emsp;&emsp;float curse;<br>&emsp;&emsp;&emsp;&emsp;float holy; //  NOTE( Petri ): Added 18.7.2023. Just an extra type of damage<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="melee" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float melee;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="projectile" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float projectile;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="explosion" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float explosion;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="electricity" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float electricity; //  electricity stun effect is rand[0-1] < electricity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fire" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float fire;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="drill" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float drill;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="slice" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float slice;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ice" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float ice; //  freezing stun effect is rand[0-1] < ice<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="healing" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float healing; //  healing aka negative damage. this should be given as a negative value.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="physics_hit" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float physics_hit; //  damage from being hit with a physics object<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="radioactive" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float radioactive;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="poison" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float poison;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="overeating" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float overeating;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="curse" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float curse;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="holy" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float holy; //  NOTE( Petri ): Added 18.7.2023. Just an extra type of damage<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>

	</xs:complexType>
	<xs:complexType name="ConfigDrugFx" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ConfigDrugFx {<br>&emsp;&emsp;&emsp;&emsp;float distortion_amount;<br>&emsp;&emsp;&emsp;&emsp;float color_amount;<br>&emsp;&emsp;&emsp;&emsp;float fractals_amount;<br>&emsp;&emsp;&emsp;&emsp;float fractals_size;<br>&emsp;&emsp;&emsp;&emsp;float nightvision_amount;<br>&emsp;&emsp;&emsp;&emsp;float doublevision_amount;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="distortion_amount" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float distortion_amount;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="color_amount" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float color_amount;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fractals_amount" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float fractals_amount;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fractals_size" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float fractals_size;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="nightvision_amount" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float nightvision_amount;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="doublevision_amount" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float doublevision_amount;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>

	</xs:complexType>
	<xs:complexType name="ConfigExplosion" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ConfigExplosion {<br>&emsp;&emsp;&emsp;&emsp;bool never_cache; //  if set, won't ever cache and the explosion happens that frame. Used for projectiles<br>&emsp;&emsp;&emsp;&emsp;float explosion_radius; //  Explosion radius, used to find the peasants and physics bodies that are thrown into the air<br>&emsp;&emsp;&emsp;&emsp;std::string explosion_sprite; //  sprite animation of the explosion that we play<br>&emsp;&emsp;&emsp;&emsp;bool explosion_sprite_emissive; //  if 1, sprite is emissive<br>&emsp;&emsp;&emsp;&emsp;bool explosion_sprite_additive; //  if 1, sprite is additive<br>&emsp;&emsp;&emsp;&emsp;bool explosion_sprite_random_rotation; //  if true, rotates the sprite to random 90 degrees<br>&emsp;&emsp;&emsp;&emsp;float explosion_sprite_lifetime; //  if 0, finds the lifetime based on the rect animation currently playing. If not 0 it is seconds how long does the explosion sprite stay in the world<br>&emsp;&emsp;&emsp;&emsp;float damage; //  how much damage does this do to living entities<br>&emsp;&emsp;&emsp;&emsp;float camera_shake; //  camera shake - how much we shake the camera<br>&emsp;&emsp;&emsp;&emsp;bool particle_effect; //  Should we use the ParticleEffect::DoExplosion()<br>&emsp;&emsp;&emsp;&emsp;std::string load_this_entity; //  if set, this entity is loaded when the explosion is queued<br>&emsp;&emsp;&emsp;&emsp;bool light_enabled; //  Should the explosion emit light to its surroundings?<br>&emsp;&emsp;&emsp;&emsp;float light_fade_time; //  The time it takes for the light flash to fade out<br>&emsp;&emsp;&emsp;&emsp;unsignedint light_r; //  Color red 0-255<br>&emsp;&emsp;&emsp;&emsp;unsignedint light_g; //  Color green 0-255<br>&emsp;&emsp;&emsp;&emsp;unsignedint light_b; //  Color blue 0-255<br>&emsp;&emsp;&emsp;&emsp;float light_radius_coeff; //  The radius of the light will be explosion_radius * light_radius_coeff<br>&emsp;&emsp;&emsp;&emsp;bool hole_enabled; //  Do we remove ground, creata a crater<br>&emsp;&emsp;&emsp;&emsp;bool destroy_non_platform_solid_enabled; //  Do we remove solid cells that aren't platforms?<br>&emsp;&emsp;&emsp;&emsp;int electricity_count; //  How many electricity entitities should we create?<br>&emsp;&emsp;&emsp;&emsp;int min_radius_for_cracks; //  Cracks are created if explosion_radius is larger than this<br>&emsp;&emsp;&emsp;&emsp;int crack_count; //  How many crack entitities should we create?<br>&emsp;&emsp;&emsp;&emsp;float knockback_force; //  How far do entities get thrown if a knockback occurs? final_knocback = explosion_radius * knockback_force * target.inv_normalized_distance_from_explosion / target.mass<br>&emsp;&emsp;&emsp;&emsp;bool hole_destroy_liquid; //  Do we destroy the liquid cells we ran into, or do we just throw them into to the air?<br>&emsp;&emsp;&emsp;&emsp;bool hole_destroy_physics_dynamic; //  Do we destroy the dynamic physics cells we encountered?<br>&emsp;&emsp;&emsp;&emsp;std::string create_cell_material; //  The material destroyed cells might turn into.<br>&emsp;&emsp;&emsp;&emsp;int create_cell_probability; //  The probability a destroyed cell is turned into 'create_cell_material'<br>&emsp;&emsp;&emsp;&emsp;int background_lightning_count; //  Parallax background lightning count is set to this on explosion<br>&emsp;&emsp;&emsp;&emsp;std::string spark_material; //  spark material, TODO moved these to use a special Serializer<br>&emsp;&emsp;&emsp;&emsp;int material_sparks_min_hp; //  How many sparks are we creating (rand max)<br>&emsp;&emsp;&emsp;&emsp;int material_sparks_probability; //  How many sparks are we creating (rand max)<br>&emsp;&emsp;&emsp;&emsp;int material_sparks_count_min; //  How many sparks are we creating (rand min)<br>&emsp;&emsp;&emsp;&emsp;int material_sparks_count_max; //  How many sparks are we creating (rand max)<br>&emsp;&emsp;&emsp;&emsp;bool material_sparks_enabled; //  Should we create few fire particles around the explosion<br>&emsp;&emsp;&emsp;&emsp;bool material_sparks_real; //  if the spark particles created are real or fake<br>&emsp;&emsp;&emsp;&emsp;bool material_sparks_scale_with_hp; //  if true, will create more sparks the harder the material<br>&emsp;&emsp;&emsp;&emsp;bool sparks_enabled; //  Should we create few fire particles around the explosion<br>&emsp;&emsp;&emsp;&emsp;int sparks_count_min; //  How many sparks are we creating (rand min)<br>&emsp;&emsp;&emsp;&emsp;int sparks_count_max; //  How many sparks are we creating (rand max)<br>&emsp;&emsp;&emsp;&emsp;float sparks_inner_radius_coeff; //  If 'sparks_enabled', Sparks are created in the area between circles defined by 'explosion_radius'*'sparks_inner_radius_coeff' and 'explosion_radius'<br>&emsp;&emsp;&emsp;&emsp;bool stains_enabled; //  Should we stain the ground and other particles<br>&emsp;&emsp;&emsp;&emsp;float stains_radius; //  The distance from the edge of the hole to the edge of the stained area, 0.0f for default which is 0.3 * explosion_radius<br>&emsp;&emsp;&emsp;&emsp;int ray_energy; //  This is the energy we have per ray. Could be called 'penetration power' or something like that. If cells have a hp of 20 rays with 100 energy can penetrate 5 cells<br>&emsp;&emsp;&emsp;&emsp;int max_durability_to_destroy; //  When destroying cells only cells with a durability <= max_durability_to_destroy will be affected<br>&emsp;&emsp;&emsp;&emsp;int gore_particle_count; //  How many particles to create in case we do gore stuff?<br>&emsp;&emsp;&emsp;&emsp;bool shake_vegetation; //  Should we shake vegetation around the explosion (uses the area of stain_image to find vegetation)<br>&emsp;&emsp;&emsp;&emsp;bool damage_mortals; //  Look for peasants and throw them into the air? Remember to enabled physics_throw as well if you want them to actually fly<br>&emsp;&emsp;&emsp;&emsp;bool physics_throw_enabled; //  Should we throw physics objects into the air, also peasants<br>&emsp;&emsp;&emsp;&emsp;float physics_multiplier_ragdoll_force; //  treat the ragdolls a bit differently from other physics objects, to get them to fly nicely<br>&emsp;&emsp;&emsp;&emsp;float cell_explosion_power; //  used when a solid cell explodes as the multiplier to how big the radius is going to be<br>&emsp;&emsp;&emsp;&emsp;float cell_explosion_radius_min; //  when cell explodes, this is the minimum radius that explosion is made of<br>&emsp;&emsp;&emsp;&emsp;float cell_explosion_radius_max; //  when cell explodes, this is the minimum radius that explosion is made of<br>&emsp;&emsp;&emsp;&emsp;float cell_explosion_velocity_min; //  cell explodes only when body velocity is greater than this<br>&emsp;&emsp;&emsp;&emsp;float cell_explosion_damage_required; //  how much fire damage is required before this explodes<br>&emsp;&emsp;&emsp;&emsp;float cell_explosion_probability; //  this is used when there's a tiny contact that doesn't cause an explosion, in those cases this is used as a random to check if we should explode or not<br>&emsp;&emsp;&emsp;&emsp;float cell_explosion_power_ragdoll_coeff; //  ragdoll cells destruction power is multiplied with this<br>&emsp;&emsp;&emsp;&emsp;bool pixel_sprites_enabled; //  if enabled will carve out the pixel sprites<br>&emsp;&emsp;&emsp;&emsp;bool is_digger; //  if 1, we apply some special digger logic to this explosion<br>&emsp;&emsp;&emsp;&emsp;bool audio_enabled; //  Do we play an explosion sound?<br>&emsp;&emsp;&emsp;&emsp;std::string audio_event_name; //  Name of audio event in 'explosion' audio bank. If not set, will default to 'explosion' or 'explosion_small' based on explosion radius.<br>&emsp;&emsp;&emsp;&emsp;float audio_liquid_amount_normalized; //  value of the 'liquid_amount' parameter passed to the explosion's audio event<br>&emsp;&emsp;&emsp;&emsp;int explosion_delay_id; //  for delayed barrel explosions... this has to be set and has to be the same for the explosions for there to be a delay<br>&emsp;&emsp;&emsp;&emsp;EntityID who_is_responsible; //  the entity that caused the explosion<br>&emsp;&emsp;&emsp;&emsp;bool null_damage; //  if set, will not call DamageModelSystem::TakeDamage()<br>&emsp;&emsp;&emsp;&emsp;EntityID dont_damage_this; //  if set, this entity doesn't receive damage from the explosion<br>&emsp;&emsp;&emsp;&emsp;EntityID impl_send_message_to_this;<br>&emsp;&emsp;&emsp;&emsp;types_vector2 impl_position;<br>&emsp;&emsp;&emsp;&emsp;int32 impl_delay_frame;<br>&emsp;&emsp;&emsp;&emsp;ValueRange physics_explosion_power; //  how hard do we throw physics objects<br>&emsp;&emsp;&emsp;&emsp;ValueRangeInt delay; //  if > 0, the explosion occurs with a delay chosen randomly from this range and is never buffered<br>&emsp;&emsp;&emsp;&emsp;ConfigDamageCritical damage_critical; //  critical damage config. NOTE: must be already calculated ('chance' does nothing).<br>};<br>```]]> </xs:documentation> </xs:annotation>
			<xs:all>
				<xs:element name="damage_critical" type="ConfigDamageCritical" minOccurs="0"/>
			</xs:all>
		<xs:attribute name="never_cache" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool never_cache; //  if set, won't ever cache and the explosion happens that frame. Used for projectiles<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="explosion_radius" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float explosion_radius; //  Explosion radius, used to find the peasants and physics bodies that are thrown into the air<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="explosion_sprite" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string explosion_sprite; //  sprite animation of the explosion that we play<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="explosion_sprite_emissive" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool explosion_sprite_emissive; //  if 1, sprite is emissive<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="explosion_sprite_additive" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool explosion_sprite_additive; //  if 1, sprite is additive<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="explosion_sprite_random_rotation" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool explosion_sprite_random_rotation; //  if true, rotates the sprite to random 90 degrees<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="explosion_sprite_lifetime" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float explosion_sprite_lifetime; //  if 0, finds the lifetime based on the rect animation currently playing. If not 0 it is seconds how long does the explosion sprite stay in the world<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float damage; //  how much damage does this do to living entities<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="camera_shake" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float camera_shake; //  camera shake - how much we shake the camera<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="particle_effect" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool particle_effect; //  Should we use the ParticleEffect::DoExplosion()<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="load_this_entity" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string load_this_entity; //  if set, this entity is loaded when the explosion is queued<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="light_enabled" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool light_enabled; //  Should the explosion emit light to its surroundings?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="light_fade_time" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float light_fade_time; //  The time it takes for the light flash to fade out<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="light_r" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>unsignedint light_r; //  Color red 0-255<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="light_g" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>unsignedint light_g; //  Color green 0-255<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="light_b" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>unsignedint light_b; //  Color blue 0-255<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="light_radius_coeff" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float light_radius_coeff; //  The radius of the light will be explosion_radius * light_radius_coeff<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="hole_enabled" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool hole_enabled; //  Do we remove ground, creata a crater<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="destroy_non_platform_solid_enabled" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool destroy_non_platform_solid_enabled; //  Do we remove solid cells that aren't platforms?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="electricity_count" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int electricity_count; //  How many electricity entitities should we create?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="min_radius_for_cracks" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int min_radius_for_cracks; //  Cracks are created if explosion_radius is larger than this<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="crack_count" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int crack_count; //  How many crack entitities should we create?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="knockback_force" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float knockback_force; //  How far do entities get thrown if a knockback occurs? final_knocback = explosion_radius * knockback_force * target.inv_normalized_distance_from_explosion / target.mass<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="hole_destroy_liquid" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool hole_destroy_liquid; //  Do we destroy the liquid cells we ran into, or do we just throw them into to the air?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="hole_destroy_physics_dynamic" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool hole_destroy_physics_dynamic; //  Do we destroy the dynamic physics cells we encountered?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="create_cell_material" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string create_cell_material; //  The material destroyed cells might turn into.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="create_cell_probability" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int create_cell_probability; //  The probability a destroyed cell is turned into 'create_cell_material'<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="background_lightning_count" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int background_lightning_count; //  Parallax background lightning count is set to this on explosion<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="spark_material" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string spark_material; //  spark material, TODO moved these to use a special Serializer<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="material_sparks_min_hp" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int material_sparks_min_hp; //  How many sparks are we creating (rand max)<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="material_sparks_probability" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int material_sparks_probability; //  How many sparks are we creating (rand max)<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="material_sparks_count_min" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int material_sparks_count_min; //  How many sparks are we creating (rand min)<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="material_sparks_count_max" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int material_sparks_count_max; //  How many sparks are we creating (rand max)<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="material_sparks_enabled" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool material_sparks_enabled; //  Should we create few fire particles around the explosion<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="material_sparks_real" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool material_sparks_real; //  if the spark particles created are real or fake<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="material_sparks_scale_with_hp" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool material_sparks_scale_with_hp; //  if true, will create more sparks the harder the material<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="sparks_enabled" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool sparks_enabled; //  Should we create few fire particles around the explosion<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="sparks_count_min" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int sparks_count_min; //  How many sparks are we creating (rand min)<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="sparks_count_max" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int sparks_count_max; //  How many sparks are we creating (rand max)<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="sparks_inner_radius_coeff" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float sparks_inner_radius_coeff; //  If 'sparks_enabled', Sparks are created in the area between circles defined by 'explosion_radius'*'sparks_inner_radius_coeff' and 'explosion_radius'<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="stains_enabled" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool stains_enabled; //  Should we stain the ground and other particles<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="stains_radius" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float stains_radius; //  The distance from the edge of the hole to the edge of the stained area, 0.0f for default which is 0.3 * explosion_radius<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ray_energy" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int ray_energy; //  This is the energy we have per ray. Could be called 'penetration power' or something like that. If cells have a hp of 20 rays with 100 energy can penetrate 5 cells<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="max_durability_to_destroy" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int max_durability_to_destroy; //  When destroying cells only cells with a durability <= max_durability_to_destroy will be affected<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="gore_particle_count" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int gore_particle_count; //  How many particles to create in case we do gore stuff?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="shake_vegetation" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool shake_vegetation; //  Should we shake vegetation around the explosion (uses the area of stain_image to find vegetation)<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_mortals" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool damage_mortals; //  Look for peasants and throw them into the air? Remember to enabled physics_throw as well if you want them to actually fly<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="physics_throw_enabled" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool physics_throw_enabled; //  Should we throw physics objects into the air, also peasants<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="physics_multiplier_ragdoll_force" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float physics_multiplier_ragdoll_force; //  treat the ragdolls a bit differently from other physics objects, to get them to fly nicely<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="cell_explosion_power" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float cell_explosion_power; //  used when a solid cell explodes as the multiplier to how big the radius is going to be<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="cell_explosion_radius_min" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float cell_explosion_radius_min; //  when cell explodes, this is the minimum radius that explosion is made of<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="cell_explosion_radius_max" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float cell_explosion_radius_max; //  when cell explodes, this is the minimum radius that explosion is made of<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="cell_explosion_velocity_min" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float cell_explosion_velocity_min; //  cell explodes only when body velocity is greater than this<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="cell_explosion_damage_required" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float cell_explosion_damage_required; //  how much fire damage is required before this explodes<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="cell_explosion_probability" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float cell_explosion_probability; //  this is used when there's a tiny contact that doesn't cause an explosion, in those cases this is used as a random to check if we should explode or not<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="cell_explosion_power_ragdoll_coeff" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float cell_explosion_power_ragdoll_coeff; //  ragdoll cells destruction power is multiplied with this<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="pixel_sprites_enabled" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool pixel_sprites_enabled; //  if enabled will carve out the pixel sprites<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_digger" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_digger; //  if 1, we apply some special digger logic to this explosion<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="audio_enabled" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool audio_enabled; //  Do we play an explosion sound?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="audio_event_name" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string audio_event_name; //  Name of audio event in 'explosion' audio bank. If not set, will default to 'explosion' or 'explosion_small' based on explosion radius.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="audio_liquid_amount_normalized" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float audio_liquid_amount_normalized; //  value of the 'liquid_amount' parameter passed to the explosion's audio event<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="explosion_delay_id" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int explosion_delay_id; //  for delayed barrel explosions... this has to be set and has to be the same for the explosions for there to be a delay<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: EntityID for who_is_responsible -->
		<xs:attribute name="null_damage" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool null_damage; //  if set, will not call DamageModelSystem::TakeDamage()<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: EntityID for dont_damage_this -->
		<!-- Some Unknown Type: EntityID for impl_send_message_to_this -->
		<!-- Some Unknown Type: types_vector2 for impl_position -->
		<xs:attribute name="impl_delay_frame" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int32 impl_delay_frame;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="physics_explosion_power.min" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ValueRange physics_explosion_power; //  how hard do we throw physics objects<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="physics_explosion_power.max" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ValueRange physics_explosion_power; //  how hard do we throw physics objects<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="delay.min" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ValueRangeInt delay; //  if > 0, the explosion occurs with a delay chosen randomly from this range and is never buffered<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="delay.max" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ValueRangeInt delay; //  if > 0, the explosion occurs with a delay chosen randomly from this range and is never buffered<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>

	</xs:complexType>
	<xs:complexType name="ConfigGunActionInfo" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ConfigGunActionInfo {<br>&emsp;&emsp;&emsp;&emsp;std::string action_id;<br>&emsp;&emsp;&emsp;&emsp;std::string action_name;<br>&emsp;&emsp;&emsp;&emsp;std::string action_description;<br>&emsp;&emsp;&emsp;&emsp;std::string action_sprite_filename;<br>&emsp;&emsp;&emsp;&emsp;std::string action_unidentified_sprite_filename;<br>&emsp;&emsp;&emsp;&emsp;int action_type;<br>&emsp;&emsp;&emsp;&emsp;std::string action_spawn_level; //  comma separated values should match probabilities<br>&emsp;&emsp;&emsp;&emsp;std::string action_spawn_probability; //  comma separated values should match levels<br>&emsp;&emsp;&emsp;&emsp;std::string action_spawn_requires_flag; //  if set, requires that this persistent flag is set for spawn probablities to be something else than 0<br>&emsp;&emsp;&emsp;&emsp;bool action_spawn_manual_unlock; //  if true, will not automatically call AddFlagPersistent( action_spawn_requires_flag ) when this action is spawned. You must do it yourself! <br>&emsp;&emsp;&emsp;&emsp;int action_max_uses; //  -1 = infinite otherwise it's the amount specified<br>&emsp;&emsp;&emsp;&emsp;std::string custom_xml_file; //  if set, this will be used instead of 'action.xml'<br>&emsp;&emsp;&emsp;&emsp;float action_mana_drain; //  how much mana does this action drain?<br>&emsp;&emsp;&emsp;&emsp;bool action_is_dangerous_blast; //  TODO - is this used anywhere?<br>&emsp;&emsp;&emsp;&emsp;int action_draw_many_count;<br>&emsp;&emsp;&emsp;&emsp;bool action_ai_never_uses;<br>&emsp;&emsp;&emsp;&emsp;bool action_never_unlimited;<br>&emsp;&emsp;&emsp;&emsp;bool state_shuffled;<br>&emsp;&emsp;&emsp;&emsp;int state_cards_drawn;<br>&emsp;&emsp;&emsp;&emsp;bool state_discarded_action;<br>&emsp;&emsp;&emsp;&emsp;bool state_destroyed_action;<br>&emsp;&emsp;&emsp;&emsp;int fire_rate_wait;<br>&emsp;&emsp;&emsp;&emsp;float speed_multiplier;<br>&emsp;&emsp;&emsp;&emsp;float child_speed_multiplier;<br>&emsp;&emsp;&emsp;&emsp;float dampening;<br>&emsp;&emsp;&emsp;&emsp;float explosion_radius;<br>&emsp;&emsp;&emsp;&emsp;float spread_degrees; //  in 360 degrees, randomizes the direction of the bullet -spread_degrees to +spread_degrees<br>&emsp;&emsp;&emsp;&emsp;float pattern_degrees; //  in 360 degrees, if != 0, distributes the bullets to an even pattern from -pattern_degrees to +pattern_degrees<br>&emsp;&emsp;&emsp;&emsp;float screenshake;<br>&emsp;&emsp;&emsp;&emsp;float recoil;<br>&emsp;&emsp;&emsp;&emsp;float damage_melee_add; //  TODO - is this used anywhere?<br>&emsp;&emsp;&emsp;&emsp;float damage_projectile_add; //  if change to mul - take into account that default is 0<br>&emsp;&emsp;&emsp;&emsp;float damage_electricity_add;<br>&emsp;&emsp;&emsp;&emsp;float damage_fire_add; //  TODO - is this used anywhere?<br>&emsp;&emsp;&emsp;&emsp;float damage_explosion_add;<br>&emsp;&emsp;&emsp;&emsp;float damage_ice_add;<br>&emsp;&emsp;&emsp;&emsp;float damage_slice_add;<br>&emsp;&emsp;&emsp;&emsp;float damage_healing_add;<br>&emsp;&emsp;&emsp;&emsp;float damage_curse_add;<br>&emsp;&emsp;&emsp;&emsp;float damage_drill_add;<br>&emsp;&emsp;&emsp;&emsp;float damage_null_all; //  if > 0 then will set all damage to 0 and add a NullDamageComponent (that nullss the rest). The value is a percent (0.0-1.0) of what the chance is that everything will be nulled. 1 = always<br>&emsp;&emsp;&emsp;&emsp;int damage_critical_chance; //  the chance of a critical hit. ]0-100[<br>&emsp;&emsp;&emsp;&emsp;float damage_critical_multiplier; //  multiplier that is applied to all damage types on a critical hit<br>&emsp;&emsp;&emsp;&emsp;float explosion_damage_to_materials;<br>&emsp;&emsp;&emsp;&emsp;float knockback_force; //  how much knockback it does to enemies<br>&emsp;&emsp;&emsp;&emsp;int reload_time;<br>&emsp;&emsp;&emsp;&emsp;int lightning_count;<br>&emsp;&emsp;&emsp;&emsp;std::string material;<br>&emsp;&emsp;&emsp;&emsp;int material_amount;<br>&emsp;&emsp;&emsp;&emsp;std::string trail_material;<br>&emsp;&emsp;&emsp;&emsp;int trail_material_amount;<br>&emsp;&emsp;&emsp;&emsp;int bounces;<br>&emsp;&emsp;&emsp;&emsp;float gravity;<br>&emsp;&emsp;&emsp;&emsp;float light;<br>&emsp;&emsp;&emsp;&emsp;float blood_count_multiplier; //  ProjectileComponent has blood_count_multiplier, it tells how much blood is generated when this hits an entity. These are multiplied together...<br>&emsp;&emsp;&emsp;&emsp;int gore_particles; //  amount of blood particles generated by the explosion<br>&emsp;&emsp;&emsp;&emsp;int ragdoll_fx; //  ragdoll_fx of the projectile, selects the highest 1 = normal, 2 = gore<br>&emsp;&emsp;&emsp;&emsp;bool friendly_fire; //  if 1, will set friendly fire on to the bullet<br>&emsp;&emsp;&emsp;&emsp;float physics_impulse_coeff; //  projectile applies an impulse to physics bodies it hits. Impulse = physics_impulse_coeff * velocity<br>&emsp;&emsp;&emsp;&emsp;int lifetime_add;<br>&emsp;&emsp;&emsp;&emsp;std::string sprite;<br>&emsp;&emsp;&emsp;&emsp;std::string extra_entities; //  comma separated xml files, that are loaded into the projectile entity. Their components get added but nothing else from the xml files is loaded<br>&emsp;&emsp;&emsp;&emsp;std::string game_effect_entities; //  comma separated xml files, that have the game effects when they hit the entity<br>&emsp;&emsp;&emsp;&emsp;std::string sound_loop_tag; //  If wand has a SoundLoopComponent with this tag it will start playing when this is shot<br>&emsp;&emsp;&emsp;&emsp;std::string projectile_file;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="action_id" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string action_id;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="action_name" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string action_name;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="action_description" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string action_description;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="action_sprite_filename" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string action_sprite_filename;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="action_unidentified_sprite_filename" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string action_unidentified_sprite_filename;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="action_type" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int action_type;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="action_spawn_level" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string action_spawn_level; //  comma separated values should match probabilities<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="action_spawn_probability" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string action_spawn_probability; //  comma separated values should match levels<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="action_spawn_requires_flag" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string action_spawn_requires_flag; //  if set, requires that this persistent flag is set for spawn probablities to be something else than 0<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="action_spawn_manual_unlock" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool action_spawn_manual_unlock; //  if true, will not automatically call AddFlagPersistent( action_spawn_requires_flag ) when this action is spawned. You must do it yourself! <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="action_max_uses" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int action_max_uses; //  -1 = infinite otherwise it's the amount specified<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="custom_xml_file" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string custom_xml_file; //  if set, this will be used instead of 'action.xml'<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="action_mana_drain" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float action_mana_drain; //  how much mana does this action drain?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="action_is_dangerous_blast" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool action_is_dangerous_blast; //  TODO - is this used anywhere?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="action_draw_many_count" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int action_draw_many_count;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="action_ai_never_uses" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool action_ai_never_uses;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="action_never_unlimited" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool action_never_unlimited;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="state_shuffled" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool state_shuffled;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="state_cards_drawn" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int state_cards_drawn;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="state_discarded_action" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool state_discarded_action;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="state_destroyed_action" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool state_destroyed_action;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fire_rate_wait" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int fire_rate_wait;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="speed_multiplier" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float speed_multiplier;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="child_speed_multiplier" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float child_speed_multiplier;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="dampening" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float dampening;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="explosion_radius" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float explosion_radius;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="spread_degrees" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float spread_degrees; //  in 360 degrees, randomizes the direction of the bullet -spread_degrees to +spread_degrees<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="pattern_degrees" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float pattern_degrees; //  in 360 degrees, if != 0, distributes the bullets to an even pattern from -pattern_degrees to +pattern_degrees<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="screenshake" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float screenshake;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="recoil" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float recoil;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_melee_add" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float damage_melee_add; //  TODO - is this used anywhere?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_projectile_add" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float damage_projectile_add; //  if change to mul - take into account that default is 0<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_electricity_add" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float damage_electricity_add;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_fire_add" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float damage_fire_add; //  TODO - is this used anywhere?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_explosion_add" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float damage_explosion_add;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_ice_add" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float damage_ice_add;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_slice_add" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float damage_slice_add;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_healing_add" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float damage_healing_add;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_curse_add" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float damage_curse_add;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_drill_add" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float damage_drill_add;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_null_all" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float damage_null_all; //  if > 0 then will set all damage to 0 and add a NullDamageComponent (that nullss the rest). The value is a percent (0.0-1.0) of what the chance is that everything will be nulled. 1 = always<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_critical_chance" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int damage_critical_chance; //  the chance of a critical hit. ]0-100[<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_critical_multiplier" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float damage_critical_multiplier; //  multiplier that is applied to all damage types on a critical hit<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="explosion_damage_to_materials" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float explosion_damage_to_materials;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="knockback_force" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float knockback_force; //  how much knockback it does to enemies<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="reload_time" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int reload_time;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lightning_count" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int lightning_count;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="material" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string material;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="material_amount" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int material_amount;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="trail_material" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string trail_material;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="trail_material_amount" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int trail_material_amount;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="bounces" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int bounces;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="gravity" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float gravity;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="light" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float light;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="blood_count_multiplier" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float blood_count_multiplier; //  ProjectileComponent has blood_count_multiplier, it tells how much blood is generated when this hits an entity. These are multiplied together...<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="gore_particles" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int gore_particles; //  amount of blood particles generated by the explosion<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ragdoll_fx" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int ragdoll_fx; //  ragdoll_fx of the projectile, selects the highest 1 = normal, 2 = gore<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="friendly_fire" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool friendly_fire; //  if 1, will set friendly fire on to the bullet<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="physics_impulse_coeff" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float physics_impulse_coeff; //  projectile applies an impulse to physics bodies it hits. Impulse = physics_impulse_coeff * velocity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lifetime_add" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int lifetime_add;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="sprite" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string sprite;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="extra_entities" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string extra_entities; //  comma separated xml files, that are loaded into the projectile entity. Their components get added but nothing else from the xml files is loaded<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="game_effect_entities" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string game_effect_entities; //  comma separated xml files, that have the game effects when they hit the entity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="sound_loop_tag" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string sound_loop_tag; //  If wand has a SoundLoopComponent with this tag it will start playing when this is shot<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="projectile_file" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string projectile_file;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>

	</xs:complexType>
	<xs:complexType name="ConfigGun" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ConfigGun {<br>&emsp;&emsp;&emsp;&emsp;int actions_per_round;<br>&emsp;&emsp;&emsp;&emsp;bool shuffle_deck_when_empty;<br>&emsp;&emsp;&emsp;&emsp;int reload_time;<br>&emsp;&emsp;&emsp;&emsp;int deck_capacity; //  e.g. deck size, how many cards can be put into this gun<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="actions_per_round" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int actions_per_round;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="shuffle_deck_when_empty" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool shuffle_deck_when_empty;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="reload_time" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int reload_time;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="deck_capacity" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int deck_capacity; //  e.g. deck size, how many cards can be put into this gun<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>

	</xs:complexType>
	<xs:complexType name="ConfigLaser" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ConfigLaser {<br>&emsp;&emsp;&emsp;&emsp;int32 max_cell_durability_to_destroy;<br>&emsp;&emsp;&emsp;&emsp;uint32 damage_to_cells;<br>&emsp;&emsp;&emsp;&emsp;float max_length;<br>&emsp;&emsp;&emsp;&emsp;float beam_radius;<br>&emsp;&emsp;&emsp;&emsp;int32 beam_particle_chance;<br>&emsp;&emsp;&emsp;&emsp;float beam_particle_fade;<br>&emsp;&emsp;&emsp;&emsp;bool beam_particle_fade_reverse;<br>&emsp;&emsp;&emsp;&emsp;int32 hit_particle_chance;<br>&emsp;&emsp;&emsp;&emsp;bool audio_enabled;<br>&emsp;&emsp;&emsp;&emsp;bool audio_hit_always_enabled;<br>&emsp;&emsp;&emsp;&emsp;float damage_to_entities;<br>&emsp;&emsp;&emsp;&emsp;bool damage_apply_hitbox_dmg_multiplier; //  NOTE( Petri ): 20.6.2023 - laser emitters have by default skipped the HitboxComponent's damage_multiplier. Added this as a way to enable that multiplier. <br>&emsp;&emsp;&emsp;&emsp;bool root_entity_is_responsible_for_damage; //  If 1, damage from laser to entities will be treated as if it was caused by the laser emitter's root entity<br>&emsp;&emsp;&emsp;&emsp;int32 beam_particle_type;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="max_cell_durability_to_destroy" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int32 max_cell_durability_to_destroy;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_to_cells" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint32 damage_to_cells;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="max_length" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float max_length;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="beam_radius" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float beam_radius;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="beam_particle_chance" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int32 beam_particle_chance;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="beam_particle_fade" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float beam_particle_fade;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="beam_particle_fade_reverse" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool beam_particle_fade_reverse;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="hit_particle_chance" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int32 hit_particle_chance;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="audio_enabled" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool audio_enabled;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="audio_hit_always_enabled" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool audio_hit_always_enabled;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_to_entities" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float damage_to_entities;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_apply_hitbox_dmg_multiplier" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool damage_apply_hitbox_dmg_multiplier; //  NOTE( Petri ): 20.6.2023 - laser emitters have by default skipped the HitboxComponent's damage_multiplier. Added this as a way to enable that multiplier. <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="root_entity_is_responsible_for_damage" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool root_entity_is_responsible_for_damage; //  If 1, damage from laser to entities will be treated as if it was caused by the laser emitter's root entity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="beam_particle_type" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int32 beam_particle_type;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>

	</xs:complexType>
	<xs:complexType name="ConfigNpcParty" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ConfigNpcParty {<br>&emsp;&emsp;&emsp;&emsp;bool entities_exist;<br>&emsp;&emsp;&emsp;&emsp;int direction;<br>&emsp;&emsp;&emsp;&emsp;float speed;<br>&emsp;&emsp;&emsp;&emsp;types_vector2 position;<br>&emsp;&emsp;&emsp;&emsp;std::vector<EntityID> member_entities;<br>&emsp;&emsp;&emsp;&emsp;std::vector<std::string> member_files;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="entities_exist" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool entities_exist;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="direction" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int direction;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="speed" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float speed;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: types_vector2 for position -->
		<!-- Some Unknown Type: std::vector<EntityID> for member_entities -->
		<!-- Some Unknown Type: std::vector<std::string> for member_files -->

	</xs:complexType>
	<xs:complexType name="ConfigParallaxBackground" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ConfigParallaxBackground {<br>&emsp;&emsp;&emsp;&emsp;bool debug;<br>&emsp;&emsp;&emsp;&emsp;bool init_randomize;<br>&emsp;&emsp;&emsp;&emsp;float storm_clouds_pos_y_0;<br>&emsp;&emsp;&emsp;&emsp;float storm_clouds_pos_y_1;<br>&emsp;&emsp;&emsp;&emsp;float storm_alpha_0;<br>&emsp;&emsp;&emsp;&emsp;float storm_alpha_1;<br>&emsp;&emsp;&emsp;&emsp;float parallax_offset_y;<br>&emsp;&emsp;&emsp;&emsp;float mountains_01_offset_y;<br>&emsp;&emsp;&emsp;&emsp;float mountains_02_offset_y;<br>&emsp;&emsp;&emsp;&emsp;float clouds_01_offset_y_min;<br>&emsp;&emsp;&emsp;&emsp;float clouds_01_offset_y_max;<br>&emsp;&emsp;&emsp;&emsp;float clouds_02_offset_y_min;<br>&emsp;&emsp;&emsp;&emsp;float clouds_02_offset_y_max;<br>&emsp;&emsp;&emsp;&emsp;float gradient_sky_alpha;<br>&emsp;&emsp;&emsp;&emsp;float sunset_alpha;<br>&emsp;&emsp;&emsp;&emsp;float cloud_coeff;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="debug" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool debug;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="init_randomize" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool init_randomize;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="storm_clouds_pos_y_0" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float storm_clouds_pos_y_0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="storm_clouds_pos_y_1" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float storm_clouds_pos_y_1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="storm_alpha_0" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float storm_alpha_0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="storm_alpha_1" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float storm_alpha_1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="parallax_offset_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float parallax_offset_y;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mountains_01_offset_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mountains_01_offset_y;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mountains_02_offset_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mountains_02_offset_y;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="clouds_01_offset_y_min" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float clouds_01_offset_y_min;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="clouds_01_offset_y_max" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float clouds_01_offset_y_max;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="clouds_02_offset_y_min" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float clouds_02_offset_y_min;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="clouds_02_offset_y_max" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float clouds_02_offset_y_max;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="gradient_sky_alpha" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float gradient_sky_alpha;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="sunset_alpha" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float sunset_alpha;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="cloud_coeff" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float cloud_coeff;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>

	</xs:complexType>
	<xs:complexType name="ConfigPendingPortal" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ConfigPendingPortal {<br>&emsp;&emsp;&emsp;&emsp;uint32 id;<br>&emsp;&emsp;&emsp;&emsp;uint32 target_id;<br>&emsp;&emsp;&emsp;&emsp;bool is_at_home;<br>&emsp;&emsp;&emsp;&emsp;std::string target_biome_name;<br>&emsp;&emsp;&emsp;&emsp;Entity* entity;<br>&emsp;&emsp;&emsp;&emsp;types_vector2 position;<br>&emsp;&emsp;&emsp;&emsp;types_vector2 target_position;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="id" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint32 id;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="target_id" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint32 target_id;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_at_home" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_at_home;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="target_biome_name" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string target_biome_name;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: Entity* for entity -->
		<!-- Some Unknown Type: types_vector2 for position -->
		<!-- Some Unknown Type: types_vector2 for target_position -->

	</xs:complexType>
	<xs:complexType name="ConfigSound" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ConfigSound {<br>&emsp;&emsp;&emsp;&emsp;std::string file;<br>&emsp;&emsp;&emsp;&emsp;bool stream;<br>&emsp;&emsp;&emsp;&emsp;bool is_3d;<br>&emsp;&emsp;&emsp;&emsp;bool loop;<br>&emsp;&emsp;&emsp;&emsp;float random_volume_min;<br>&emsp;&emsp;&emsp;&emsp;float random_volume_max;<br>&emsp;&emsp;&emsp;&emsp;float random_pitch_min;<br>&emsp;&emsp;&emsp;&emsp;float random_pitch_max;<br>&emsp;&emsp;&emsp;&emsp;float min_distance;<br>&emsp;&emsp;&emsp;&emsp;float max_distance;<br>&emsp;&emsp;&emsp;&emsp;AUDIO_LAYER::Enum layer;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="file" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string file;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="stream" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool stream;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_3d" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_3d;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="loop" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool loop;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="random_volume_min" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float random_volume_min;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="random_volume_max" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float random_volume_max;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="random_pitch_min" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float random_pitch_min;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="random_pitch_max" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float random_pitch_max;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="min_distance" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float min_distance;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="max_distance" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float max_distance;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="layer" type="AUDIO_LAYER" default="EFFECT_GAME">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>AUDIO_LAYER::Enum layer;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>

	</xs:complexType>
	<xs:complexType name="DebugSettings" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class DebugSettings {<br>&emsp;&emsp;&emsp;&emsp;bool mDrawPathFindingGrid;<br>&emsp;&emsp;&emsp;&emsp;float DEBUG_RAGDOLL_EXTRA_FORCE;<br>&emsp;&emsp;&emsp;&emsp;bool mRenderPathFinding;<br>&emsp;&emsp;&emsp;&emsp;bool mPauseSimulation;<br>&emsp;&emsp;&emsp;&emsp;bool mPauseSomeSimulation;<br>&emsp;&emsp;&emsp;&emsp;bool mCameraFreeIsSmoothed;<br>&emsp;&emsp;&emsp;&emsp;bool mCameraIsLockedInGameplay;<br>&emsp;&emsp;&emsp;&emsp;bool camera_light;<br>&emsp;&emsp;&emsp;&emsp;bool mAllowCameraMoveWhenLocked;<br>&emsp;&emsp;&emsp;&emsp;bool mCameraDisableCameraShake;<br>&emsp;&emsp;&emsp;&emsp;float mCameraTargetOffsetY;<br>&emsp;&emsp;&emsp;&emsp;float mCameraTargetOffsetX;<br>&emsp;&emsp;&emsp;&emsp;bool mPostFxDisabled;<br>&emsp;&emsp;&emsp;&emsp;bool mGuiDisabled;<br>&emsp;&emsp;&emsp;&emsp;bool mGuiHalfSize;<br>&emsp;&emsp;&emsp;&emsp;bool mFogOfWarOpenEverywhere;<br>&emsp;&emsp;&emsp;&emsp;bool mTrailerMode;<br>&emsp;&emsp;&emsp;&emsp;bool mDayTimeRotationPaused;<br>&emsp;&emsp;&emsp;&emsp;bool mPlayerNeverDies;<br>&emsp;&emsp;&emsp;&emsp;bool mFreezeAI;<br>&emsp;&emsp;&emsp;&emsp;bool mGameAudioVisualization;<br>&emsp;&emsp;&emsp;&emsp;bool mGameMusicDebug;<br>&emsp;&emsp;&emsp;&emsp;bool mGameMusicDebugFades;<br>&emsp;&emsp;&emsp;&emsp;bool mAudioPerformanceDebug;<br>&emsp;&emsp;&emsp;&emsp;float B2_Friction;<br>&emsp;&emsp;&emsp;&emsp;float mRecordingCameraStartX;<br>&emsp;&emsp;&emsp;&emsp;float mRecordingCameraStartY;<br>&emsp;&emsp;&emsp;&emsp;bool GLOBAL_WE_ARE_DOING_RESET; //  used to track if we're doing the reset. cassert(false) in places <br>&emsp;&emsp;&emsp;&emsp;bool mSettingWasChanged;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="mDrawPathFindingGrid" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mDrawPathFindingGrid;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="DEBUG_RAGDOLL_EXTRA_FORCE" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float DEBUG_RAGDOLL_EXTRA_FORCE;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mRenderPathFinding" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mRenderPathFinding;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPauseSimulation" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mPauseSimulation;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPauseSomeSimulation" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mPauseSomeSimulation;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mCameraFreeIsSmoothed" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mCameraFreeIsSmoothed;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mCameraIsLockedInGameplay" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mCameraIsLockedInGameplay;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="camera_light" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool camera_light;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mAllowCameraMoveWhenLocked" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mAllowCameraMoveWhenLocked;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mCameraDisableCameraShake" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mCameraDisableCameraShake;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mCameraTargetOffsetY" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mCameraTargetOffsetY;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mCameraTargetOffsetX" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mCameraTargetOffsetX;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPostFxDisabled" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mPostFxDisabled;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mGuiDisabled" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mGuiDisabled;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mGuiHalfSize" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mGuiHalfSize;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mFogOfWarOpenEverywhere" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mFogOfWarOpenEverywhere;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mTrailerMode" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mTrailerMode;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mDayTimeRotationPaused" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mDayTimeRotationPaused;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPlayerNeverDies" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mPlayerNeverDies;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mFreezeAI" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mFreezeAI;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mGameAudioVisualization" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mGameAudioVisualization;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mGameMusicDebug" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mGameMusicDebug;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mGameMusicDebugFades" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mGameMusicDebugFades;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mAudioPerformanceDebug" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mAudioPerformanceDebug;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="B2_Friction" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float B2_Friction;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mRecordingCameraStartX" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mRecordingCameraStartX;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mRecordingCameraStartY" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mRecordingCameraStartY;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="GLOBAL_WE_ARE_DOING_RESET" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool GLOBAL_WE_ARE_DOING_RESET; //  used to track if we're doing the reset. cassert(false) in places <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mSettingWasChanged" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mSettingWasChanged;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>

	</xs:complexType>
	<xs:complexType name="DebugSettingsOllis" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class DebugSettingsOllis {<br>&emsp;&emsp;&emsp;&emsp;float airflow_lo_time;<br>&emsp;&emsp;&emsp;&emsp;float airflow_lo_scale;<br>&emsp;&emsp;&emsp;&emsp;float airflow_lo_force;<br>&emsp;&emsp;&emsp;&emsp;float airflow_hi_time;<br>&emsp;&emsp;&emsp;&emsp;float airflow_hi_scale;<br>&emsp;&emsp;&emsp;&emsp;float airflow_hi_force;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="airflow_lo_time" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float airflow_lo_time;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="airflow_lo_scale" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float airflow_lo_scale;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="airflow_lo_force" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float airflow_lo_force;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="airflow_hi_time" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float airflow_hi_time;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="airflow_hi_scale" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float airflow_hi_scale;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="airflow_hi_force" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float airflow_hi_force;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>

	</xs:complexType>
	<xs:complexType name="DebugSettingsPetrisDontTouchAndDontMoveToHeader" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class DebugSettingsPetrisDontTouchAndDontMoveToHeader {<br>&emsp;&emsp;&emsp;&emsp;bool LIMIT_VELOCITY; //  if true, will reload wang maps<br>&emsp;&emsp;&emsp;&emsp;bool REGEN_WANG_MAPS; //  if true, will reload wang maps<br>&emsp;&emsp;&emsp;&emsp;bool DISABLE_GRIDWORLD_RENDERING; //  disables the rendering so you can check the backgrounds in peace<br>&emsp;&emsp;&emsp;&emsp;float SWIMMING_FORCE;<br>&emsp;&emsp;&emsp;&emsp;int8 test;<br>&emsp;&emsp;&emsp;&emsp;uint8 test2;<br>&emsp;&emsp;&emsp;&emsp;bool draw_game_stats;<br>&emsp;&emsp;&emsp;&emsp;bool DEBUG_LOAD_ALL_ENTITIES; //  CODE WILL TOGGLE THIS OFF AFTER THE EXECUTION! <br>&emsp;&emsp;&emsp;&emsp;bool mDrawUpdateRects;<br>&emsp;&emsp;&emsp;&emsp;bool mDrawBox2D;<br>&emsp;&emsp;&emsp;&emsp;bool mDrawBox2DAABB;<br>&emsp;&emsp;&emsp;&emsp;bool mDrawBox2DVelocities;<br>&emsp;&emsp;&emsp;&emsp;bool mDrawBox2DForces;<br>&emsp;&emsp;&emsp;&emsp;bool mDrawBox2DMassDensity;<br>&emsp;&emsp;&emsp;&emsp;bool mDrawBox2DCollisionGroups;<br>&emsp;&emsp;&emsp;&emsp;bool mDrawJoints;<br>&emsp;&emsp;&emsp;&emsp;bool mBox2DMousePick;<br>&emsp;&emsp;&emsp;&emsp;bool mDebugEnabled;<br>&emsp;&emsp;&emsp;&emsp;bool mDebugKeysEnabled;<br>&emsp;&emsp;&emsp;&emsp;bool mDrawEntities;<br>&emsp;&emsp;&emsp;&emsp;float mEntityScale;<br>&emsp;&emsp;&emsp;&emsp;bool mEntityDrawTags;<br>&emsp;&emsp;&emsp;&emsp;bool mEntityDrawFilename;<br>&emsp;&emsp;&emsp;&emsp;bool mDrawWorldChunks;<br>&emsp;&emsp;&emsp;&emsp;float mDrawWorldChunksScale;<br>&emsp;&emsp;&emsp;&emsp;float mDrawWorldChunksPosX;<br>&emsp;&emsp;&emsp;&emsp;float mDrawWorldChunksPosY;<br>&emsp;&emsp;&emsp;&emsp;bool mDrawBiomeHeight;<br>&emsp;&emsp;&emsp;&emsp;bool mDraw64x64CellCounts;<br>&emsp;&emsp;&emsp;&emsp;bool mDrawWangMap;<br>&emsp;&emsp;&emsp;&emsp;bool draw_wang_colors;<br>&emsp;&emsp;&emsp;&emsp;float mWangMapScale;<br>&emsp;&emsp;&emsp;&emsp;float mWangMapAlpha;<br>&emsp;&emsp;&emsp;&emsp;bool mDebugSpamRandomEntities;<br>&emsp;&emsp;&emsp;&emsp;bool do_edge;<br>&emsp;&emsp;&emsp;&emsp;float physics_impulse_limit;<br>&emsp;&emsp;&emsp;&emsp;float physics_multiplier;<br>&emsp;&emsp;&emsp;&emsp;float physics_pos_x;<br>&emsp;&emsp;&emsp;&emsp;float physics_pos_y;<br>&emsp;&emsp;&emsp;&emsp;float physics_throw_str;<br>&emsp;&emsp;&emsp;&emsp;int physics_damage_frames;<br>&emsp;&emsp;&emsp;&emsp;float physics_damage_coeff;<br>&emsp;&emsp;&emsp;&emsp;int player_flying_frames;<br>&emsp;&emsp;&emsp;&emsp;bool memory_leak_im_gui;<br>&emsp;&emsp;&emsp;&emsp;bool display_cell_velocities;<br>&emsp;&emsp;&emsp;&emsp;bool mDoingVideoCapture;<br>&emsp;&emsp;&emsp;&emsp;bool DISABLE_ANIMAL_AI;<br>&emsp;&emsp;&emsp;&emsp;std::vector<std::string> mRandomEntities;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="LIMIT_VELOCITY" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool LIMIT_VELOCITY; //  if true, will reload wang maps<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="REGEN_WANG_MAPS" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool REGEN_WANG_MAPS; //  if true, will reload wang maps<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="DISABLE_GRIDWORLD_RENDERING" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool DISABLE_GRIDWORLD_RENDERING; //  disables the rendering so you can check the backgrounds in peace<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="SWIMMING_FORCE" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float SWIMMING_FORCE;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="test" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int8 test;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="test2" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint8 test2;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="draw_game_stats" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool draw_game_stats;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="DEBUG_LOAD_ALL_ENTITIES" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool DEBUG_LOAD_ALL_ENTITIES; //  CODE WILL TOGGLE THIS OFF AFTER THE EXECUTION! <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mDrawUpdateRects" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mDrawUpdateRects;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mDrawBox2D" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mDrawBox2D;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mDrawBox2DAABB" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mDrawBox2DAABB;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mDrawBox2DVelocities" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mDrawBox2DVelocities;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mDrawBox2DForces" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mDrawBox2DForces;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mDrawBox2DMassDensity" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mDrawBox2DMassDensity;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mDrawBox2DCollisionGroups" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mDrawBox2DCollisionGroups;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mDrawJoints" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mDrawJoints;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mBox2DMousePick" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mBox2DMousePick;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mDebugEnabled" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mDebugEnabled;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mDebugKeysEnabled" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mDebugKeysEnabled;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mDrawEntities" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mDrawEntities;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mEntityScale" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mEntityScale;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mEntityDrawTags" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mEntityDrawTags;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mEntityDrawFilename" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mEntityDrawFilename;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mDrawWorldChunks" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mDrawWorldChunks;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mDrawWorldChunksScale" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mDrawWorldChunksScale;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mDrawWorldChunksPosX" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mDrawWorldChunksPosX;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mDrawWorldChunksPosY" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mDrawWorldChunksPosY;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mDrawBiomeHeight" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mDrawBiomeHeight;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mDraw64x64CellCounts" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mDraw64x64CellCounts;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mDrawWangMap" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mDrawWangMap;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="draw_wang_colors" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool draw_wang_colors;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mWangMapScale" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mWangMapScale;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mWangMapAlpha" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mWangMapAlpha;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mDebugSpamRandomEntities" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mDebugSpamRandomEntities;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="do_edge" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool do_edge;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="physics_impulse_limit" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float physics_impulse_limit;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="physics_multiplier" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float physics_multiplier;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="physics_pos_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float physics_pos_x;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="physics_pos_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float physics_pos_y;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="physics_throw_str" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float physics_throw_str;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="physics_damage_frames" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int physics_damage_frames;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="physics_damage_coeff" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float physics_damage_coeff;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="player_flying_frames" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int player_flying_frames;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="memory_leak_im_gui" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool memory_leak_im_gui;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="display_cell_velocities" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool display_cell_velocities;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mDoingVideoCapture" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mDoingVideoCapture;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="DISABLE_ANIMAL_AI" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool DISABLE_ANIMAL_AI;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: std::vector<std::string> for mRandomEntities -->

	</xs:complexType>
	<xs:complexType name="GameStats" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class GameStats {<br>&emsp;&emsp;&emsp;&emsp;bool dead; //  is player dead?<br>&emsp;&emsp;&emsp;&emsp;int death_count; //  for global<br>&emsp;&emsp;&emsp;&emsp;int streaks; //  tracks winning streaks<br>&emsp;&emsp;&emsp;&emsp;uint32 world_seed; //  writes the world seed that is in use<br>&emsp;&emsp;&emsp;&emsp;std::string killed_by;<br>&emsp;&emsp;&emsp;&emsp;std::string killed_by_extra;<br>&emsp;&emsp;&emsp;&emsp;double playtime; //  session playtime in seconds, this does not include time in menus<br>&emsp;&emsp;&emsp;&emsp;std::string playtime_str; //  session playtime as a string<br>&emsp;&emsp;&emsp;&emsp;int places_visited; //  places visited<br>&emsp;&emsp;&emsp;&emsp;int enemies_killed;<br>&emsp;&emsp;&emsp;&emsp;int heart_containers;<br>&emsp;&emsp;&emsp;&emsp;int64 hp; //  max hp<br>&emsp;&emsp;&emsp;&emsp;int64 gold;<br>&emsp;&emsp;&emsp;&emsp;int64 gold_all; //  all gold, not just what's currently in players inventory<br>&emsp;&emsp;&emsp;&emsp;bool gold_infinite; //  will be set to true if all of the money is unlocked <br>&emsp;&emsp;&emsp;&emsp;int items; //  wands,potions,actions<br>&emsp;&emsp;&emsp;&emsp;int projectiles_shot; //  player, how many projectiles shot?<br>&emsp;&emsp;&emsp;&emsp;int kicks; //  player, kick count<br>&emsp;&emsp;&emsp;&emsp;double damage_taken; //  total damage taken<br>&emsp;&emsp;&emsp;&emsp;double healed; //  when player is healed (by healer, or some other thing, it's tracked here, BUG: Healing liquid isn't tracked here<br>&emsp;&emsp;&emsp;&emsp;int teleports; //  how many times have we teleported, this is bugged out right now, teleport projectiles are not counted<br>&emsp;&emsp;&emsp;&emsp;int wands_edited; //  how many wands player has edited<br>&emsp;&emsp;&emsp;&emsp;int biomes_visited_with_wands; //  used to figure out if a player played a no-wands-run, tracks how many biomes has player entered with wands. Hills doesn't fire Message_VisitedNewBiome so it doesn't count.<br>&emsp;&emsp;&emsp;&emsp;types_vector2 death_pos;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="dead" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool dead; //  is player dead?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="death_count" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int death_count; //  for global<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="streaks" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int streaks; //  tracks winning streaks<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="world_seed" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint32 world_seed; //  writes the world seed that is in use<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="killed_by" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string killed_by;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="killed_by_extra" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string killed_by_extra;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="playtime" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>double playtime; //  session playtime in seconds, this does not include time in menus<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="playtime_str" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string playtime_str; //  session playtime as a string<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="places_visited" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int places_visited; //  places visited<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="enemies_killed" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int enemies_killed;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="heart_containers" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int heart_containers;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="hp" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int64 hp; //  max hp<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="gold" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int64 gold;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="gold_all" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int64 gold_all; //  all gold, not just what's currently in players inventory<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="gold_infinite" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool gold_infinite; //  will be set to true if all of the money is unlocked <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="items" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int items; //  wands,potions,actions<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="projectiles_shot" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int projectiles_shot; //  player, how many projectiles shot?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="kicks" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int kicks; //  player, kick count<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_taken" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>double damage_taken; //  total damage taken<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="healed" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>double healed; //  when player is healed (by healer, or some other thing, it's tracked here, BUG: Healing liquid isn't tracked here<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="teleports" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int teleports; //  how many times have we teleported, this is bugged out right now, teleport projectiles are not counted<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="wands_edited" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int wands_edited; //  how many wands player has edited<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="biomes_visited_with_wands" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int biomes_visited_with_wands; //  used to figure out if a player played a no-wands-run, tracks how many biomes has player entered with wands. Hills doesn't fire Message_VisitedNewBiome so it doesn't count.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: types_vector2 for death_pos -->

	</xs:complexType>
	<xs:complexType name="GlobalStats" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class GlobalStats {<br>&emsp;&emsp;&emsp;&emsp;int STATS_VERSION; //  used to help with stats parsing<br>&emsp;&emsp;&emsp;&emsp;int DEBUG_HOW_MANY_RESETS; //  how many times have reset this?<br>&emsp;&emsp;&emsp;&emsp;bool DEBUG_FIXED_STATS; //  this gets set true, if -fix_stats has been used<br>&emsp;&emsp;&emsp;&emsp;bool session_dead; //  is player dead?<br>&emsp;&emsp;&emsp;&emsp;int DEBUG_HOW_MANY_TIMES_DONE; //  debug tracker<br>&emsp;&emsp;&emsp;&emsp;bool DEBUG_IS_ON; //  is debug on<br>&emsp;&emsp;&emsp;&emsp;STATS_KEY_VALUE_MAP KEY_VALUE_STATS; //  tracks causes and counts<br>&emsp;&emsp;&emsp;&emsp;GameStats session; //  the current run stats<br>&emsp;&emsp;&emsp;&emsp;GameStats highest; //  stores the highest values of each<br>&emsp;&emsp;&emsp;&emsp;GameStats global; //  stores the total value of each<br>&emsp;&emsp;&emsp;&emsp;GameStats prev_best; //  stores the total value of each<br>};<br>```]]> </xs:documentation> </xs:annotation>
			<xs:all>
				<xs:element name="session" type="GameStats" minOccurs="0"/>
				<xs:element name="highest" type="GameStats" minOccurs="0"/>
				<xs:element name="global" type="GameStats" minOccurs="0"/>
				<xs:element name="prev_best" type="GameStats" minOccurs="0"/>
			</xs:all>
		<xs:attribute name="STATS_VERSION" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int STATS_VERSION; //  used to help with stats parsing<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="DEBUG_HOW_MANY_RESETS" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int DEBUG_HOW_MANY_RESETS; //  how many times have reset this?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="DEBUG_FIXED_STATS" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool DEBUG_FIXED_STATS; //  this gets set true, if -fix_stats has been used<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="session_dead" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool session_dead; //  is player dead?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="DEBUG_HOW_MANY_TIMES_DONE" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int DEBUG_HOW_MANY_TIMES_DONE; //  debug tracker<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="DEBUG_IS_ON" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool DEBUG_IS_ON; //  is debug on<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: STATS_KEY_VALUE_MAP for KEY_VALUE_STATS -->

	</xs:complexType>
	<xs:complexType name="CosmeticParticleConfig" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class CosmeticParticleConfig {<br>&emsp;&emsp;&emsp;&emsp;int m_material_id;<br>&emsp;&emsp;&emsp;&emsp;bool cosmetic_force_create;<br>&emsp;&emsp;&emsp;&emsp;bool render_back;<br>&emsp;&emsp;&emsp;&emsp;bool render_on_grid;<br>&emsp;&emsp;&emsp;&emsp;bool draw_as_long;<br>&emsp;&emsp;&emsp;&emsp;float airflow_force;<br>&emsp;&emsp;&emsp;&emsp;float airflow_scale;<br>&emsp;&emsp;&emsp;&emsp;float friction;<br>&emsp;&emsp;&emsp;&emsp;float probability;<br>&emsp;&emsp;&emsp;&emsp;bool particle_single_width;<br>&emsp;&emsp;&emsp;&emsp;bool fade_based_on_lifetime;<br>&emsp;&emsp;&emsp;&emsp;types_vector2 vel;<br>&emsp;&emsp;&emsp;&emsp;types::aabb vel_random;<br>&emsp;&emsp;&emsp;&emsp;uint32 color; //  if something else than 0 will use this color<br>&emsp;&emsp;&emsp;&emsp;ValueRange lifetime;<br>&emsp;&emsp;&emsp;&emsp;types_vector2 gravity;<br>&emsp;&emsp;&emsp;&emsp;ValueRangeInt count;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="m_material_id" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int m_material_id;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="cosmetic_force_create" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool cosmetic_force_create;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="render_back" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool render_back;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="render_on_grid" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool render_on_grid;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="draw_as_long" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool draw_as_long;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="airflow_force" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float airflow_force;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="airflow_scale" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float airflow_scale;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="friction" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float friction;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="probability" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float probability;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="particle_single_width" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool particle_single_width;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fade_based_on_lifetime" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool fade_based_on_lifetime;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: types_vector2 for vel -->
		<xs:attribute name="vel_random.min_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>types::aabb vel_random;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="vel_random.min_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>types::aabb vel_random;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="vel_random.max_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>types::aabb vel_random;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="vel_random.max_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>types::aabb vel_random;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="color" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint32 color; //  if something else than 0 will use this color<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lifetime.min" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ValueRange lifetime;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lifetime.max" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ValueRange lifetime;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: types_vector2 for gravity -->
		<xs:attribute name="count.min" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ValueRangeInt count;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="count.max" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ValueRangeInt count;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>

	</xs:complexType>
	<xs:complexType name="ConfigItemStats" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ConfigItemStats {<br>&emsp;&emsp;&emsp;&emsp;std::string name;<br>&emsp;&emsp;&emsp;&emsp;bool count_as_item_pickup;<br>&emsp;&emsp;&emsp;&emsp;types_vector2 pos;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="name" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string name;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="count_as_item_pickup" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool count_as_item_pickup;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: types_vector2 for pos -->

	</xs:complexType>
	<xs:complexType name="ConfigPlayerStats" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ConfigPlayerStats {<br>&emsp;&emsp;&emsp;&emsp;std::string BUILD_NAME; //  build name from the macro<br>&emsp;&emsp;&emsp;&emsp;STATS_ITEM_MAP item_map; //  just a map of all the items picked up<br>&emsp;&emsp;&emsp;&emsp;STATS_DEATH_MAP biomes_visited; //  tracks biomes visited, second value is how many times, but that bugs out with save/load<br>&emsp;&emsp;&emsp;&emsp;GameStats stats; //  stores sessions stats<br>&emsp;&emsp;&emsp;&emsp;GameStats biome_baseline; //  stores biome baseline for sessions stats<br>};<br>```]]> </xs:documentation> </xs:annotation>
			<xs:all>
				<xs:element name="stats" type="GameStats" minOccurs="0"/>
				<xs:element name="biome_baseline" type="GameStats" minOccurs="0"/>
			</xs:all>
		<xs:attribute name="BUILD_NAME" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string BUILD_NAME; //  build name from the macro<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: STATS_ITEM_MAP for item_map -->
		<!-- Some Unknown Type: STATS_DEATH_MAP for biomes_visited -->

	</xs:complexType>
	<xs:complexType name="ConfigStats" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ConfigStats {<br>&emsp;&emsp;&emsp;&emsp;int deaths; //  total deaths (by whom ever)<br>&emsp;&emsp;&emsp;&emsp;int player_kills; //  how many times has killed player<br>&emsp;&emsp;&emsp;&emsp;int player_projectile_count; //  how many times has projectiles been fired<br>&emsp;&emsp;&emsp;&emsp;int kills; //  how many kills to we have all together<br>&emsp;&emsp;&emsp;&emsp;STATS_DEATH_MAP death_map; //  tracks causes and counts<br>&emsp;&emsp;&emsp;&emsp;STATS_DEATH_MAP kill_map; //  tracks who we've killed and how many times<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="deaths" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int deaths; //  total deaths (by whom ever)<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="player_kills" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int player_kills; //  how many times has killed player<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="player_projectile_count" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int player_projectile_count; //  how many times has projectiles been fired<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="kills" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int kills; //  how many kills to we have all together<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: STATS_DEATH_MAP for death_map -->
		<!-- Some Unknown Type: STATS_DEATH_MAP for kill_map -->

	</xs:complexType>
	<xs:complexType name="AIAttackComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class AIAttackComponent {<br>&emsp;&emsp;&emsp;&emsp;int use_probability = 100; // [0, 100] The probability for using this attack if it's otherwise possible<br>&emsp;&emsp;&emsp;&emsp;float min_distance = 10; // [0, 10000] The minimum distance from enemy at which we can perform this attack.<br>&emsp;&emsp;&emsp;&emsp;float max_distance = 160; // [0, 10000] The maximum distance from enemy at which we can perform this attack.<br>&emsp;&emsp;&emsp;&emsp;float angular_range_deg = 90; // [0, 90] When looking for threats/prey this is our field of view around the X axis. 90 means we scan the whole 180 degrees around the X axis, to the left and right.<br>&emsp;&emsp;&emsp;&emsp;int state_duration_frames = 45; // [0, 1000] How long do we stay in the attack state, before other states are allowed?<br>&emsp;&emsp;&emsp;&emsp;int frames_between = 180; // [0, 1000] The minimum number of frames we wait between these attacks<br>&emsp;&emsp;&emsp;&emsp;int frames_between_global = 30; // [0, 1000] The minimum number of frames we wait after this attack before doing any other ranged attack<br>&emsp;&emsp;&emsp;&emsp;std::string animation_name = "attack_ranged"; //  The animation to play when performing this attack<br>&emsp;&emsp;&emsp;&emsp;bool attack_landing_ranged_enabled = 0; //  If 1, we try to land before doing the attack, if there's ground near nearby under us<br>&emsp;&emsp;&emsp;&emsp;int attack_ranged_action_frame = 2; // [0, 1000] The frame of the 'attack_ranged' animation during which the ranged attack actually occurs<br>&emsp;&emsp;&emsp;&emsp;float attack_ranged_offset_x = 0; // [-1000, 1000] 'attack_ranged_entity_file' is created here when performing a ranged attack<br>&emsp;&emsp;&emsp;&emsp;float attack_ranged_offset_y = 0; // [-1000, 1000] 'attack_ranged_entity_file' is created here when performing a ranged attack<br>&emsp;&emsp;&emsp;&emsp;float attack_ranged_root_offset_x = 0; // [-1000, 1000] <br>&emsp;&emsp;&emsp;&emsp;float attack_ranged_root_offset_y = 0; // [-1000, 1000] <br>&emsp;&emsp;&emsp;&emsp;bool attack_ranged_use_message = 0; //  If 1, we do ranged attacks by sending a Message_UseItem<br>&emsp;&emsp;&emsp;&emsp;bool attack_ranged_predict = 0; //  If 1, we attempt to predict target movement and shoot accordingly<br>&emsp;&emsp;&emsp;&emsp;std::string attack_ranged_entity_file = "data/entities/projectiles/spear.xml"; //  File to projectile entity that is created when performing a ranged attack<br>&emsp;&emsp;&emsp;&emsp;int attack_ranged_entity_count_min = 1; // [0, 1000] Minimum number of projectiles shot when performing a ranged attack<br>&emsp;&emsp;&emsp;&emsp;int attack_ranged_entity_count_max = 1; // [0, 1000] Maximum number of projectiles shot when performing a ranged attack<br>&emsp;&emsp;&emsp;&emsp;bool attack_ranged_use_laser_sight = 0; //  If 1, we draw a laser sight to our target. Requires entity to have a sprite with tag 'laser_sight'<br>&emsp;&emsp;&emsp;&emsp;bool attack_ranged_aim_rotation_enabled = 0; //  If 1, we use a laser sight<br>&emsp;&emsp;&emsp;&emsp;float attack_ranged_aim_rotation_speed = 3; //  How fast can we rotate our aim to track targets<br>&emsp;&emsp;&emsp;&emsp;float attack_ranged_aim_rotation_shooting_ok_angle_deg = 10; //  If our aim is closer than this to the target we shoot<br>&emsp;&emsp;&emsp;&emsp;float mRangedAttackCurrentAimAngle = 0; //  which direction does our gun currently point at, physically saying?<br>&emsp;&emsp;&emsp;&emsp;int mNextFrameUsable = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="use_probability" type="xs:int" default="100">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int use_probability = 100; // [0, 100] The probability for using this attack if it's otherwise possible<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="min_distance" type="xs:decimal" default="10">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float min_distance = 10; // [0, 10000] The minimum distance from enemy at which we can perform this attack.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="max_distance" type="xs:decimal" default="160">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float max_distance = 160; // [0, 10000] The maximum distance from enemy at which we can perform this attack.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="angular_range_deg" type="xs:decimal" default="90">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float angular_range_deg = 90; // [0, 90] When looking for threats/prey this is our field of view around the X axis. 90 means we scan the whole 180 degrees around the X axis, to the left and right.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="state_duration_frames" type="xs:int" default="45">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int state_duration_frames = 45; // [0, 1000] How long do we stay in the attack state, before other states are allowed?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="frames_between" type="xs:int" default="180">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int frames_between = 180; // [0, 1000] The minimum number of frames we wait between these attacks<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="frames_between_global" type="xs:int" default="30">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int frames_between_global = 30; // [0, 1000] The minimum number of frames we wait after this attack before doing any other ranged attack<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="animation_name" type="xs:string" default="attack_ranged">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string animation_name = "attack_ranged"; //  The animation to play when performing this attack<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_landing_ranged_enabled" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool attack_landing_ranged_enabled = 0; //  If 1, we try to land before doing the attack, if there's ground near nearby under us<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_ranged_action_frame" type="xs:int" default="2">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int attack_ranged_action_frame = 2; // [0, 1000] The frame of the 'attack_ranged' animation during which the ranged attack actually occurs<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_ranged_offset_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float attack_ranged_offset_x = 0; // [-1000, 1000] 'attack_ranged_entity_file' is created here when performing a ranged attack<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_ranged_offset_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float attack_ranged_offset_y = 0; // [-1000, 1000] 'attack_ranged_entity_file' is created here when performing a ranged attack<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_ranged_root_offset_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float attack_ranged_root_offset_x = 0; // [-1000, 1000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_ranged_root_offset_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float attack_ranged_root_offset_y = 0; // [-1000, 1000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_ranged_use_message" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool attack_ranged_use_message = 0; //  If 1, we do ranged attacks by sending a Message_UseItem<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_ranged_predict" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool attack_ranged_predict = 0; //  If 1, we attempt to predict target movement and shoot accordingly<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_ranged_entity_file" type="xs:string" default="data/entities/projectiles/spear.xml">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string attack_ranged_entity_file = "data/entities/projectiles/spear.xml"; //  File to projectile entity that is created when performing a ranged attack<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_ranged_entity_count_min" type="xs:int" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int attack_ranged_entity_count_min = 1; // [0, 1000] Minimum number of projectiles shot when performing a ranged attack<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_ranged_entity_count_max" type="xs:int" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int attack_ranged_entity_count_max = 1; // [0, 1000] Maximum number of projectiles shot when performing a ranged attack<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_ranged_use_laser_sight" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool attack_ranged_use_laser_sight = 0; //  If 1, we draw a laser sight to our target. Requires entity to have a sprite with tag 'laser_sight'<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_ranged_aim_rotation_enabled" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool attack_ranged_aim_rotation_enabled = 0; //  If 1, we use a laser sight<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_ranged_aim_rotation_speed" type="xs:decimal" default="3">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float attack_ranged_aim_rotation_speed = 3; //  How fast can we rotate our aim to track targets<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_ranged_aim_rotation_shooting_ok_angle_deg" type="xs:decimal" default="10">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float attack_ranged_aim_rotation_shooting_ok_angle_deg = 10; //  If our aim is closer than this to the target we shoot<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mRangedAttackCurrentAimAngle" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mRangedAttackCurrentAimAngle = 0; //  which direction does our gun currently point at, physically saying?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mNextFrameUsable" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mNextFrameUsable = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="AIComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class AIComponent {<br>&emsp;&emsp;&emsp;&emsp;float TEMP_TEMP_TEMP = 0; // [0, 3.5] <br>&emsp;&emsp;&emsp;&emsp;AIData* data;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="TEMP_TEMP_TEMP" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float TEMP_TEMP_TEMP = 0; // [0, 3.5] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: AIData* for data -->
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="AbilityComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class AbilityComponent {<br>&emsp;&emsp;&emsp;&emsp;int cooldown_frames = 0; // [0, 60000] <br>&emsp;&emsp;&emsp;&emsp;std::string entity_file; //  the projectile entity file<br>&emsp;&emsp;&emsp;&emsp;std::string sprite_file;<br>&emsp;&emsp;&emsp;&emsp;int entity_count = 1; // [0, 60000] <br>&emsp;&emsp;&emsp;&emsp;bool never_reload = 0;<br>&emsp;&emsp;&emsp;&emsp;int reload_time_frames = 0;<br>&emsp;&emsp;&emsp;&emsp;float mana = 0;<br>&emsp;&emsp;&emsp;&emsp;float mana_max = 100;<br>&emsp;&emsp;&emsp;&emsp;float mana_charge_speed = 10;<br>&emsp;&emsp;&emsp;&emsp;bool rotate_in_hand = 1;<br>&emsp;&emsp;&emsp;&emsp;float rotate_in_hand_amount = 1; //  [0-1], how much does the item rotate related to the actual aiming angle<br>&emsp;&emsp;&emsp;&emsp;float rotate_hand_amount = 0.7; //  [0-1], how much does hand sprite rotate related to the actual aiming angle<br>&emsp;&emsp;&emsp;&emsp;bool fast_projectile = 0; //  if 1, then the velocity of the bullet is increased quite a bit. Lightning requires this<br>&emsp;&emsp;&emsp;&emsp;float swim_propel_amount = 0; // [-1000, 1000] <br>&emsp;&emsp;&emsp;&emsp;int max_charged_actions = 0;<br>&emsp;&emsp;&emsp;&emsp;int charge_wait_frames = 10;<br>&emsp;&emsp;&emsp;&emsp;float item_recoil_recovery_speed = 15; //  How quickly does the item return to resting state after getting recoil<br>&emsp;&emsp;&emsp;&emsp;float item_recoil_max = 1; //  Maximum distance moved by recoil<br>&emsp;&emsp;&emsp;&emsp;float item_recoil_offset_coeff = 1; //  Item distance moved by recoil = mItemRecoil * item_recoil_offset_coeff<br>&emsp;&emsp;&emsp;&emsp;float item_recoil_rotation_coeff = 5; //  Item rotation by recoil = mItemRecoil * item_recoil_rotation_coeff<br>&emsp;&emsp;&emsp;&emsp;std::string base_item_file = "data/entities/base_item.xml"; //  when dropping / throwing the item, this is the base_item that we add the ability component to<br>&emsp;&emsp;&emsp;&emsp;bool use_entity_file_as_projectile_info_proxy = 0;<br>&emsp;&emsp;&emsp;&emsp;bool click_to_use = 1;<br>&emsp;&emsp;&emsp;&emsp;int stat_times_player_has_shot = 0; //  used to track how many times player has shot this 'ability'<br>&emsp;&emsp;&emsp;&emsp;int stat_times_player_has_edited = 0; //  used to track how many times this has been edited<br>&emsp;&emsp;&emsp;&emsp;bool shooting_reduces_amount_in_inventory = 0;<br>&emsp;&emsp;&emsp;&emsp;bool throw_as_item = 0;<br>&emsp;&emsp;&emsp;&emsp;bool simulate_throw_as_item = 0; //  If 1, the item will be work as normal ability, but throwing animation is played by the user<br>&emsp;&emsp;&emsp;&emsp;int max_amount_in_inventory = 1;<br>&emsp;&emsp;&emsp;&emsp;int amount_in_inventory = 1;<br>&emsp;&emsp;&emsp;&emsp;bool drop_as_item_on_death = 1;<br>&emsp;&emsp;&emsp;&emsp;std::string ui_name = "[NOT_SET]"; //  way to name the weapons<br>&emsp;&emsp;&emsp;&emsp;bool use_gun_script = 0; //  If 1, the default ability behaviour is replaced with one that uses the lua gun system.<br>&emsp;&emsp;&emsp;&emsp;bool is_petris_gun = 0; //  if 1, TODO( PETRI)<br>&emsp;&emsp;&emsp;&emsp;int gun_level = 1; // [1, 10] the level of the wand, set in gun_procedural.lua<br>&emsp;&emsp;&emsp;&emsp;std::string add_these_child_actions; //  e.g. 'bullet,bullet,damage' ... actions are parsed into a string. These are added as actual entities when the item is initialized<br>&emsp;&emsp;&emsp;&emsp;int current_slot_durability = -1; //  After this many slots the last slot of the gun is removed. -1 means not initialized/infinite.<br>&emsp;&emsp;&emsp;&emsp;std_string slot_consumption_function = _get_gun_slot_durability_default; //  Name of the lua function in 'gun.lua' that is called to calculate durability of the last slot in the gun<br>&emsp;&emsp;&emsp;&emsp;int mNextFrameUsable = 0; //  hax, don't touch!<br>&emsp;&emsp;&emsp;&emsp;int mCastDelayStartFrame = 0; //  hax, don't touch!<br>&emsp;&emsp;&emsp;&emsp;int mReloadFramesLeft = 0; //  hax, don't touch!<br>&emsp;&emsp;&emsp;&emsp;int mReloadNextFrameUsable = 0; //  hax, don't touch!<br>&emsp;&emsp;&emsp;&emsp;int mChargeCount = 0; //  hax, don't touch!<br>&emsp;&emsp;&emsp;&emsp;bool mIsInitialized = 0;<br>&emsp;&emsp;&emsp;&emsp;ConfigGun gun_config; //  Constants for gun script<br>&emsp;&emsp;&emsp;&emsp;ConfigGunActionInfo gunaction_config; //  Constants for gun script<br>&emsp;&emsp;&emsp;&emsp;int mAmmoLeft = 0;<br>&emsp;&emsp;&emsp;&emsp;int mNextChargeFrame = 0;<br>&emsp;&emsp;&emsp;&emsp;float mItemRecoil = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
			<xs:all>
				<xs:element name="gun_config" type="ConfigGun" minOccurs="0"/>
				<xs:element name="gunaction_config" type="ConfigGunActionInfo" minOccurs="0"/>
			</xs:all>
		<xs:attribute name="cooldown_frames" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int cooldown_frames = 0; // [0, 60000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="entity_file" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string entity_file; //  the projectile entity file<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="sprite_file" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string sprite_file;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="entity_count" type="xs:int" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int entity_count = 1; // [0, 60000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="never_reload" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool never_reload = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="reload_time_frames" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int reload_time_frames = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mana" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mana = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mana_max" type="xs:decimal" default="100">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mana_max = 100;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mana_charge_speed" type="xs:decimal" default="10">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mana_charge_speed = 10;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="rotate_in_hand" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool rotate_in_hand = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="rotate_in_hand_amount" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float rotate_in_hand_amount = 1; //  [0-1], how much does the item rotate related to the actual aiming angle<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="rotate_hand_amount" type="xs:decimal" default="0.7">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float rotate_hand_amount = 0.7; //  [0-1], how much does hand sprite rotate related to the actual aiming angle<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fast_projectile" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool fast_projectile = 0; //  if 1, then the velocity of the bullet is increased quite a bit. Lightning requires this<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="swim_propel_amount" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float swim_propel_amount = 0; // [-1000, 1000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="max_charged_actions" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int max_charged_actions = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="charge_wait_frames" type="xs:int" default="10">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int charge_wait_frames = 10;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="item_recoil_recovery_speed" type="xs:decimal" default="15">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float item_recoil_recovery_speed = 15; //  How quickly does the item return to resting state after getting recoil<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="item_recoil_max" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float item_recoil_max = 1; //  Maximum distance moved by recoil<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="item_recoil_offset_coeff" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float item_recoil_offset_coeff = 1; //  Item distance moved by recoil = mItemRecoil * item_recoil_offset_coeff<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="item_recoil_rotation_coeff" type="xs:decimal" default="5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float item_recoil_rotation_coeff = 5; //  Item rotation by recoil = mItemRecoil * item_recoil_rotation_coeff<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="base_item_file" type="xs:string" default="data/entities/base_item.xml">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string base_item_file = "data/entities/base_item.xml"; //  when dropping / throwing the item, this is the base_item that we add the ability component to<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="use_entity_file_as_projectile_info_proxy" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool use_entity_file_as_projectile_info_proxy = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="click_to_use" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool click_to_use = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="stat_times_player_has_shot" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int stat_times_player_has_shot = 0; //  used to track how many times player has shot this 'ability'<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="stat_times_player_has_edited" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int stat_times_player_has_edited = 0; //  used to track how many times this has been edited<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="shooting_reduces_amount_in_inventory" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool shooting_reduces_amount_in_inventory = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="throw_as_item" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool throw_as_item = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="simulate_throw_as_item" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool simulate_throw_as_item = 0; //  If 1, the item will be work as normal ability, but throwing animation is played by the user<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="max_amount_in_inventory" type="xs:int" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int max_amount_in_inventory = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="amount_in_inventory" type="xs:int" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int amount_in_inventory = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="drop_as_item_on_death" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool drop_as_item_on_death = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ui_name" type="xs:string" default="[NOT_SET]">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string ui_name = "[NOT_SET]"; //  way to name the weapons<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="use_gun_script" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool use_gun_script = 0; //  If 1, the default ability behaviour is replaced with one that uses the lua gun system.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_petris_gun" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_petris_gun = 0; //  if 1, TODO( PETRI)<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="gun_level" type="xs:int" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int gun_level = 1; // [1, 10] the level of the wand, set in gun_procedural.lua<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="add_these_child_actions" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string add_these_child_actions; //  e.g. 'bullet,bullet,damage' ... actions are parsed into a string. These are added as actual entities when the item is initialized<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="current_slot_durability" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int current_slot_durability = -1; //  After this many slots the last slot of the gun is removed. -1 means not initialized/infinite.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="slot_consumption_function" type="xs:string" default="_get_gun_slot_durability_default">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std_string slot_consumption_function = _get_gun_slot_durability_default; //  Name of the lua function in 'gun.lua' that is called to calculate durability of the last slot in the gun<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mNextFrameUsable" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mNextFrameUsable = 0; //  hax, don't touch!<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mCastDelayStartFrame" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mCastDelayStartFrame = 0; //  hax, don't touch!<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mReloadFramesLeft" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mReloadFramesLeft = 0; //  hax, don't touch!<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mReloadNextFrameUsable" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mReloadNextFrameUsable = 0; //  hax, don't touch!<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mChargeCount" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mChargeCount = 0; //  hax, don't touch!<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mIsInitialized" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mIsInitialized = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mAmmoLeft" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mAmmoLeft = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mNextChargeFrame" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mNextChargeFrame = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mItemRecoil" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mItemRecoil = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="AdvancedFishAIComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class AdvancedFishAIComponent {<br>&emsp;&emsp;&emsp;&emsp;float move_check_range_min = 16; // [0, 2] <br>&emsp;&emsp;&emsp;&emsp;float move_check_range_max = 64; // [0, 2] <br>&emsp;&emsp;&emsp;&emsp;bool flock = 1;<br>&emsp;&emsp;&emsp;&emsp;bool avoid_predators = 1;<br>&emsp;&emsp;&emsp;&emsp;bool mHasTargetDirection = 0;<br>&emsp;&emsp;&emsp;&emsp;vec2 mTargetPos;<br>&emsp;&emsp;&emsp;&emsp;vec2 mTargetVec;<br>&emsp;&emsp;&emsp;&emsp;vec2 mLastFramesMovementAreaMin;<br>&emsp;&emsp;&emsp;&emsp;vec2 mLastFramesMovementAreaMax;<br>&emsp;&emsp;&emsp;&emsp;uint32 mNumFailedTargetSearches = 0;<br>&emsp;&emsp;&emsp;&emsp;int mNextFrameCheckAreWeStuck = -1;<br>&emsp;&emsp;&emsp;&emsp;int mNextFrameCheckFlockWants = -1;<br>&emsp;&emsp;&emsp;&emsp;int mNextFramePredatorAvoidance = -1;<br>&emsp;&emsp;&emsp;&emsp;float mScared = 0;<br>&emsp;&emsp;&emsp;&emsp;bool mWantsToBeInFlock = 1;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="move_check_range_min" type="xs:decimal" default="16">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float move_check_range_min = 16; // [0, 2] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="move_check_range_max" type="xs:decimal" default="64">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float move_check_range_max = 64; // [0, 2] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="flock" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool flock = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="avoid_predators" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool avoid_predators = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mHasTargetDirection" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mHasTargetDirection = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mTargetPos.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mTargetPos;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mTargetPos.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mTargetPos;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mTargetVec.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mTargetVec;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mTargetVec.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mTargetVec;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLastFramesMovementAreaMin.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mLastFramesMovementAreaMin;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLastFramesMovementAreaMin.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mLastFramesMovementAreaMin;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLastFramesMovementAreaMax.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mLastFramesMovementAreaMax;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLastFramesMovementAreaMax.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mLastFramesMovementAreaMax;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mNumFailedTargetSearches" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint32 mNumFailedTargetSearches = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mNextFrameCheckAreWeStuck" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mNextFrameCheckAreWeStuck = -1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mNextFrameCheckFlockWants" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mNextFrameCheckFlockWants = -1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mNextFramePredatorAvoidance" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mNextFramePredatorAvoidance = -1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mScared" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mScared = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mWantsToBeInFlock" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mWantsToBeInFlock = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="AltarComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class AltarComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string recognized_entity_tags;<br>&emsp;&emsp;&emsp;&emsp;int uses_remaining = 3;<br>&emsp;&emsp;&emsp;&emsp;int good_fx_material = 0; //  String name of material for particles emitted on successful sacrifice<br>&emsp;&emsp;&emsp;&emsp;int neutral_fx_material = 0; //  String name of material for particles emitted on successful sacrifice<br>&emsp;&emsp;&emsp;&emsp;int evil_fx_material = 0; //  String name of material for particles emitted on successful sacrifice<br>&emsp;&emsp;&emsp;&emsp;EntityTags m_recognized_entity_tags;<br>&emsp;&emsp;&emsp;&emsp;uint32 m_recognized_entity_tags_count = 0;<br>&emsp;&emsp;&emsp;&emsp;EntityTags m_current_entity_tags;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="recognized_entity_tags" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string recognized_entity_tags;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="uses_remaining" type="xs:int" default="3">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int uses_remaining = 3;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="good_fx_material" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int good_fx_material = 0; //  String name of material for particles emitted on successful sacrifice<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="neutral_fx_material" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int neutral_fx_material = 0; //  String name of material for particles emitted on successful sacrifice<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="evil_fx_material" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int evil_fx_material = 0; //  String name of material for particles emitted on successful sacrifice<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: EntityTags for m_recognized_entity_tags -->
		<xs:attribute name="m_recognized_entity_tags_count" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint32 m_recognized_entity_tags_count = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: EntityTags for m_current_entity_tags -->
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="AnimalAIComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class AnimalAIComponent {<br>&emsp;&emsp;&emsp;&emsp;int ai_state = 0; // [0, 20] Current state of ai, defines what the animal is doing<br>&emsp;&emsp;&emsp;&emsp;int ai_state_timer = 0; // [0, 1000] If not 0, then we wait till this frame to pop current state from our state stack<br>&emsp;&emsp;&emsp;&emsp;bool keep_state_alive_when_enabled = 0; //  if 1, will ensure state timer keeps current state alive for a while when Component is Enabled<br>&emsp;&emsp;&emsp;&emsp;std::string preferred_job; //  We always do this job, unless interrupted (i.e. by taking fire damage)<br>&emsp;&emsp;&emsp;&emsp;int escape_if_damaged_probability = 30; //  the chance of escaping if someone damages us. only works if 'can_fly = 0 '<br>&emsp;&emsp;&emsp;&emsp;int attack_if_damaged_probability = 100; //  the chance of counter-attacking if someone damages us, and we didn't escape<br>&emsp;&emsp;&emsp;&emsp;int eye_offset_x = 0; // [-100, 100] We cast rays from our position + eye_offset to check if we can see something<br>&emsp;&emsp;&emsp;&emsp;int eye_offset_y = 0; // [-100, 100] We cast rays from our position + eye_offset to check if we can see something<br>&emsp;&emsp;&emsp;&emsp;bool attack_only_if_attacked = 0; //  If 1, we never attack anyone unless attacked before by someone<br>&emsp;&emsp;&emsp;&emsp;bool dont_counter_attack_own_herd = 0; //  If 1, we don't attack members of our herd even if they accidentally attack us<br>&emsp;&emsp;&emsp;&emsp;float creature_detection_range_x = 50; // [0, 2000] When looking for threats/prey this is the max distance from us on the X axis we scan<br>&emsp;&emsp;&emsp;&emsp;float creature_detection_range_y = 20; // [0, 2000] When looking for threats/prey this is the max distance from us on the Y axis we scan<br>&emsp;&emsp;&emsp;&emsp;float creature_detection_angular_range_deg = 90; // [0, 90] When looking for threats/prey this is our field of view around the X axis. 90 means we scan the whole 180 degrees around the X axis, to the left and right<br>&emsp;&emsp;&emsp;&emsp;int creature_detection_check_every_x_frames = 120; // [0, 5000] Checks for threats/prey take place at least this many frames apart from each other<br>&emsp;&emsp;&emsp;&emsp;float max_distance_to_cam_to_start_hunting = 300; // [0, 2000] JobDefault idles before we've been once at least this close to the camera<br>&emsp;&emsp;&emsp;&emsp;int pathfinding_max_depth_no_target = 50; // [0, 5000] The maximum depth (in nodes) path search use when we have not found prey yet<br>&emsp;&emsp;&emsp;&emsp;int pathfinding_max_depth_has_target = 120; // [0, 5000] The maximum depth (in nodes) path search use when we have found prey<br>&emsp;&emsp;&emsp;&emsp;float aggressiveness_min = 80; // [0, 100] what's the initial random aggressiveness of this creature<br>&emsp;&emsp;&emsp;&emsp;float aggressiveness_max = 100; // [0, 100] what's the initial random aggressiveness of this creature<br>&emsp;&emsp;&emsp;&emsp;bool tries_to_ranged_attack_friends = 0; //  if 1, the AI tries to attack whoever it considers a friend based on herd_ids, CHARMED and BERSERK status etc. useful e.g. for healers.<br>&emsp;&emsp;&emsp;&emsp;bool attack_melee_enabled = 1; //  If 1, and melee attack has been configured, we can perform melee attacks<br>&emsp;&emsp;&emsp;&emsp;bool attack_dash_enabled = 0; //  If 1, and dash attack has been configured, we can perform dash attacks (a long-distance melee attack where we dash towards the enemy)<br>&emsp;&emsp;&emsp;&emsp;bool attack_landing_ranged_enabled = 0; //  If 1, and ranged attack has been configured, we can perform ranged attacks<br>&emsp;&emsp;&emsp;&emsp;bool attack_ranged_enabled = 0; //  If 1, and ranged attack has been configured, we can perform ranged attacks<br>&emsp;&emsp;&emsp;&emsp;float attack_knockback_multiplier = 100; // [-100, 100] If not 0, melee and dash attacks cause knockback to target<br>&emsp;&emsp;&emsp;&emsp;bool is_static_turret = 0; //  If 1, we can only attack in one fixed direction<br>&emsp;&emsp;&emsp;&emsp;int attack_melee_max_distance = 20; // [0, 400] Maximum distance at which we can perform a melee attack<br>&emsp;&emsp;&emsp;&emsp;int attack_melee_action_frame = 2; // [0, 1000] The animation frame during which the melee attack damage is inflicted and visual effects are created<br>&emsp;&emsp;&emsp;&emsp;int attack_melee_frames_between = 10; // [0, 1000] The minimum number of frames we wait between melee attacks<br>&emsp;&emsp;&emsp;&emsp;float attack_melee_damage_min = 0.4; // [0, 100] Melee attack damage inclusive minimum amount. The damage is randomized between melee attack_damage_min and attack_melee_damage_max<br>&emsp;&emsp;&emsp;&emsp;float attack_melee_damage_max = 0.6; // [0, 100] Melee attack damage inclusive maximum amount. The damage is randomized between melee attack_damage_min and attack_melee_damage_max<br>&emsp;&emsp;&emsp;&emsp;float attack_melee_impulse_vector_x = 0; // [-100, 100] The x component of the impulse that is applied to damaged entities<br>&emsp;&emsp;&emsp;&emsp;float attack_melee_impulse_vector_y = 0; // [-100, 100] The y component of the impulse that is applied to damaged entities<br>&emsp;&emsp;&emsp;&emsp;float attack_melee_impulse_multiplier = 0; // [-100, 100] A multiplier applied to attack_melee_impulse<br>&emsp;&emsp;&emsp;&emsp;float attack_melee_offset_x = 0; // [-1000, 1000] Melee attack particle effects are created here<br>&emsp;&emsp;&emsp;&emsp;float attack_melee_offset_y = 0; // [-1000, 1000] Melee attack particle effects are created here<br>&emsp;&emsp;&emsp;&emsp;bool attack_melee_finish_enabled = 0; //  If 1, we perform a finishing move when our attack would kill the target using the 'attack_finish' animation<br>&emsp;&emsp;&emsp;&emsp;int attack_melee_finish_action_frame = 2; // [0, 1000] The animation frame during which the melee attack finishing move damage is inflicted and visual effects are created<br>&emsp;&emsp;&emsp;&emsp;float attack_dash_distance = 50; // [0, 10000] The maximum distance from enemy at which we can perform a dash attack. If a normal melee attack is possible we always do that instead<br>&emsp;&emsp;&emsp;&emsp;int attack_dash_frames_between = 120; // [0, 1200] The minimum number of frames we wait between dash attacks<br>&emsp;&emsp;&emsp;&emsp;float attack_dash_damage = 0.25; // [0, 20] The amount of damage inflicted by the dash attack<br>&emsp;&emsp;&emsp;&emsp;float attack_dash_speed = 200; // [0, 5000] The speed at which we dash<br>&emsp;&emsp;&emsp;&emsp;float attack_dash_lob = 0.9; // [0, 6] The smaller this value is the more curved our dash attack trajectory is<br>&emsp;&emsp;&emsp;&emsp;float attack_ranged_min_distance = 10; // [0, 10000] The minimum distance from enemy at which we can perform a ranged attack.<br>&emsp;&emsp;&emsp;&emsp;float attack_ranged_max_distance = 160; // [0, 10000] The maximum distance from enemy at which we can perform a ranged attack.<br>&emsp;&emsp;&emsp;&emsp;int attack_ranged_action_frame = 2; // [0, 1000] The frame of the 'attack_ranged' animation during which the ranged attack actually occurs<br>&emsp;&emsp;&emsp;&emsp;float attack_ranged_offset_x = 0; // [-1000, 1000] 'attack_ranged_entity_file' is created here when performing a ranged attack<br>&emsp;&emsp;&emsp;&emsp;float attack_ranged_offset_y = 0; // [-1000, 1000] 'attack_ranged_entity_file' is created here when performing a ranged attack<br>&emsp;&emsp;&emsp;&emsp;bool attack_ranged_use_message = 0; //  If 1, we do ranged attacks by sending a Message_UseItem<br>&emsp;&emsp;&emsp;&emsp;bool attack_ranged_predict = 0; //  If 1, we attempt to predict target movement and shoot accordingly<br>&emsp;&emsp;&emsp;&emsp;std::string attack_ranged_entity_file = "data/entities/projectiles/spear.xml"; //  File to projectile entity that is created when performing a ranged attack<br>&emsp;&emsp;&emsp;&emsp;int attack_ranged_entity_count_min = 1; // [0, 1000] Minimum number of projectiles shot when performing a ranged attack<br>&emsp;&emsp;&emsp;&emsp;int attack_ranged_entity_count_max = 1; // [0, 1000] Maximum number of projectiles shot when performing a ranged attack<br>&emsp;&emsp;&emsp;&emsp;bool attack_ranged_use_laser_sight = 0; //  If 1, we draw a laser sight to our target. Requires entity to have a sprite with tag 'laser_sight'<br>&emsp;&emsp;&emsp;&emsp;bool attack_ranged_laser_sight_beam_kind = 0; //  0 = red, 1 = blue <br>&emsp;&emsp;&emsp;&emsp;bool attack_ranged_aim_rotation_enabled = 0;<br>&emsp;&emsp;&emsp;&emsp;float attack_ranged_aim_rotation_speed = 3;<br>&emsp;&emsp;&emsp;&emsp;float attack_ranged_aim_rotation_shooting_ok_angle_deg = 10;<br>&emsp;&emsp;&emsp;&emsp;int attack_ranged_state_duration_frames = 45; // [0, 1000] How long do we stay in the attack state, before other states are allowed?<br>&emsp;&emsp;&emsp;&emsp;bool hide_from_prey = 0; //  If 1, we attempt to hide from our target after a succesful attack<br>&emsp;&emsp;&emsp;&emsp;float hide_from_prey_target_distance = 200; // [0, 10000] The minimum distance from our target where we should move when hiding<br>&emsp;&emsp;&emsp;&emsp;int hide_from_prey_time = 300; //  The number of frames we spend hiding and staying hiding<br>&emsp;&emsp;&emsp;&emsp;bool food_eating_create_particles = 1; //  If 1, we replace eaten cells with particles made of this material<br>&emsp;&emsp;&emsp;&emsp;int eating_area_radius_x = 3; // [-100, 100] 1/2 width of the area from which we eat food<br>&emsp;&emsp;&emsp;&emsp;int eating_area_radius_y = 8; // [-100, 100] 1/2 height of the area from which we eat food<br>&emsp;&emsp;&emsp;&emsp;int mouth_offset_x = 0; // [-100, 100] The center of the area from which we eat food<br>&emsp;&emsp;&emsp;&emsp;int mouth_offset_y = 0; // [-100, 100] The center of the area from which we eat food<br>&emsp;&emsp;&emsp;&emsp;bool defecates_and_pees = 0; //  If 1, we occasionally take a leak or a dump<br>&emsp;&emsp;&emsp;&emsp;int butt_offset_x = 0; // [-100, 100] Bodily wastes are created here<br>&emsp;&emsp;&emsp;&emsp;int butt_offset_y = 0; // [-100, 100] Bodily wastes are created here<br>&emsp;&emsp;&emsp;&emsp;float pee_velocity_x = 0; // [-1000, 1000] The velocity at which our piss gets shot<br>&emsp;&emsp;&emsp;&emsp;float pee_velocity_y = 0; // [-1000, 1000] The velocity at which our piss gets shot<br>&emsp;&emsp;&emsp;&emsp;bool needs_food = 1; //  If 1, we stop to eat if we encounter 'food_material' cells<br>&emsp;&emsp;&emsp;&emsp;bool sense_creatures = 1; //  If 1, we occasionally search our surroundings for prey and threats<br>&emsp;&emsp;&emsp;&emsp;bool sense_creatures_through_walls = 0; //  If 1, will see creatures even if the wall raycast fails<br>&emsp;&emsp;&emsp;&emsp;bool can_fly = 1; //  If 1, we can fly. Please set 'PathFindingComponent.can_fly' to 1 as well if this is 1<br>&emsp;&emsp;&emsp;&emsp;bool can_walk = 1; //  If 1, we can walk. Please set 'PathFindingComponent.can_walk' to 1 as well if this is 1<br>&emsp;&emsp;&emsp;&emsp;int path_distance_to_target_node_to_turn_around = 0; // [0, 1000] If we're further than this from target path finding node on the X-axis we turn to face it<br>&emsp;&emsp;&emsp;&emsp;float path_cleanup_explosion_radius = 6; // [0, 1000] If we get stuck on ground we create an explosion this big to clear our surroundings a bit<br>&emsp;&emsp;&emsp;&emsp;float max_distance_to_move_from_home = 0;<br>&emsp;&emsp;&emsp;&emsp;ConfigExplosion attack_melee_finish_config_explosion; //  If we have explosion, it's the setup for it<br>&emsp;&emsp;&emsp;&emsp;LensValue<int> attack_ranged_frames_between; //  The minimum number of frames we wait between ranged attacks<br>&emsp;&emsp;&emsp;&emsp;int food_material = 0; //  The cell material we eat if encountering said material and 'needs_food' is 1<br>&emsp;&emsp;&emsp;&emsp;int food_particle_effect_material = 0; //  We create particles made of this material when eating if 'food_eating_create_particles' is 1<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> mAggression; //  the greater this value the more likely we're to attack creatures from other herds<br>&emsp;&emsp;&emsp;&emsp;AI_STATE_STACK mAiStateStack; //  a stack of actions and times they take, we can push new actions to the front and pop them from there<br>&emsp;&emsp;&emsp;&emsp;int mAiStateLastSwitchFrame = 0; //  when was the last time we switched a state<br>&emsp;&emsp;&emsp;&emsp;int mAiStatePrev = 0; //  previous AI state<br>&emsp;&emsp;&emsp;&emsp;int mCreatureDetectionNextCheck = 0; //  threat/prey check, next time we check for threat/prey<br>&emsp;&emsp;&emsp;&emsp;EntityID mGreatestThreat = 0; //  the entity we consider to be our greatest threat<br>&emsp;&emsp;&emsp;&emsp;EntityID mGreatestPrey = 0; //  the entity we consider to be our most important prey<br>&emsp;&emsp;&emsp;&emsp;int mSelectedMultiAttack = -1; //  which AIAttackComponent attack are we using?<br>&emsp;&emsp;&emsp;&emsp;bool mHasFoundPrey = 0; //  1, if we have ever found prey<br>&emsp;&emsp;&emsp;&emsp;bool mHasBeenAttackedByPlayer = 0; //  1, if we have been ever attacked<br>&emsp;&emsp;&emsp;&emsp;bool mHasStartedAttacking = 0; //  1, if we have ever started attacking anyone<br>&emsp;&emsp;&emsp;&emsp;int mNearbyFoodCount = 0; //  amount of 'food_material' near us<br>&emsp;&emsp;&emsp;&emsp;int mEatNextFrame = 0; //  next frame we can eat<br>&emsp;&emsp;&emsp;&emsp;int mEatTime = 0; //  time we've been constantly eating<br>&emsp;&emsp;&emsp;&emsp;int mFrameNextGiveUp = 0; //  next frame we consider ourselves to be stuck<br>&emsp;&emsp;&emsp;&emsp;vec2 mLastFramesMovementAreaMin; //  AABB min of the area where we've been since the last time we got stuck<br>&emsp;&emsp;&emsp;&emsp;vec2 mLastFramesMovementAreaMax; //  AABB max of the area where we've been since the last time we got stuck<br>&emsp;&emsp;&emsp;&emsp;int mFoodMaterialId = -1; //  cached id of 'food_material'<br>&emsp;&emsp;&emsp;&emsp;int mFoodParticleEffectMaterialId = -1; //  cached id of 'food_particle_effect_material'<br>&emsp;&emsp;&emsp;&emsp;float mNextJumpLob = 1; //  we use this for next jump<br>&emsp;&emsp;&emsp;&emsp;vec2 mNextJumpTarget; //  we use this for next jump<br>&emsp;&emsp;&emsp;&emsp;bool mNextJumpHasVelocity = 0; //  we use this for next jump<br>&emsp;&emsp;&emsp;&emsp;int mLastFrameJumped = -1; //  previous frame we launched into a jump<br>&emsp;&emsp;&emsp;&emsp;int mFramesWithoutTarget = 0;<br>&emsp;&emsp;&emsp;&emsp;int mLastFrameCanDamageOwnHerd = -1;<br>&emsp;&emsp;&emsp;&emsp;vec2 mHomePosition; //  where our home is located<br>&emsp;&emsp;&emsp;&emsp;int mLastFrameAttackWasDone = 0; //  when was the last time we did an attack (not necessarily did damage to anyone though)<br>&emsp;&emsp;&emsp;&emsp;int mNextFrameCanCallFriend = 0;<br>&emsp;&emsp;&emsp;&emsp;int mNextFrameRespondFriend = -1;<br>&emsp;&emsp;&emsp;&emsp;bool mHasNoticedPlayer = 0; //  if 1, we have noticed player or player projectile<br>&emsp;&emsp;&emsp;&emsp;float mRangedAttackCurrentAimAngle = 0; //  which direction does our gun currently point at, physically saying?<br>&emsp;&emsp;&emsp;&emsp;int mRangedAttackNextFrame = 0; //  next frame we can perform a ranged attack<br>&emsp;&emsp;&emsp;&emsp;int mMeleeAttackNextFrame = 0; //  next frame we can perform a melee attack<br>&emsp;&emsp;&emsp;&emsp;float mNextMeleeAttackDamage = 0; //  the amount of damage our next melee attack will cause. used by finishing move logic<br>&emsp;&emsp;&emsp;&emsp;bool mMeleeAttacking = 0; //  1, if we're doing a melee attack<br>&emsp;&emsp;&emsp;&emsp;int mMeleeAttackDashNextFrame = 0; //  the next frame we can perform a melee attack<br>&emsp;&emsp;&emsp;&emsp;RtsUnitGoal mCurrentJob; //  info about our current job. sorta legacy and could be simplified because the RTS logic is not used anywhere but doesn't have much overhead either.<br>};<br>```]]> </xs:documentation> </xs:annotation>
			<xs:all>
				<xs:element name="attack_melee_finish_config_explosion" type="ConfigExplosion" minOccurs="0"/>
			</xs:all>
		<xs:attribute name="ai_state" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int ai_state = 0; // [0, 20] Current state of ai, defines what the animal is doing<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ai_state_timer" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int ai_state_timer = 0; // [0, 1000] If not 0, then we wait till this frame to pop current state from our state stack<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="keep_state_alive_when_enabled" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool keep_state_alive_when_enabled = 0; //  if 1, will ensure state timer keeps current state alive for a while when Component is Enabled<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="preferred_job" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string preferred_job; //  We always do this job, unless interrupted (i.e. by taking fire damage)<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="escape_if_damaged_probability" type="xs:int" default="30">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int escape_if_damaged_probability = 30; //  the chance of escaping if someone damages us. only works if 'can_fly = 0 '<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_if_damaged_probability" type="xs:int" default="100">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int attack_if_damaged_probability = 100; //  the chance of counter-attacking if someone damages us, and we didn't escape<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="eye_offset_x" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int eye_offset_x = 0; // [-100, 100] We cast rays from our position + eye_offset to check if we can see something<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="eye_offset_y" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int eye_offset_y = 0; // [-100, 100] We cast rays from our position + eye_offset to check if we can see something<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_only_if_attacked" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool attack_only_if_attacked = 0; //  If 1, we never attack anyone unless attacked before by someone<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="dont_counter_attack_own_herd" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool dont_counter_attack_own_herd = 0; //  If 1, we don't attack members of our herd even if they accidentally attack us<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="creature_detection_range_x" type="xs:decimal" default="50">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float creature_detection_range_x = 50; // [0, 2000] When looking for threats/prey this is the max distance from us on the X axis we scan<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="creature_detection_range_y" type="xs:decimal" default="20">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float creature_detection_range_y = 20; // [0, 2000] When looking for threats/prey this is the max distance from us on the Y axis we scan<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="creature_detection_angular_range_deg" type="xs:decimal" default="90">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float creature_detection_angular_range_deg = 90; // [0, 90] When looking for threats/prey this is our field of view around the X axis. 90 means we scan the whole 180 degrees around the X axis, to the left and right<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="creature_detection_check_every_x_frames" type="xs:int" default="120">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int creature_detection_check_every_x_frames = 120; // [0, 5000] Checks for threats/prey take place at least this many frames apart from each other<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="max_distance_to_cam_to_start_hunting" type="xs:decimal" default="300">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float max_distance_to_cam_to_start_hunting = 300; // [0, 2000] JobDefault idles before we've been once at least this close to the camera<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="pathfinding_max_depth_no_target" type="xs:int" default="50">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int pathfinding_max_depth_no_target = 50; // [0, 5000] The maximum depth (in nodes) path search use when we have not found prey yet<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="pathfinding_max_depth_has_target" type="xs:int" default="120">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int pathfinding_max_depth_has_target = 120; // [0, 5000] The maximum depth (in nodes) path search use when we have found prey<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="aggressiveness_min" type="xs:decimal" default="80">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float aggressiveness_min = 80; // [0, 100] what's the initial random aggressiveness of this creature<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="aggressiveness_max" type="xs:decimal" default="100">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float aggressiveness_max = 100; // [0, 100] what's the initial random aggressiveness of this creature<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="tries_to_ranged_attack_friends" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool tries_to_ranged_attack_friends = 0; //  if 1, the AI tries to attack whoever it considers a friend based on herd_ids, CHARMED and BERSERK status etc. useful e.g. for healers.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_melee_enabled" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool attack_melee_enabled = 1; //  If 1, and melee attack has been configured, we can perform melee attacks<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_dash_enabled" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool attack_dash_enabled = 0; //  If 1, and dash attack has been configured, we can perform dash attacks (a long-distance melee attack where we dash towards the enemy)<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_landing_ranged_enabled" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool attack_landing_ranged_enabled = 0; //  If 1, and ranged attack has been configured, we can perform ranged attacks<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_ranged_enabled" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool attack_ranged_enabled = 0; //  If 1, and ranged attack has been configured, we can perform ranged attacks<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_knockback_multiplier" type="xs:decimal" default="100">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float attack_knockback_multiplier = 100; // [-100, 100] If not 0, melee and dash attacks cause knockback to target<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_static_turret" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_static_turret = 0; //  If 1, we can only attack in one fixed direction<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_melee_max_distance" type="xs:int" default="20">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int attack_melee_max_distance = 20; // [0, 400] Maximum distance at which we can perform a melee attack<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_melee_action_frame" type="xs:int" default="2">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int attack_melee_action_frame = 2; // [0, 1000] The animation frame during which the melee attack damage is inflicted and visual effects are created<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_melee_frames_between" type="xs:int" default="10">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int attack_melee_frames_between = 10; // [0, 1000] The minimum number of frames we wait between melee attacks<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_melee_damage_min" type="xs:decimal" default="0.4">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float attack_melee_damage_min = 0.4; // [0, 100] Melee attack damage inclusive minimum amount. The damage is randomized between melee attack_damage_min and attack_melee_damage_max<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_melee_damage_max" type="xs:decimal" default="0.6">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float attack_melee_damage_max = 0.6; // [0, 100] Melee attack damage inclusive maximum amount. The damage is randomized between melee attack_damage_min and attack_melee_damage_max<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_melee_impulse_vector_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float attack_melee_impulse_vector_x = 0; // [-100, 100] The x component of the impulse that is applied to damaged entities<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_melee_impulse_vector_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float attack_melee_impulse_vector_y = 0; // [-100, 100] The y component of the impulse that is applied to damaged entities<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_melee_impulse_multiplier" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float attack_melee_impulse_multiplier = 0; // [-100, 100] A multiplier applied to attack_melee_impulse<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_melee_offset_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float attack_melee_offset_x = 0; // [-1000, 1000] Melee attack particle effects are created here<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_melee_offset_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float attack_melee_offset_y = 0; // [-1000, 1000] Melee attack particle effects are created here<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_melee_finish_enabled" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool attack_melee_finish_enabled = 0; //  If 1, we perform a finishing move when our attack would kill the target using the 'attack_finish' animation<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_melee_finish_action_frame" type="xs:int" default="2">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int attack_melee_finish_action_frame = 2; // [0, 1000] The animation frame during which the melee attack finishing move damage is inflicted and visual effects are created<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_dash_distance" type="xs:decimal" default="50">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float attack_dash_distance = 50; // [0, 10000] The maximum distance from enemy at which we can perform a dash attack. If a normal melee attack is possible we always do that instead<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_dash_frames_between" type="xs:int" default="120">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int attack_dash_frames_between = 120; // [0, 1200] The minimum number of frames we wait between dash attacks<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_dash_damage" type="xs:decimal" default="0.25">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float attack_dash_damage = 0.25; // [0, 20] The amount of damage inflicted by the dash attack<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_dash_speed" type="xs:decimal" default="200">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float attack_dash_speed = 200; // [0, 5000] The speed at which we dash<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_dash_lob" type="xs:decimal" default="0.9">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float attack_dash_lob = 0.9; // [0, 6] The smaller this value is the more curved our dash attack trajectory is<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_ranged_min_distance" type="xs:decimal" default="10">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float attack_ranged_min_distance = 10; // [0, 10000] The minimum distance from enemy at which we can perform a ranged attack.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_ranged_max_distance" type="xs:decimal" default="160">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float attack_ranged_max_distance = 160; // [0, 10000] The maximum distance from enemy at which we can perform a ranged attack.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_ranged_action_frame" type="xs:int" default="2">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int attack_ranged_action_frame = 2; // [0, 1000] The frame of the 'attack_ranged' animation during which the ranged attack actually occurs<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_ranged_offset_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float attack_ranged_offset_x = 0; // [-1000, 1000] 'attack_ranged_entity_file' is created here when performing a ranged attack<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_ranged_offset_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float attack_ranged_offset_y = 0; // [-1000, 1000] 'attack_ranged_entity_file' is created here when performing a ranged attack<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_ranged_use_message" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool attack_ranged_use_message = 0; //  If 1, we do ranged attacks by sending a Message_UseItem<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_ranged_predict" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool attack_ranged_predict = 0; //  If 1, we attempt to predict target movement and shoot accordingly<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_ranged_entity_file" type="xs:string" default="data/entities/projectiles/spear.xml">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string attack_ranged_entity_file = "data/entities/projectiles/spear.xml"; //  File to projectile entity that is created when performing a ranged attack<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_ranged_entity_count_min" type="xs:int" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int attack_ranged_entity_count_min = 1; // [0, 1000] Minimum number of projectiles shot when performing a ranged attack<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_ranged_entity_count_max" type="xs:int" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int attack_ranged_entity_count_max = 1; // [0, 1000] Maximum number of projectiles shot when performing a ranged attack<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_ranged_use_laser_sight" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool attack_ranged_use_laser_sight = 0; //  If 1, we draw a laser sight to our target. Requires entity to have a sprite with tag 'laser_sight'<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_ranged_laser_sight_beam_kind" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool attack_ranged_laser_sight_beam_kind = 0; //  0 = red, 1 = blue <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_ranged_aim_rotation_enabled" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool attack_ranged_aim_rotation_enabled = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_ranged_aim_rotation_speed" type="xs:decimal" default="3">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float attack_ranged_aim_rotation_speed = 3;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_ranged_aim_rotation_shooting_ok_angle_deg" type="xs:decimal" default="10">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float attack_ranged_aim_rotation_shooting_ok_angle_deg = 10;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_ranged_state_duration_frames" type="xs:int" default="45">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int attack_ranged_state_duration_frames = 45; // [0, 1000] How long do we stay in the attack state, before other states are allowed?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="hide_from_prey" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool hide_from_prey = 0; //  If 1, we attempt to hide from our target after a succesful attack<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="hide_from_prey_target_distance" type="xs:decimal" default="200">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float hide_from_prey_target_distance = 200; // [0, 10000] The minimum distance from our target where we should move when hiding<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="hide_from_prey_time" type="xs:int" default="300">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int hide_from_prey_time = 300; //  The number of frames we spend hiding and staying hiding<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="food_eating_create_particles" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool food_eating_create_particles = 1; //  If 1, we replace eaten cells with particles made of this material<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="eating_area_radius_x" type="xs:int" default="3">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int eating_area_radius_x = 3; // [-100, 100] 1/2 width of the area from which we eat food<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="eating_area_radius_y" type="xs:int" default="8">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int eating_area_radius_y = 8; // [-100, 100] 1/2 height of the area from which we eat food<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mouth_offset_x" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mouth_offset_x = 0; // [-100, 100] The center of the area from which we eat food<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mouth_offset_y" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mouth_offset_y = 0; // [-100, 100] The center of the area from which we eat food<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="defecates_and_pees" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool defecates_and_pees = 0; //  If 1, we occasionally take a leak or a dump<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="butt_offset_x" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int butt_offset_x = 0; // [-100, 100] Bodily wastes are created here<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="butt_offset_y" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int butt_offset_y = 0; // [-100, 100] Bodily wastes are created here<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="pee_velocity_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float pee_velocity_x = 0; // [-1000, 1000] The velocity at which our piss gets shot<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="pee_velocity_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float pee_velocity_y = 0; // [-1000, 1000] The velocity at which our piss gets shot<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="needs_food" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool needs_food = 1; //  If 1, we stop to eat if we encounter 'food_material' cells<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="sense_creatures" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool sense_creatures = 1; //  If 1, we occasionally search our surroundings for prey and threats<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="sense_creatures_through_walls" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool sense_creatures_through_walls = 0; //  If 1, will see creatures even if the wall raycast fails<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="can_fly" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool can_fly = 1; //  If 1, we can fly. Please set 'PathFindingComponent.can_fly' to 1 as well if this is 1<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="can_walk" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool can_walk = 1; //  If 1, we can walk. Please set 'PathFindingComponent.can_walk' to 1 as well if this is 1<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="path_distance_to_target_node_to_turn_around" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int path_distance_to_target_node_to_turn_around = 0; // [0, 1000] If we're further than this from target path finding node on the X-axis we turn to face it<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="path_cleanup_explosion_radius" type="xs:decimal" default="6">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float path_cleanup_explosion_radius = 6; // [0, 1000] If we get stuck on ground we create an explosion this big to clear our surroundings a bit<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="max_distance_to_move_from_home" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float max_distance_to_move_from_home = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_ranged_frames_between" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>LensValue<int> attack_ranged_frames_between; //  The minimum number of frames we wait between ranged attacks<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="food_material" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int food_material = 0; //  The cell material we eat if encountering said material and 'needs_food' is 1<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="food_particle_effect_material" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int food_particle_effect_material = 0; //  We create particles made of this material when eating if 'food_eating_create_particles' is 1<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mAggression" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>LensValue<float> mAggression; //  the greater this value the more likely we're to attack creatures from other herds<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: AI_STATE_STACK for mAiStateStack -->
		<xs:attribute name="mAiStateLastSwitchFrame" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mAiStateLastSwitchFrame = 0; //  when was the last time we switched a state<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mAiStatePrev" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mAiStatePrev = 0; //  previous AI state<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mCreatureDetectionNextCheck" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mCreatureDetectionNextCheck = 0; //  threat/prey check, next time we check for threat/prey<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: EntityID for mGreatestThreat -->
		<!-- Some Unknown Type: EntityID for mGreatestPrey -->
		<xs:attribute name="mSelectedMultiAttack" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mSelectedMultiAttack = -1; //  which AIAttackComponent attack are we using?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mHasFoundPrey" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mHasFoundPrey = 0; //  1, if we have ever found prey<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mHasBeenAttackedByPlayer" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mHasBeenAttackedByPlayer = 0; //  1, if we have been ever attacked<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mHasStartedAttacking" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mHasStartedAttacking = 0; //  1, if we have ever started attacking anyone<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mNearbyFoodCount" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mNearbyFoodCount = 0; //  amount of 'food_material' near us<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mEatNextFrame" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mEatNextFrame = 0; //  next frame we can eat<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mEatTime" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mEatTime = 0; //  time we've been constantly eating<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mFrameNextGiveUp" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mFrameNextGiveUp = 0; //  next frame we consider ourselves to be stuck<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLastFramesMovementAreaMin.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mLastFramesMovementAreaMin; //  AABB min of the area where we've been since the last time we got stuck<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLastFramesMovementAreaMin.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mLastFramesMovementAreaMin; //  AABB min of the area where we've been since the last time we got stuck<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLastFramesMovementAreaMax.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mLastFramesMovementAreaMax; //  AABB max of the area where we've been since the last time we got stuck<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLastFramesMovementAreaMax.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mLastFramesMovementAreaMax; //  AABB max of the area where we've been since the last time we got stuck<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mFoodMaterialId" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mFoodMaterialId = -1; //  cached id of 'food_material'<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mFoodParticleEffectMaterialId" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mFoodParticleEffectMaterialId = -1; //  cached id of 'food_particle_effect_material'<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mNextJumpLob" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mNextJumpLob = 1; //  we use this for next jump<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mNextJumpTarget.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mNextJumpTarget; //  we use this for next jump<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mNextJumpTarget.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mNextJumpTarget; //  we use this for next jump<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mNextJumpHasVelocity" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mNextJumpHasVelocity = 0; //  we use this for next jump<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLastFrameJumped" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mLastFrameJumped = -1; //  previous frame we launched into a jump<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mFramesWithoutTarget" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mFramesWithoutTarget = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLastFrameCanDamageOwnHerd" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mLastFrameCanDamageOwnHerd = -1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mHomePosition.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mHomePosition; //  where our home is located<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mHomePosition.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mHomePosition; //  where our home is located<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLastFrameAttackWasDone" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mLastFrameAttackWasDone = 0; //  when was the last time we did an attack (not necessarily did damage to anyone though)<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mNextFrameCanCallFriend" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mNextFrameCanCallFriend = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mNextFrameRespondFriend" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mNextFrameRespondFriend = -1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mHasNoticedPlayer" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mHasNoticedPlayer = 0; //  if 1, we have noticed player or player projectile<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mRangedAttackCurrentAimAngle" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mRangedAttackCurrentAimAngle = 0; //  which direction does our gun currently point at, physically saying?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mRangedAttackNextFrame" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mRangedAttackNextFrame = 0; //  next frame we can perform a ranged attack<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mMeleeAttackNextFrame" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mMeleeAttackNextFrame = 0; //  next frame we can perform a melee attack<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mNextMeleeAttackDamage" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mNextMeleeAttackDamage = 0; //  the amount of damage our next melee attack will cause. used by finishing move logic<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mMeleeAttacking" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mMeleeAttacking = 0; //  1, if we're doing a melee attack<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mMeleeAttackDashNextFrame" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mMeleeAttackDashNextFrame = 0; //  the next frame we can perform a melee attack<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: RtsUnitGoal for mCurrentJob -->
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="ArcComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ArcComponent {<br>&emsp;&emsp;&emsp;&emsp;int lifetime = 60; //  remaining number of frames the arc exists<br>&emsp;&emsp;&emsp;&emsp;ARC_TYPE::Enum type; //  which implementation the arc should use<br>&emsp;&emsp;&emsp;&emsp;int material = 0; //  string name for the material the arc is made of<br>&emsp;&emsp;&emsp;&emsp;EntityID mArcTarget = 0; //  if 'mArcTarget' points to an existing entity a lighting arc will be created between this entity and 'mArcTarget'<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="lifetime" type="xs:int" default="60">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int lifetime = 60; //  remaining number of frames the arc exists<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="type" type="ARC_TYPE" default="MATERIAL">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ARC_TYPE::Enum type; //  which implementation the arc should use<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="material" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int material = 0; //  string name for the material the arc is made of<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: EntityID for mArcTarget -->
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="AreaDamageComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class AreaDamageComponent {<br>&emsp;&emsp;&emsp;&emsp;float circle_radius = 0; //  if > 0, will only damage entities inside the aabb rectangle which are closer than 'circle_radius' to the aabb center.<br>&emsp;&emsp;&emsp;&emsp;float damage_per_frame = 10; // [0, 256] <br>&emsp;&emsp;&emsp;&emsp;int update_every_n_frame = 1; // [0, 60] <br>&emsp;&emsp;&emsp;&emsp;EntityID entity_responsible = 0; //  if NULL, will try to figure out who to blame<br>&emsp;&emsp;&emsp;&emsp;std::string death_cause = "$damage_curse"; // [0, 60] <br>&emsp;&emsp;&emsp;&emsp;std::string entities_with_tag = "mortal"; //  damage entities with this tag<br>&emsp;&emsp;&emsp;&emsp;vec2 aabb_min;<br>&emsp;&emsp;&emsp;&emsp;vec2 aabb_max;<br>&emsp;&emsp;&emsp;&emsp;DAMAGE_TYPES::Enum damage_type; //  the damage type<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="circle_radius" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float circle_radius = 0; //  if > 0, will only damage entities inside the aabb rectangle which are closer than 'circle_radius' to the aabb center.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_per_frame" type="xs:decimal" default="10">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float damage_per_frame = 10; // [0, 256] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="update_every_n_frame" type="xs:int" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int update_every_n_frame = 1; // [0, 60] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: EntityID for entity_responsible -->
		<xs:attribute name="death_cause" type="xs:string" default="$damage_curse">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string death_cause = "$damage_curse"; // [0, 60] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="entities_with_tag" type="xs:string" default="mortal">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string entities_with_tag = "mortal"; //  damage entities with this tag<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="aabb_min.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 aabb_min;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="aabb_min.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 aabb_min;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="aabb_max.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 aabb_max;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="aabb_max.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 aabb_max;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_type" type="DAMAGE_TYPES" default="DAMAGE_PHYSICS_HIT">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>DAMAGE_TYPES::Enum damage_type; //  the damage type<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="AttachToEntityComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class AttachToEntityComponent {<br>&emsp;&emsp;&emsp;&emsp;bool only_position = 0; //  if 1, we only inherit position. it is calculated as follows: target_position + target_offset * target_scale<br>&emsp;&emsp;&emsp;&emsp;std::string target_hotspot_tag; //  if set, we apply the offset of target HotSpot with this tag<br>&emsp;&emsp;&emsp;&emsp;int target_sprite_id = -1; //  if >= 0, the Nth sprite transform in target entity is inherited<br>&emsp;&emsp;&emsp;&emsp;bool rotate_based_on_x_scale = 0; //  if 1, the rotation is set to 0 deg if scale >= 0 else to 180 deg<br>&emsp;&emsp;&emsp;&emsp;bool destroy_component_when_target_is_gone = 1; //  should probably be on by default<br>&emsp;&emsp;&emsp;&emsp;types::xform Transform;<br>&emsp;&emsp;&emsp;&emsp;EntityID target = 0; //  EntityID of the entity we're attached to. This will fail after save/load, unfortunately<br>&emsp;&emsp;&emsp;&emsp;int mUpdateFrame = -1;<br>};<br>```]]> </xs:documentation> </xs:annotation>
			<xs:all>
				<xs:element name="Transform" type="Transform" minOccurs="0"/>
			</xs:all>
		<xs:attribute name="only_position" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool only_position = 0; //  if 1, we only inherit position. it is calculated as follows: target_position + target_offset * target_scale<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="target_hotspot_tag" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string target_hotspot_tag; //  if set, we apply the offset of target HotSpot with this tag<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="target_sprite_id" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int target_sprite_id = -1; //  if >= 0, the Nth sprite transform in target entity is inherited<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="rotate_based_on_x_scale" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool rotate_based_on_x_scale = 0; //  if 1, the rotation is set to 0 deg if scale >= 0 else to 180 deg<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="destroy_component_when_target_is_gone" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool destroy_component_when_target_is_gone = 1; //  should probably be on by default<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: EntityID for target -->
		<xs:attribute name="mUpdateFrame" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mUpdateFrame = -1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="AudioComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class AudioComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string file;<br>&emsp;&emsp;&emsp;&emsp;std::string event_root;<br>&emsp;&emsp;&emsp;&emsp;std::string audio_physics_material;<br>&emsp;&emsp;&emsp;&emsp;bool set_latest_event_position = 0;<br>&emsp;&emsp;&emsp;&emsp;bool remove_latest_event_on_destroyed = 0;<br>&emsp;&emsp;&emsp;&emsp;bool send_message_on_event_dead = 0;<br>&emsp;&emsp;&emsp;&emsp;bool play_only_if_visible = 0; //  plays sounds only if entity position is on screen and not covered by fog of war<br>&emsp;&emsp;&emsp;&emsp;int m_audio_physics_material = 0;<br>&emsp;&emsp;&emsp;&emsp;AudioSourceHandle m_latest_source = -1;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="file" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string file;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="event_root" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string event_root;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="audio_physics_material" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string audio_physics_material;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="set_latest_event_position" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool set_latest_event_position = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="remove_latest_event_on_destroyed" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool remove_latest_event_on_destroyed = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="send_message_on_event_dead" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool send_message_on_event_dead = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="play_only_if_visible" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool play_only_if_visible = 0; //  plays sounds only if entity position is on screen and not covered by fog of war<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="m_audio_physics_material" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int m_audio_physics_material = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: AudioSourceHandle for m_latest_source -->
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="AudioListenerComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class AudioListenerComponent {<br>&emsp;&emsp;&emsp;&emsp;float z = 0; // [-500, 500] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="z" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float z = 0; // [-500, 500] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="AudioLoopComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class AudioLoopComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string file;<br>&emsp;&emsp;&emsp;&emsp;std::string event_name;<br>&emsp;&emsp;&emsp;&emsp;bool auto_play = 0;<br>&emsp;&emsp;&emsp;&emsp;bool auto_play_if_enabled = 0;<br>&emsp;&emsp;&emsp;&emsp;bool play_on_component_enable = 0;<br>&emsp;&emsp;&emsp;&emsp;bool calculate_material_lowpass = 1;<br>&emsp;&emsp;&emsp;&emsp;bool set_speed_parameter = 0;<br>&emsp;&emsp;&emsp;&emsp;bool set_speed_parameter_only_based_on_x_movement = 0;<br>&emsp;&emsp;&emsp;&emsp;bool set_speed_parameter_only_based_on_y_movement = 0;<br>&emsp;&emsp;&emsp;&emsp;float volume_autofade_speed = 0;<br>&emsp;&emsp;&emsp;&emsp;float m_volume = 0;<br>&emsp;&emsp;&emsp;&emsp;float m_intensity = 1;<br>&emsp;&emsp;&emsp;&emsp;float m_intensity2 = 1;<br>&emsp;&emsp;&emsp;&emsp;AudioSourceHandle m_source = -1;<br>&emsp;&emsp;&emsp;&emsp;int m_frame_created = -1;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="file" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string file;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="event_name" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string event_name;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="auto_play" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool auto_play = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="auto_play_if_enabled" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool auto_play_if_enabled = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="play_on_component_enable" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool play_on_component_enable = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="calculate_material_lowpass" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool calculate_material_lowpass = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="set_speed_parameter" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool set_speed_parameter = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="set_speed_parameter_only_based_on_x_movement" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool set_speed_parameter_only_based_on_x_movement = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="set_speed_parameter_only_based_on_y_movement" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool set_speed_parameter_only_based_on_y_movement = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="volume_autofade_speed" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float volume_autofade_speed = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="m_volume" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float m_volume = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="m_intensity" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float m_intensity = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="m_intensity2" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float m_intensity2 = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: AudioSourceHandle for m_source -->
		<xs:attribute name="m_frame_created" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int m_frame_created = -1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="BiomeTrackerComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class BiomeTrackerComponent {<br>&emsp;&emsp;&emsp;&emsp;int limit_to_every_n_frame = 0; //  if > 1, we will only check the biome every n frames<br>&emsp;&emsp;&emsp;&emsp;Biome* unsafe_current_biome; //  DO NOT ACCESS, since this can be in valid<br>&emsp;&emsp;&emsp;&emsp;std::string current_biome_name; //  used to track in which biome we are at<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="limit_to_every_n_frame" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int limit_to_every_n_frame = 0; //  if > 1, we will only check the biome every n frames<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: Biome* for unsafe_current_biome -->
		<xs:attribute name="current_biome_name" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string current_biome_name; //  used to track in which biome we are at<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="BlackHoleComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class BlackHoleComponent {<br>&emsp;&emsp;&emsp;&emsp;float radius = 16; // [0, 128] <br>&emsp;&emsp;&emsp;&emsp;float particle_attractor_force = 2; // [0, 32] <br>&emsp;&emsp;&emsp;&emsp;float damage_probability = 0.25;<br>&emsp;&emsp;&emsp;&emsp;float damage_amount = 0.1; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;int16 m_particle_attractor_id = -1;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="radius" type="xs:decimal" default="16">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float radius = 16; // [0, 128] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="particle_attractor_force" type="xs:decimal" default="2">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float particle_attractor_force = 2; // [0, 32] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_probability" type="xs:decimal" default="0.25">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float damage_probability = 0.25;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_amount" type="xs:decimal" default="0.1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float damage_amount = 0.1; // [0, 10] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="m_particle_attractor_id" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int16 m_particle_attractor_id = -1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="BookComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class BookComponent {<br>&emsp;&emsp;&emsp;&emsp;float TEMP_TEMPY = 0; // [0, 3.5] <br>&emsp;&emsp;&emsp;&emsp;float TEMP_TEMP_TEMP = 0; // [0, 3.5] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="TEMP_TEMPY" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float TEMP_TEMPY = 0; // [0, 3.5] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="TEMP_TEMP_TEMP" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float TEMP_TEMP_TEMP = 0; // [0, 3.5] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="BossDragonComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class BossDragonComponent {<br>&emsp;&emsp;&emsp;&emsp;float speed = 1; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float speed_hunt = 3; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float acceleration = 3; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float direction_adjust_speed = 1; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float direction_adjust_speed_hunt = 1; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float gravity = 3; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float tail_gravity = 30; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float part_distance = 10; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;int ground_check_offset = 0; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float eat_ground_radius = 1; // [0, 1e+006] <br>&emsp;&emsp;&emsp;&emsp;bool eat_ground = 1; //  does the worm destroy the ground it moves through or not?<br>&emsp;&emsp;&emsp;&emsp;float hitbox_radius = 1; // [0, 1e+006] <br>&emsp;&emsp;&emsp;&emsp;float bite_damage = 2; // [0, 10] how much damage does this do when it hits an entity<br>&emsp;&emsp;&emsp;&emsp;float target_kill_radius = 1; // [0, 1e+006] <br>&emsp;&emsp;&emsp;&emsp;float target_kill_ragdoll_force = 1; // [0, 1e+006] <br>&emsp;&emsp;&emsp;&emsp;float hunt_box_radius = 512; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float random_target_box_radius = 512; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;int new_hunt_target_check_every = 30; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;int new_random_target_check_every = 120; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float jump_cam_shake = 20; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float jump_cam_shake_distance = 256; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float eat_anim_wait_mult = 0.05; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;std::string projectile_1 = "data/entities/projectiles/bossdragon.xml";<br>&emsp;&emsp;&emsp;&emsp;int projectile_1_count = 2; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;std::string projectile_2 = "data/entities/projectiles/bossdragon_ray.xml";<br>&emsp;&emsp;&emsp;&emsp;int projectile_2_count = 5; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;std::string ragdoll_filename;<br>&emsp;&emsp;&emsp;&emsp;int mTargetEntityId = 0;<br>&emsp;&emsp;&emsp;&emsp;vec2 mTargetVec;<br>&emsp;&emsp;&emsp;&emsp;float mGravVelocity = 0;<br>&emsp;&emsp;&emsp;&emsp;float mSpeed = 0;<br>&emsp;&emsp;&emsp;&emsp;vec2 mRandomTarget;<br>&emsp;&emsp;&emsp;&emsp;vec2 mLastLivingTargetPos;<br>&emsp;&emsp;&emsp;&emsp;int mNextTargetCheckFrame = 0;<br>&emsp;&emsp;&emsp;&emsp;int mNextHuntTargetCheckFrame = 0;<br>&emsp;&emsp;&emsp;&emsp;bool mOnGroundPrev = 0;<br>&emsp;&emsp;&emsp;&emsp;int mMaterialIdPrev = 0;<br>&emsp;&emsp;&emsp;&emsp;int mPhase = 0;<br>&emsp;&emsp;&emsp;&emsp;int mNextPhaseSwitchTime = 0;<br>&emsp;&emsp;&emsp;&emsp;float mPartDistance = 2;<br>&emsp;&emsp;&emsp;&emsp;bool mIsInitialized = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="speed" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float speed = 1; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="speed_hunt" type="xs:decimal" default="3">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float speed_hunt = 3; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="acceleration" type="xs:decimal" default="3">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float acceleration = 3; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="direction_adjust_speed" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float direction_adjust_speed = 1; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="direction_adjust_speed_hunt" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float direction_adjust_speed_hunt = 1; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="gravity" type="xs:decimal" default="3">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float gravity = 3; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="tail_gravity" type="xs:decimal" default="30">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float tail_gravity = 30; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="part_distance" type="xs:decimal" default="10">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float part_distance = 10; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ground_check_offset" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int ground_check_offset = 0; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="eat_ground_radius" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float eat_ground_radius = 1; // [0, 1e+006] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="eat_ground" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool eat_ground = 1; //  does the worm destroy the ground it moves through or not?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="hitbox_radius" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float hitbox_radius = 1; // [0, 1e+006] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="bite_damage" type="xs:decimal" default="2">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float bite_damage = 2; // [0, 10] how much damage does this do when it hits an entity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="target_kill_radius" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float target_kill_radius = 1; // [0, 1e+006] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="target_kill_ragdoll_force" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float target_kill_ragdoll_force = 1; // [0, 1e+006] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="hunt_box_radius" type="xs:decimal" default="512">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float hunt_box_radius = 512; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="random_target_box_radius" type="xs:decimal" default="512">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float random_target_box_radius = 512; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="new_hunt_target_check_every" type="xs:int" default="30">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int new_hunt_target_check_every = 30; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="new_random_target_check_every" type="xs:int" default="120">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int new_random_target_check_every = 120; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="jump_cam_shake" type="xs:decimal" default="20">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float jump_cam_shake = 20; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="jump_cam_shake_distance" type="xs:decimal" default="256">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float jump_cam_shake_distance = 256; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="eat_anim_wait_mult" type="xs:decimal" default="0.05">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float eat_anim_wait_mult = 0.05; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="projectile_1" type="xs:string" default="data/entities/projectiles/bossdragon.xml">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string projectile_1 = "data/entities/projectiles/bossdragon.xml";<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="projectile_1_count" type="xs:int" default="2">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int projectile_1_count = 2; // [0, 10] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="projectile_2" type="xs:string" default="data/entities/projectiles/bossdragon_ray.xml">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string projectile_2 = "data/entities/projectiles/bossdragon_ray.xml";<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="projectile_2_count" type="xs:int" default="5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int projectile_2_count = 5; // [0, 10] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ragdoll_filename" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string ragdoll_filename;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mTargetEntityId" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mTargetEntityId = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mTargetVec.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mTargetVec;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mTargetVec.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mTargetVec;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mGravVelocity" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mGravVelocity = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mSpeed" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mSpeed = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mRandomTarget.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mRandomTarget;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mRandomTarget.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mRandomTarget;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLastLivingTargetPos.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mLastLivingTargetPos;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLastLivingTargetPos.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mLastLivingTargetPos;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mNextTargetCheckFrame" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mNextTargetCheckFrame = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mNextHuntTargetCheckFrame" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mNextHuntTargetCheckFrame = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mOnGroundPrev" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mOnGroundPrev = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mMaterialIdPrev" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mMaterialIdPrev = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPhase" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mPhase = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mNextPhaseSwitchTime" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mNextPhaseSwitchTime = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPartDistance" type="xs:decimal" default="2">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mPartDistance = 2;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mIsInitialized" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mIsInitialized = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="BossHealthBarComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class BossHealthBarComponent {<br>&emsp;&emsp;&emsp;&emsp;bool gui = 1;<br>&emsp;&emsp;&emsp;&emsp;bool gui_special_final_boss = 0;<br>&emsp;&emsp;&emsp;&emsp;bool in_world = 0;<br>&emsp;&emsp;&emsp;&emsp;float gui_max_distance_visible = 600;<br>&emsp;&emsp;&emsp;&emsp;bool mOldSpritesDestroyed = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="gui" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool gui = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="gui_special_final_boss" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool gui_special_final_boss = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="in_world" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool in_world = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="gui_max_distance_visible" type="xs:decimal" default="600">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float gui_max_distance_visible = 600;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mOldSpritesDestroyed" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mOldSpritesDestroyed = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="CameraBoundComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class CameraBoundComponent {<br>&emsp;&emsp;&emsp;&emsp;bool enabled = 1; //  If enabled, kills this component if it's outside the camera distance<br>&emsp;&emsp;&emsp;&emsp;float distance = 250; // [0, 1024] Distance in pixels from the center of camera, if outside this distance the entity is destroyed<br>&emsp;&emsp;&emsp;&emsp;float distance_border = 20; // [0, 1024] Offset towards camera in pixels from 'distance' where the entity is respawned if it was frozen<br>&emsp;&emsp;&emsp;&emsp;int max_count = 10; // [0, 1024] If more than 'max_count' entities of this type exist the one furthest from camera is destroyed<br>&emsp;&emsp;&emsp;&emsp;bool freeze_on_distance_kill = 1; //  If true and the entity went too far - this entity will be stored so we can later respawn it where it was destroyed because it got too far from the camera?<br>&emsp;&emsp;&emsp;&emsp;bool freeze_on_max_count_kill = 1; //  If true and the entity was one too many of its kind - this entity will be stored so we can later respawn it where it was destroyed because it got too far from the camera?<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="enabled" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool enabled = 1; //  If enabled, kills this component if it's outside the camera distance<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="distance" type="xs:decimal" default="250">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float distance = 250; // [0, 1024] Distance in pixels from the center of camera, if outside this distance the entity is destroyed<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="distance_border" type="xs:decimal" default="20">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float distance_border = 20; // [0, 1024] Offset towards camera in pixels from 'distance' where the entity is respawned if it was frozen<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="max_count" type="xs:int" default="10">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int max_count = 10; // [0, 1024] If more than 'max_count' entities of this type exist the one furthest from camera is destroyed<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="freeze_on_distance_kill" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool freeze_on_distance_kill = 1; //  If true and the entity went too far - this entity will be stored so we can later respawn it where it was destroyed because it got too far from the camera?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="freeze_on_max_count_kill" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool freeze_on_max_count_kill = 1; //  If true and the entity was one too many of its kind - this entity will be stored so we can later respawn it where it was destroyed because it got too far from the camera?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="CardinalMovementComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class CardinalMovementComponent {<br>&emsp;&emsp;&emsp;&emsp;bool horizontal_movement = 1; //  allow horizontal movement<br>&emsp;&emsp;&emsp;&emsp;bool vertical_movement = 1; //  allow vertical movement<br>&emsp;&emsp;&emsp;&emsp;bool intercardinal_movement = 0; //  allow intercardinal movement<br>&emsp;&emsp;&emsp;&emsp;vec2 mPrevPos;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="horizontal_movement" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool horizontal_movement = 1; //  allow horizontal movement<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="vertical_movement" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool vertical_movement = 1; //  allow vertical movement<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="intercardinal_movement" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool intercardinal_movement = 0; //  allow intercardinal movement<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevPos.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mPrevPos;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevPos.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mPrevPos;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="CellEaterComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class CellEaterComponent {<br>&emsp;&emsp;&emsp;&emsp;float radius = 10; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;int eat_probability = 100; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;bool only_stain = 0;<br>&emsp;&emsp;&emsp;&emsp;bool eat_dynamic_physics_bodies = 1;<br>&emsp;&emsp;&emsp;&emsp;bool limited_materials = 0; //  if true, will only eat the materials defined in material_list<br>&emsp;&emsp;&emsp;&emsp;std::string ignored_material_tag; //  if set, will not eat any materials with this tag. please note that this lowers the performance of cell eating by some amount.<br>&emsp;&emsp;&emsp;&emsp;int ignored_material = 0; //  String name of a material that shouldn't be eaten by the component<br>&emsp;&emsp;&emsp;&emsp;VEC_OF_MATERIALS materials; //  is a list of accepted materials sorted<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="radius" type="xs:decimal" default="10">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float radius = 10; // [0, 100] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="eat_probability" type="xs:int" default="100">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int eat_probability = 100; // [0, 100] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="only_stain" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool only_stain = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="eat_dynamic_physics_bodies" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool eat_dynamic_physics_bodies = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="limited_materials" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool limited_materials = 0; //  if true, will only eat the materials defined in material_list<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ignored_material_tag" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string ignored_material_tag; //  if set, will not eat any materials with this tag. please note that this lowers the performance of cell eating by some amount.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ignored_material" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int ignored_material = 0; //  String name of a material that shouldn't be eaten by the component<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="materials" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>VEC_OF_MATERIALS materials; //  is a list of accepted materials sorted<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="CharacterCollisionComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class CharacterCollisionComponent {<br>&emsp;&emsp;&emsp;&emsp;int getting_crushed_threshold = 5; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;int moving_up_before_getting_crushed_threshold = 3; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;int getting_crushed_counter = 0; //  1.12.2018 - Is this still used?<br>&emsp;&emsp;&emsp;&emsp;int stuck_in_ground_counter = 0; //  used this mostly for player to figure out if it's stuck in ground<br>&emsp;&emsp;&emsp;&emsp;bool mCollidedHorizontally = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="getting_crushed_threshold" type="xs:int" default="5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int getting_crushed_threshold = 5; // [0, 100] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="moving_up_before_getting_crushed_threshold" type="xs:int" default="3">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int moving_up_before_getting_crushed_threshold = 3; // [0, 100] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="getting_crushed_counter" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int getting_crushed_counter = 0; //  1.12.2018 - Is this still used?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="stuck_in_ground_counter" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int stuck_in_ground_counter = 0; //  used this mostly for player to figure out if it's stuck in ground<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mCollidedHorizontally" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mCollidedHorizontally = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="CharacterDataComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class CharacterDataComponent {<br>&emsp;&emsp;&emsp;&emsp;int platforming_type = 0; // [0, 3] 0 = oldest, 1 = newer, 2 = safest<br>&emsp;&emsp;&emsp;&emsp;float mass = 1; // [0, 10] 1.0 = approx. mass of player<br>&emsp;&emsp;&emsp;&emsp;int buoyancy_check_offset_y = -6; // [-1000, 1000] <br>&emsp;&emsp;&emsp;&emsp;float liquid_velocity_coeff = 9; // [0, 20] how much do liquids move this character. e.g. when standing in a flowing river<br>&emsp;&emsp;&emsp;&emsp;float gravity = 100; // [0, 250] <br>&emsp;&emsp;&emsp;&emsp;float fly_recharge_spd = 0; // [0, 250] <br>&emsp;&emsp;&emsp;&emsp;float fly_recharge_spd_ground = 0; // [0, 250] <br>&emsp;&emsp;&emsp;&emsp;bool flying_needs_recharge = 0; //  const variable... player has this as true<br>&emsp;&emsp;&emsp;&emsp;int flying_in_air_wait_frames = 44; // [0, 200] to fix the tap tap tap flying cheese, we wait this many frames before recharging in air<br>&emsp;&emsp;&emsp;&emsp;int flying_recharge_removal_frames = 8; // [0, 20] another fix to the tap tap - this is how many frames from pressing down up we'll remove fly charge<br>&emsp;&emsp;&emsp;&emsp;int climb_over_y = 3; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;int check_collision_max_size_x = 5; // [0, 50] <br>&emsp;&emsp;&emsp;&emsp;int check_collision_max_size_y = 5; // [0, 50] <br>&emsp;&emsp;&emsp;&emsp;bool is_on_ground = 0;<br>&emsp;&emsp;&emsp;&emsp;bool is_on_slippery_ground = 0;<br>&emsp;&emsp;&emsp;&emsp;float ground_stickyness = 0;<br>&emsp;&emsp;&emsp;&emsp;bool effect_hit_ground = 0;<br>&emsp;&emsp;&emsp;&emsp;int eff_hg_damage_min = 0; //  if we want to damage ground when hitting it... this is the place<br>&emsp;&emsp;&emsp;&emsp;int eff_hg_damage_max = 0; //  if we want to damage ground when hitting it... this is the place<br>&emsp;&emsp;&emsp;&emsp;float eff_hg_position_x = 0; // [-15, 15] <br>&emsp;&emsp;&emsp;&emsp;float eff_hg_position_y = 0; // [-15, 15] <br>&emsp;&emsp;&emsp;&emsp;float eff_hg_size_x = 0; // [-15, 15] <br>&emsp;&emsp;&emsp;&emsp;float eff_hg_size_y = 0; // [-15, 15] <br>&emsp;&emsp;&emsp;&emsp;float eff_hg_velocity_min_x = 0; // [-65, 65] <br>&emsp;&emsp;&emsp;&emsp;float eff_hg_velocity_max_x = 0; // [-65, 65] <br>&emsp;&emsp;&emsp;&emsp;float eff_hg_velocity_min_y = 0; // [-65, 65] <br>&emsp;&emsp;&emsp;&emsp;float eff_hg_velocity_max_y = 0; // [-65, 65] <br>&emsp;&emsp;&emsp;&emsp;float eff_hg_offset_y = 0; // [-15, 15] <br>&emsp;&emsp;&emsp;&emsp;bool eff_hg_update_box2d = 0; //  if true, will move physics bodies that it hits<br>&emsp;&emsp;&emsp;&emsp;float eff_hg_b2force_multiplier = 0.0035; //  multiplies the velocity with this...<br>&emsp;&emsp;&emsp;&emsp;float destroy_ground = 0; //  how much damage do we do the ground when land on it<br>&emsp;&emsp;&emsp;&emsp;bool send_transform_update_message = 0; //  if 1, will send Message_TransformUpdated to updated entities and their children when the component is processed by PlayerCollisionSystem or CharacterCollisionSystem<br>&emsp;&emsp;&emsp;&emsp;bool dont_update_velocity_and_xform = 0; //  might be useful if you want to use CharacterCollisionSystem to only update on_ground status<br>&emsp;&emsp;&emsp;&emsp;float mFlyingTimeLeft = 1000; //  How much flying energy do we have left? - NOTE( Petri ): 1.3.2023 - This used to be a private variable. It was changed to fix the save/load infinite flying bug.<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> collision_aabb_min_x;<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> collision_aabb_max_x;<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> collision_aabb_min_y;<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> collision_aabb_max_y;<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> fly_time_max; //  how much flying energy + <br>&emsp;&emsp;&emsp;&emsp;int mFramesOnGround = 0;<br>&emsp;&emsp;&emsp;&emsp;int mLastFrameOnGround = 0;<br>&emsp;&emsp;&emsp;&emsp;vec2 mVelocity;<br>&emsp;&emsp;&emsp;&emsp;bool mCollidedHorizontally = 0; //  moved this here from CharacterCollisionComponent - since that is multithreaded and we needed a non multithreaded version<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="platforming_type" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int platforming_type = 0; // [0, 3] 0 = oldest, 1 = newer, 2 = safest<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mass" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mass = 1; // [0, 10] 1.0 = approx. mass of player<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="buoyancy_check_offset_y" type="xs:int" default="-6">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int buoyancy_check_offset_y = -6; // [-1000, 1000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="liquid_velocity_coeff" type="xs:decimal" default="9">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float liquid_velocity_coeff = 9; // [0, 20] how much do liquids move this character. e.g. when standing in a flowing river<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="gravity" type="xs:decimal" default="100">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float gravity = 100; // [0, 250] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fly_recharge_spd" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float fly_recharge_spd = 0; // [0, 250] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fly_recharge_spd_ground" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float fly_recharge_spd_ground = 0; // [0, 250] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="flying_needs_recharge" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool flying_needs_recharge = 0; //  const variable... player has this as true<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="flying_in_air_wait_frames" type="xs:int" default="44">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int flying_in_air_wait_frames = 44; // [0, 200] to fix the tap tap tap flying cheese, we wait this many frames before recharging in air<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="flying_recharge_removal_frames" type="xs:int" default="8">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int flying_recharge_removal_frames = 8; // [0, 20] another fix to the tap tap - this is how many frames from pressing down up we'll remove fly charge<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="climb_over_y" type="xs:int" default="3">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int climb_over_y = 3; // [0, 10] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="check_collision_max_size_x" type="xs:int" default="5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int check_collision_max_size_x = 5; // [0, 50] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="check_collision_max_size_y" type="xs:int" default="5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int check_collision_max_size_y = 5; // [0, 50] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_on_ground" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_on_ground = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_on_slippery_ground" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_on_slippery_ground = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ground_stickyness" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float ground_stickyness = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="effect_hit_ground" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool effect_hit_ground = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="eff_hg_damage_min" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int eff_hg_damage_min = 0; //  if we want to damage ground when hitting it... this is the place<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="eff_hg_damage_max" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int eff_hg_damage_max = 0; //  if we want to damage ground when hitting it... this is the place<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="eff_hg_position_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float eff_hg_position_x = 0; // [-15, 15] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="eff_hg_position_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float eff_hg_position_y = 0; // [-15, 15] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="eff_hg_size_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float eff_hg_size_x = 0; // [-15, 15] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="eff_hg_size_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float eff_hg_size_y = 0; // [-15, 15] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="eff_hg_velocity_min_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float eff_hg_velocity_min_x = 0; // [-65, 65] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="eff_hg_velocity_max_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float eff_hg_velocity_max_x = 0; // [-65, 65] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="eff_hg_velocity_min_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float eff_hg_velocity_min_y = 0; // [-65, 65] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="eff_hg_velocity_max_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float eff_hg_velocity_max_y = 0; // [-65, 65] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="eff_hg_offset_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float eff_hg_offset_y = 0; // [-15, 15] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="eff_hg_update_box2d" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool eff_hg_update_box2d = 0; //  if true, will move physics bodies that it hits<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="eff_hg_b2force_multiplier" type="xs:decimal" default="0.0035">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float eff_hg_b2force_multiplier = 0.0035; //  multiplies the velocity with this...<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="destroy_ground" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float destroy_ground = 0; //  how much damage do we do the ground when land on it<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="send_transform_update_message" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool send_transform_update_message = 0; //  if 1, will send Message_TransformUpdated to updated entities and their children when the component is processed by PlayerCollisionSystem or CharacterCollisionSystem<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="dont_update_velocity_and_xform" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool dont_update_velocity_and_xform = 0; //  might be useful if you want to use CharacterCollisionSystem to only update on_ground status<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mFlyingTimeLeft" type="xs:decimal" default="1000">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mFlyingTimeLeft = 1000; //  How much flying energy do we have left? - NOTE( Petri ): 1.3.2023 - This used to be a private variable. It was changed to fix the save/load infinite flying bug.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="collision_aabb_min_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>LensValue<float> collision_aabb_min_x;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="collision_aabb_max_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>LensValue<float> collision_aabb_max_x;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="collision_aabb_min_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>LensValue<float> collision_aabb_min_y;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="collision_aabb_max_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>LensValue<float> collision_aabb_max_y;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fly_time_max" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>LensValue<float> fly_time_max; //  how much flying energy + <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mFramesOnGround" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mFramesOnGround = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLastFrameOnGround" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mLastFrameOnGround = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mVelocity.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mVelocity;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mVelocity.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mVelocity;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mCollidedHorizontally" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mCollidedHorizontally = 0; //  moved this here from CharacterCollisionComponent - since that is multithreaded and we needed a non multithreaded version<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="CharacterPlatformingComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class CharacterPlatformingComponent {<br>&emsp;&emsp;&emsp;&emsp;float jump_velocity_x = 0; // [0, 500] <br>&emsp;&emsp;&emsp;&emsp;float jump_velocity_y = -175; // [-500, 0] <br>&emsp;&emsp;&emsp;&emsp;int jump_keydown_buffer = 2; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;float fly_speed_mult = 0; // [-100, 100] AI stuff<br>&emsp;&emsp;&emsp;&emsp;float fly_speed_change_spd = 5; // [0, 1000] player<br>&emsp;&emsp;&emsp;&emsp;bool fly_model_player = 0; //  if true, uses player fly model<br>&emsp;&emsp;&emsp;&emsp;bool fly_smooth_y = 1; //  if true, smooths out the AI fly model<br>&emsp;&emsp;&emsp;&emsp;float accel_x = 1; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;float accel_x_air = 0.1; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;float pixel_gravity = 600; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;float swim_idle_buoyancy_coeff = 1.2; // [0, 2] <br>&emsp;&emsp;&emsp;&emsp;float swim_down_buoyancy_coeff = 0.7; // [0, 2] <br>&emsp;&emsp;&emsp;&emsp;float swim_up_buoyancy_coeff = 0.9; // [0, 2] <br>&emsp;&emsp;&emsp;&emsp;float swim_drag = 0.95; // [0, 2] when in water velocity *= swim_drag<br>&emsp;&emsp;&emsp;&emsp;float swim_extra_horizontal_drag = 0.9; // [0, 2] when in water velocity.x *= swim_extra_horizontal_drag<br>&emsp;&emsp;&emsp;&emsp;bool mouse_look = 1;<br>&emsp;&emsp;&emsp;&emsp;float mouse_look_buffer = 1; // [0, 5] <br>&emsp;&emsp;&emsp;&emsp;bool keyboard_look = 0; //  if true, turns based on if left or right has been pressed down<br>&emsp;&emsp;&emsp;&emsp;float turning_buffer = 0.1; // [0, 2] <br>&emsp;&emsp;&emsp;&emsp;std::string animation_to_play;<br>&emsp;&emsp;&emsp;&emsp;std::string animation_to_play_next;<br>&emsp;&emsp;&emsp;&emsp;float run_animation_velocity_switching_threshold = 45; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;bool run_animation_velocity_switching_enabled = 0;<br>&emsp;&emsp;&emsp;&emsp;int turn_animation_frames_between = 20; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;int precision_jumping_max_duration_frames = -1; //  maximum duration of precision jump or knockback. -1 = infinite<br>&emsp;&emsp;&emsp;&emsp;float audio_liquid_splash_intensity = 1;<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> velocity_min_x;<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> velocity_max_x;<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> velocity_min_y;<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> velocity_max_y;<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> run_velocity;<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> fly_velocity_x;<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> fly_speed_max_up;<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> fly_speed_max_down;<br>&emsp;&emsp;&emsp;&emsp;vec2 mExAnimationPos;<br>&emsp;&emsp;&emsp;&emsp;int mFramesInAirCounter = -1;<br>&emsp;&emsp;&emsp;&emsp;bool mIsPrecisionJumping = 0;<br>&emsp;&emsp;&emsp;&emsp;int mPrecisionJumpingTime = 0;<br>&emsp;&emsp;&emsp;&emsp;float mPrecisionJumpingSpeedX = 0;<br>&emsp;&emsp;&emsp;&emsp;int mPrecisionJumpingTimeLeft = 0;<br>&emsp;&emsp;&emsp;&emsp;float mFlyThrottle = 0;<br>&emsp;&emsp;&emsp;&emsp;float mSmoothedFlyingTargetY = 0;<br>&emsp;&emsp;&emsp;&emsp;int mJetpackEmitting = -1; //  -1 = undefined, 0 = not emitting, 1 = emitting<br>&emsp;&emsp;&emsp;&emsp;int mNextTurnAnimationFrame = 0;<br>&emsp;&emsp;&emsp;&emsp;int mFramesNotSwimming = 10; //  0 = currently swimming<br>&emsp;&emsp;&emsp;&emsp;int mFramesSwimming = 0; //  0 = not currently swimming<br>&emsp;&emsp;&emsp;&emsp;bool mShouldCrouch = 0;<br>&emsp;&emsp;&emsp;&emsp;bool mShouldCrouchPrev = 0;<br>&emsp;&emsp;&emsp;&emsp;int mLastPostureSwitchFrame = -1;<br>&emsp;&emsp;&emsp;&emsp;int mLookOverrideLastFrame = 0;<br>&emsp;&emsp;&emsp;&emsp;int mLookOverrideDirection = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="jump_velocity_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float jump_velocity_x = 0; // [0, 500] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="jump_velocity_y" type="xs:decimal" default="-175">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float jump_velocity_y = -175; // [-500, 0] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="jump_keydown_buffer" type="xs:int" default="2">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int jump_keydown_buffer = 2; // [0, 10] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fly_speed_mult" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float fly_speed_mult = 0; // [-100, 100] AI stuff<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fly_speed_change_spd" type="xs:decimal" default="5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float fly_speed_change_spd = 5; // [0, 1000] player<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fly_model_player" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool fly_model_player = 0; //  if true, uses player fly model<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fly_smooth_y" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool fly_smooth_y = 1; //  if true, smooths out the AI fly model<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="accel_x" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float accel_x = 1; // [0, 1000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="accel_x_air" type="xs:decimal" default="0.1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float accel_x_air = 0.1; // [0, 1000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="pixel_gravity" type="xs:decimal" default="600">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float pixel_gravity = 600; // [0, 1000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="swim_idle_buoyancy_coeff" type="xs:decimal" default="1.2">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float swim_idle_buoyancy_coeff = 1.2; // [0, 2] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="swim_down_buoyancy_coeff" type="xs:decimal" default="0.7">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float swim_down_buoyancy_coeff = 0.7; // [0, 2] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="swim_up_buoyancy_coeff" type="xs:decimal" default="0.9">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float swim_up_buoyancy_coeff = 0.9; // [0, 2] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="swim_drag" type="xs:decimal" default="0.95">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float swim_drag = 0.95; // [0, 2] when in water velocity *= swim_drag<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="swim_extra_horizontal_drag" type="xs:decimal" default="0.9">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float swim_extra_horizontal_drag = 0.9; // [0, 2] when in water velocity.x *= swim_extra_horizontal_drag<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mouse_look" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mouse_look = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mouse_look_buffer" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mouse_look_buffer = 1; // [0, 5] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="keyboard_look" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool keyboard_look = 0; //  if true, turns based on if left or right has been pressed down<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="turning_buffer" type="xs:decimal" default="0.1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float turning_buffer = 0.1; // [0, 2] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="animation_to_play" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string animation_to_play;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="animation_to_play_next" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string animation_to_play_next;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="run_animation_velocity_switching_threshold" type="xs:decimal" default="45">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float run_animation_velocity_switching_threshold = 45; // [0, 1000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="run_animation_velocity_switching_enabled" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool run_animation_velocity_switching_enabled = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="turn_animation_frames_between" type="xs:int" default="20">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int turn_animation_frames_between = 20; // [0, 100] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="precision_jumping_max_duration_frames" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int precision_jumping_max_duration_frames = -1; //  maximum duration of precision jump or knockback. -1 = infinite<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="audio_liquid_splash_intensity" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float audio_liquid_splash_intensity = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="velocity_min_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>LensValue<float> velocity_min_x;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="velocity_max_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>LensValue<float> velocity_max_x;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="velocity_min_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>LensValue<float> velocity_min_y;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="velocity_max_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>LensValue<float> velocity_max_y;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="run_velocity" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>LensValue<float> run_velocity;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fly_velocity_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>LensValue<float> fly_velocity_x;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fly_speed_max_up" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>LensValue<float> fly_speed_max_up;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fly_speed_max_down" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>LensValue<float> fly_speed_max_down;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mExAnimationPos.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mExAnimationPos;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mExAnimationPos.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mExAnimationPos;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mFramesInAirCounter" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mFramesInAirCounter = -1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mIsPrecisionJumping" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mIsPrecisionJumping = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrecisionJumpingTime" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mPrecisionJumpingTime = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrecisionJumpingSpeedX" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mPrecisionJumpingSpeedX = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrecisionJumpingTimeLeft" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mPrecisionJumpingTimeLeft = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mFlyThrottle" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mFlyThrottle = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mSmoothedFlyingTargetY" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mSmoothedFlyingTargetY = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mJetpackEmitting" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mJetpackEmitting = -1; //  -1 = undefined, 0 = not emitting, 1 = emitting<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mNextTurnAnimationFrame" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mNextTurnAnimationFrame = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mFramesNotSwimming" type="xs:int" default="10">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mFramesNotSwimming = 10; //  0 = currently swimming<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mFramesSwimming" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mFramesSwimming = 0; //  0 = not currently swimming<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mShouldCrouch" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mShouldCrouch = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mShouldCrouchPrev" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mShouldCrouchPrev = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLastPostureSwitchFrame" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mLastPostureSwitchFrame = -1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLookOverrideLastFrame" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mLookOverrideLastFrame = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLookOverrideDirection" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mLookOverrideDirection = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="CharacterStatsComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class CharacterStatsComponent {<br>&emsp;&emsp;&emsp;&emsp;CharacterStatsModifier stats;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<!-- Some Unknown Type: CharacterStatsModifier for stats -->
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="CollisionTriggerComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class CollisionTriggerComponent {<br>&emsp;&emsp;&emsp;&emsp;float width = 32; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;float height = 32; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;float radius = 32; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;std::string required_tag = "mortal";<br>&emsp;&emsp;&emsp;&emsp;bool remove_component_when_triggered = 0;<br>&emsp;&emsp;&emsp;&emsp;bool destroy_this_entity_when_triggered = 1;<br>&emsp;&emsp;&emsp;&emsp;int timer_for_destruction = 0; // [0, 60] <br>&emsp;&emsp;&emsp;&emsp;bool self_trigger = 0; //  if true, the shooter can trigger it<br>&emsp;&emsp;&emsp;&emsp;int skip_self_frames = 60; //  skips checks against self during these frames<br>&emsp;&emsp;&emsp;&emsp;int mTimer = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="width" type="xs:decimal" default="32">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float width = 32; // [0, 100] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="height" type="xs:decimal" default="32">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float height = 32; // [0, 100] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="radius" type="xs:decimal" default="32">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float radius = 32; // [0, 100] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="required_tag" type="xs:string" default="mortal">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string required_tag = "mortal";<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="remove_component_when_triggered" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool remove_component_when_triggered = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="destroy_this_entity_when_triggered" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool destroy_this_entity_when_triggered = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="timer_for_destruction" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int timer_for_destruction = 0; // [0, 60] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="self_trigger" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool self_trigger = 0; //  if true, the shooter can trigger it<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="skip_self_frames" type="xs:int" default="60">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int skip_self_frames = 60; //  skips checks against self during these frames<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mTimer" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mTimer = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="ConsumableTeleportComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ConsumableTeleportComponent {<br>&emsp;&emsp;&emsp;&emsp;bool create_other_end = 0;<br>&emsp;&emsp;&emsp;&emsp;bool is_at_home = 0;<br>&emsp;&emsp;&emsp;&emsp;float collision_radius = 10; // [0, 20] <br>&emsp;&emsp;&emsp;&emsp;uint32 target_id = 0;<br>&emsp;&emsp;&emsp;&emsp;uint32 id = 0;<br>&emsp;&emsp;&emsp;&emsp;int mNextUsableFrame = 0;<br>&emsp;&emsp;&emsp;&emsp;bool mHasOtherEnd = 0;<br>&emsp;&emsp;&emsp;&emsp;vec2 target_location;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="create_other_end" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool create_other_end = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_at_home" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_at_home = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="collision_radius" type="xs:decimal" default="10">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float collision_radius = 10; // [0, 20] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="target_id" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint32 target_id = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="id" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint32 id = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mNextUsableFrame" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mNextUsableFrame = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mHasOtherEnd" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mHasOtherEnd = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="target_location.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 target_location;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="target_location.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 target_location;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="ControllerGoombaAIComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ControllerGoombaAIComponent {<br>&emsp;&emsp;&emsp;&emsp;bool auto_turn_around_enabled = 1; //  disable this if you don't want creature to 'look around', while standing still<br>&emsp;&emsp;&emsp;&emsp;int wait_to_turn_around = 50; // [0, 300] <br>&emsp;&emsp;&emsp;&emsp;int wall_hit_wait = 10; // [0, 300] <br>&emsp;&emsp;&emsp;&emsp;bool check_wall_detection = 1;<br>&emsp;&emsp;&emsp;&emsp;float wall_detection_aabb_min_x = 0; // [-15, 15] <br>&emsp;&emsp;&emsp;&emsp;float wall_detection_aabb_max_x = 0; // [-15, 15] <br>&emsp;&emsp;&emsp;&emsp;float wall_detection_aabb_min_y = 0; // [-15, 15] <br>&emsp;&emsp;&emsp;&emsp;float wall_detection_aabb_max_y = 0; // [-15, 15] <br>&emsp;&emsp;&emsp;&emsp;bool check_floor_detection = 0;<br>&emsp;&emsp;&emsp;&emsp;float floor_detection_aabb_min_x = 0; // [-15, 15] <br>&emsp;&emsp;&emsp;&emsp;float floor_detection_aabb_max_x = 0; // [-15, 15] <br>&emsp;&emsp;&emsp;&emsp;float floor_detection_aabb_min_y = 0; // [-15, 15] <br>&emsp;&emsp;&emsp;&emsp;float floor_detection_aabb_max_y = 0; // [-15, 15] <br>&emsp;&emsp;&emsp;&emsp;int mChangingDirectionCounter = -1;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="auto_turn_around_enabled" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool auto_turn_around_enabled = 1; //  disable this if you don't want creature to 'look around', while standing still<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="wait_to_turn_around" type="xs:int" default="50">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int wait_to_turn_around = 50; // [0, 300] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="wall_hit_wait" type="xs:int" default="10">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int wall_hit_wait = 10; // [0, 300] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="check_wall_detection" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool check_wall_detection = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="wall_detection_aabb_min_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float wall_detection_aabb_min_x = 0; // [-15, 15] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="wall_detection_aabb_max_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float wall_detection_aabb_max_x = 0; // [-15, 15] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="wall_detection_aabb_min_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float wall_detection_aabb_min_y = 0; // [-15, 15] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="wall_detection_aabb_max_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float wall_detection_aabb_max_y = 0; // [-15, 15] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="check_floor_detection" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool check_floor_detection = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="floor_detection_aabb_min_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float floor_detection_aabb_min_x = 0; // [-15, 15] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="floor_detection_aabb_max_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float floor_detection_aabb_max_x = 0; // [-15, 15] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="floor_detection_aabb_min_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float floor_detection_aabb_min_y = 0; // [-15, 15] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="floor_detection_aabb_max_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float floor_detection_aabb_max_y = 0; // [-15, 15] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mChangingDirectionCounter" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mChangingDirectionCounter = -1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="ControlsComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ControlsComponent {<br>&emsp;&emsp;&emsp;&emsp;bool polymorph_hax = 0;<br>&emsp;&emsp;&emsp;&emsp;int polymorph_next_attack_frame = 0;<br>&emsp;&emsp;&emsp;&emsp;bool enabled = 1;<br>&emsp;&emsp;&emsp;&emsp;bool gamepad_indirect_aiming_enabled = 0;<br>&emsp;&emsp;&emsp;&emsp;bool gamepad_fire_on_thumbstick_extend = 0;<br>&emsp;&emsp;&emsp;&emsp;float gamepad_fire_on_thumbstick_extend_threshold = 0.7;<br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownFire = 0;<br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameFire = 0;<br>&emsp;&emsp;&emsp;&emsp;int mButtonLastFrameFire = -2;<br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownFire2 = 0;<br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameFire2 = 0;<br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownAction = 0;<br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameAction = 0;<br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownThrow = 0;<br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameThrow = 0;<br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownInteract = 0;<br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameInteract = 0;<br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownLeft = 0;<br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameLeft = 0;<br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownRight = 0;<br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameRight = 0;<br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownUp = 0;<br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameUp = 0;<br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownDown = 0;<br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameDown = 0;<br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownJump = 0;<br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameJump = 0;<br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownRun = 0;<br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameRun = 0;<br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownFly = 0;<br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameFly = 0;<br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownDig = 0;<br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameDig = 0;<br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownChangeItemR = 0;<br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameChangeItemR = 0;<br>&emsp;&emsp;&emsp;&emsp;int mButtonCountChangeItemR = 0; //  note these have special count property<br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownChangeItemL = 0;<br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameChangeItemL = 0;<br>&emsp;&emsp;&emsp;&emsp;int mButtonCountChangeItemL = 0; //  note these have special count property<br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownInventory = 0;<br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameInventory = 0;<br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownHolsterItem = 0;<br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameHolsterItem = 0;<br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownDropItem = 0;<br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameDropItem = 0;<br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownKick = 0;<br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameKick = 0;<br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownEat = 0;<br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameEat = 0;<br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownLeftClick = 0; //  NOTE! Ignores gamepad, if mouse is pressed this will be true.<br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameLeftClick = 0; //  NOTE! Ignores gamepad, if mouse is pressed this will be true.<br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownRightClick = 0; //  NOTE! Ignores gamepad, if mouse is pressed this will be true.<br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameRightClick = 0; //  NOTE! Ignores gamepad, if mouse is pressed this will be true.<br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownTransformLeft = 0; //  NOT IN USE!<br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameTransformLeft = 0; //  NOT IN USE!<br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownTransformRight = 0; //  NOT IN USE!<br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameTransformRight = 0; //  NOT IN USE!<br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownTransformUp = 0; //  NOT IN USE!<br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameTransformUp = 0; //  NOT IN USE!<br>&emsp;&emsp;&emsp;&emsp;int mButtonCountTransformUp = 0; //  NOT IN USE!<br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownTransformDown = 0; //  NOT IN USE!<br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameTransformDown = 0; //  NOT IN USE!<br>&emsp;&emsp;&emsp;&emsp;int mButtonCountTransformDown = 0; //  NOT IN USE!<br>&emsp;&emsp;&emsp;&emsp;float mFlyingTargetY = 0;<br>&emsp;&emsp;&emsp;&emsp;vec2 mAimingVector;<br>&emsp;&emsp;&emsp;&emsp;vec2 mAimingVectorNormalized; //  Aiming vector normalized to unit sphere.<br>&emsp;&emsp;&emsp;&emsp;vec2 mAimingVectorNonZeroLatest;<br>&emsp;&emsp;&emsp;&emsp;vec2 mGamepadAimingVectorRaw;<br>&emsp;&emsp;&emsp;&emsp;vec2 mJumpVelocity; //  used mostly by AI only?<br>&emsp;&emsp;&emsp;&emsp;vec2 mMousePosition;<br>&emsp;&emsp;&emsp;&emsp;vec2 mMousePositionRaw;<br>&emsp;&emsp;&emsp;&emsp;vec2 mMousePositionRawPrev;<br>&emsp;&emsp;&emsp;&emsp;vec2 mMouseDelta;<br>&emsp;&emsp;&emsp;&emsp;vec2 mGamepadIndirectAiming;<br>&emsp;&emsp;&emsp;&emsp;vec2 mGamePadCursorInWorld; //  where the aiming cursor is in the world, updated by platformshooterplayer_system <br>&emsp;&emsp;&emsp;&emsp;uint32_t mButtonDownDelayLineFire = 0; //  Used to delay input for some game effects<br>&emsp;&emsp;&emsp;&emsp;uint32_t mButtonDownDelayLineFire2 = 0; //  Used to delay input for some game effects<br>&emsp;&emsp;&emsp;&emsp;uint32_t mButtonDownDelayLineRight = 0; //  Used to delay input for some game effects<br>&emsp;&emsp;&emsp;&emsp;uint32_t mButtonDownDelayLineLeft = 0; //  Used to delay input for some game effects<br>&emsp;&emsp;&emsp;&emsp;uint32_t mButtonDownDelayLineUp = 0; //  Used to delay input for some game effects<br>&emsp;&emsp;&emsp;&emsp;uint32_t mButtonDownDelayLineDown = 0; //  Used to delay input for some game effects<br>&emsp;&emsp;&emsp;&emsp;uint32_t mButtonDownDelayLineKick = 0; //  Used to delay input for some game effects<br>&emsp;&emsp;&emsp;&emsp;uint32_t mButtonDownDelayLineThrow = 0; //  Used to delay input for some game effects<br>&emsp;&emsp;&emsp;&emsp;uint32_t mButtonDownDelayLineJump = 0; //  Used to delay input for some game effects<br>&emsp;&emsp;&emsp;&emsp;uint32_t mButtonDownDelayLineFly = 0; //  Used to delay input for some game effects<br>&emsp;&emsp;&emsp;&emsp;LensValue<int> input_latency_frames; //  Adds latency to some inputs. Used by some game effects. Max 31.<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="polymorph_hax" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool polymorph_hax = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="polymorph_next_attack_frame" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int polymorph_next_attack_frame = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="enabled" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool enabled = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="gamepad_indirect_aiming_enabled" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool gamepad_indirect_aiming_enabled = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="gamepad_fire_on_thumbstick_extend" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool gamepad_fire_on_thumbstick_extend = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="gamepad_fire_on_thumbstick_extend_threshold" type="xs:decimal" default="0.7">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float gamepad_fire_on_thumbstick_extend_threshold = 0.7;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonDownFire" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mButtonDownFire = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonFrameFire" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mButtonFrameFire = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonLastFrameFire" type="xs:int" default="-2">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mButtonLastFrameFire = -2;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonDownFire2" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mButtonDownFire2 = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonFrameFire2" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mButtonFrameFire2 = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonDownAction" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mButtonDownAction = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonFrameAction" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mButtonFrameAction = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonDownThrow" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mButtonDownThrow = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonFrameThrow" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mButtonFrameThrow = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonDownInteract" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mButtonDownInteract = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonFrameInteract" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mButtonFrameInteract = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonDownLeft" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mButtonDownLeft = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonFrameLeft" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mButtonFrameLeft = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonDownRight" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mButtonDownRight = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonFrameRight" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mButtonFrameRight = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonDownUp" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mButtonDownUp = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonFrameUp" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mButtonFrameUp = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonDownDown" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mButtonDownDown = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonFrameDown" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mButtonFrameDown = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonDownJump" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mButtonDownJump = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonFrameJump" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mButtonFrameJump = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonDownRun" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mButtonDownRun = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonFrameRun" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mButtonFrameRun = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonDownFly" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mButtonDownFly = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonFrameFly" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mButtonFrameFly = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonDownDig" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mButtonDownDig = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonFrameDig" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mButtonFrameDig = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonDownChangeItemR" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mButtonDownChangeItemR = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonFrameChangeItemR" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mButtonFrameChangeItemR = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonCountChangeItemR" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mButtonCountChangeItemR = 0; //  note these have special count property<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonDownChangeItemL" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mButtonDownChangeItemL = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonFrameChangeItemL" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mButtonFrameChangeItemL = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonCountChangeItemL" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mButtonCountChangeItemL = 0; //  note these have special count property<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonDownInventory" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mButtonDownInventory = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonFrameInventory" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mButtonFrameInventory = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonDownHolsterItem" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mButtonDownHolsterItem = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonFrameHolsterItem" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mButtonFrameHolsterItem = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonDownDropItem" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mButtonDownDropItem = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonFrameDropItem" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mButtonFrameDropItem = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonDownKick" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mButtonDownKick = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonFrameKick" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mButtonFrameKick = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonDownEat" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mButtonDownEat = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonFrameEat" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mButtonFrameEat = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonDownLeftClick" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mButtonDownLeftClick = 0; //  NOTE! Ignores gamepad, if mouse is pressed this will be true.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonFrameLeftClick" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mButtonFrameLeftClick = 0; //  NOTE! Ignores gamepad, if mouse is pressed this will be true.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonDownRightClick" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mButtonDownRightClick = 0; //  NOTE! Ignores gamepad, if mouse is pressed this will be true.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonFrameRightClick" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mButtonFrameRightClick = 0; //  NOTE! Ignores gamepad, if mouse is pressed this will be true.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonDownTransformLeft" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mButtonDownTransformLeft = 0; //  NOT IN USE!<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonFrameTransformLeft" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mButtonFrameTransformLeft = 0; //  NOT IN USE!<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonDownTransformRight" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mButtonDownTransformRight = 0; //  NOT IN USE!<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonFrameTransformRight" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mButtonFrameTransformRight = 0; //  NOT IN USE!<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonDownTransformUp" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mButtonDownTransformUp = 0; //  NOT IN USE!<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonFrameTransformUp" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mButtonFrameTransformUp = 0; //  NOT IN USE!<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonCountTransformUp" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mButtonCountTransformUp = 0; //  NOT IN USE!<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonDownTransformDown" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mButtonDownTransformDown = 0; //  NOT IN USE!<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonFrameTransformDown" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mButtonFrameTransformDown = 0; //  NOT IN USE!<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonCountTransformDown" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mButtonCountTransformDown = 0; //  NOT IN USE!<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mFlyingTargetY" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mFlyingTargetY = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mAimingVector.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mAimingVector;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mAimingVector.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mAimingVector;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mAimingVectorNormalized.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mAimingVectorNormalized; //  Aiming vector normalized to unit sphere.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mAimingVectorNormalized.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mAimingVectorNormalized; //  Aiming vector normalized to unit sphere.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mAimingVectorNonZeroLatest.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mAimingVectorNonZeroLatest;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mAimingVectorNonZeroLatest.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mAimingVectorNonZeroLatest;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mGamepadAimingVectorRaw.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mGamepadAimingVectorRaw;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mGamepadAimingVectorRaw.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mGamepadAimingVectorRaw;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mJumpVelocity.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mJumpVelocity; //  used mostly by AI only?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mJumpVelocity.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mJumpVelocity; //  used mostly by AI only?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mMousePosition.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mMousePosition;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mMousePosition.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mMousePosition;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mMousePositionRaw.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mMousePositionRaw;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mMousePositionRaw.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mMousePositionRaw;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mMousePositionRawPrev.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mMousePositionRawPrev;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mMousePositionRawPrev.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mMousePositionRawPrev;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mMouseDelta.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mMouseDelta;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mMouseDelta.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mMouseDelta;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mGamepadIndirectAiming.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mGamepadIndirectAiming;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mGamepadIndirectAiming.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mGamepadIndirectAiming;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mGamePadCursorInWorld.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mGamePadCursorInWorld; //  where the aiming cursor is in the world, updated by platformshooterplayer_system <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mGamePadCursorInWorld.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mGamePadCursorInWorld; //  where the aiming cursor is in the world, updated by platformshooterplayer_system <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonDownDelayLineFire" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint32_t mButtonDownDelayLineFire = 0; //  Used to delay input for some game effects<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonDownDelayLineFire2" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint32_t mButtonDownDelayLineFire2 = 0; //  Used to delay input for some game effects<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonDownDelayLineRight" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint32_t mButtonDownDelayLineRight = 0; //  Used to delay input for some game effects<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonDownDelayLineLeft" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint32_t mButtonDownDelayLineLeft = 0; //  Used to delay input for some game effects<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonDownDelayLineUp" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint32_t mButtonDownDelayLineUp = 0; //  Used to delay input for some game effects<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonDownDelayLineDown" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint32_t mButtonDownDelayLineDown = 0; //  Used to delay input for some game effects<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonDownDelayLineKick" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint32_t mButtonDownDelayLineKick = 0; //  Used to delay input for some game effects<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonDownDelayLineThrow" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint32_t mButtonDownDelayLineThrow = 0; //  Used to delay input for some game effects<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonDownDelayLineJump" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint32_t mButtonDownDelayLineJump = 0; //  Used to delay input for some game effects<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mButtonDownDelayLineFly" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint32_t mButtonDownDelayLineFly = 0; //  Used to delay input for some game effects<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="input_latency_frames" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>LensValue<int> input_latency_frames; //  Adds latency to some inputs. Used by some game effects. Max 31.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="CrawlerAnimalComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class CrawlerAnimalComponent {<br>&emsp;&emsp;&emsp;&emsp;float ray_length = 5; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;int ray_count = 16; // [0, 64] <br>&emsp;&emsp;&emsp;&emsp;float gravity = 600; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float terminal_velocity = 600; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float speed = 0.2; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;int give_up_area_radius = 20; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;int give_up_time = 45; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;float attack_from_ceiling_check_ray_length = 128; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;int attack_from_ceiling_check_every_n_frames = 15; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;float collision_damage = 0.25; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;float collision_damage_radius = 10; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;int collision_damage_frames_between = 10; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;bool animate = 1;<br>&emsp;&emsp;&emsp;&emsp;bool mDir = 1;<br>&emsp;&emsp;&emsp;&emsp;int mFrameNextGiveUp = 0;<br>&emsp;&emsp;&emsp;&emsp;int mFrameNextDamage = 0;<br>&emsp;&emsp;&emsp;&emsp;int mFrameNextAttackFromCeilingCheck = 0;<br>&emsp;&emsp;&emsp;&emsp;vec2 mMin;<br>&emsp;&emsp;&emsp;&emsp;vec2 mMax;<br>&emsp;&emsp;&emsp;&emsp;vec2 mPrevNonSnappedPosition;<br>&emsp;&emsp;&emsp;&emsp;ivec2 mPrevCellPosition;<br>&emsp;&emsp;&emsp;&emsp;ivec2 mPrevCellPosition2;<br>&emsp;&emsp;&emsp;&emsp;ivec2 mPrevCellPosition3;<br>&emsp;&emsp;&emsp;&emsp;ivec2 mPrevCellPosition4;<br>&emsp;&emsp;&emsp;&emsp;ivec2 mPrevCellPosition5;<br>&emsp;&emsp;&emsp;&emsp;ivec2 mPrevCellPosition6;<br>&emsp;&emsp;&emsp;&emsp;ivec2 mPrevCellPosition7;<br>&emsp;&emsp;&emsp;&emsp;ivec2 mPrevCellPosition8;<br>&emsp;&emsp;&emsp;&emsp;ivec2 mLatestPosition;<br>&emsp;&emsp;&emsp;&emsp;bool mPrevFalling = 0;<br>&emsp;&emsp;&emsp;&emsp;bool mIsInitialized = 0;<br>&emsp;&emsp;&emsp;&emsp;float mVelocityY = 0;<br>&emsp;&emsp;&emsp;&emsp;float mAngle = 0;<br>&emsp;&emsp;&emsp;&emsp;float mMovementStepAccumulator = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="ray_length" type="xs:decimal" default="5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float ray_length = 5; // [0, 100] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ray_count" type="xs:int" default="16">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int ray_count = 16; // [0, 64] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="gravity" type="xs:decimal" default="600">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float gravity = 600; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="terminal_velocity" type="xs:decimal" default="600">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float terminal_velocity = 600; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="speed" type="xs:decimal" default="0.2">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float speed = 0.2; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="give_up_area_radius" type="xs:int" default="20">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int give_up_area_radius = 20; // [0, 1000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="give_up_time" type="xs:int" default="45">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int give_up_time = 45; // [0, 1000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_from_ceiling_check_ray_length" type="xs:decimal" default="128">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float attack_from_ceiling_check_ray_length = 128; // [0, 1000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attack_from_ceiling_check_every_n_frames" type="xs:int" default="15">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int attack_from_ceiling_check_every_n_frames = 15; // [0, 1000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="collision_damage" type="xs:decimal" default="0.25">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float collision_damage = 0.25; // [0, 1000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="collision_damage_radius" type="xs:decimal" default="10">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float collision_damage_radius = 10; // [0, 1000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="collision_damage_frames_between" type="xs:int" default="10">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int collision_damage_frames_between = 10; // [0, 1000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="animate" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool animate = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mDir" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mDir = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mFrameNextGiveUp" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mFrameNextGiveUp = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mFrameNextDamage" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mFrameNextDamage = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mFrameNextAttackFromCeilingCheck" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mFrameNextAttackFromCeilingCheck = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mMin.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mMin;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mMin.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mMin;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mMax.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mMax;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mMax.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mMax;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevNonSnappedPosition.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mPrevNonSnappedPosition;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevNonSnappedPosition.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mPrevNonSnappedPosition;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevCellPosition.x" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 mPrevCellPosition;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevCellPosition.y" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 mPrevCellPosition;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevCellPosition2.x" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 mPrevCellPosition2;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevCellPosition2.y" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 mPrevCellPosition2;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevCellPosition3.x" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 mPrevCellPosition3;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevCellPosition3.y" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 mPrevCellPosition3;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevCellPosition4.x" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 mPrevCellPosition4;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevCellPosition4.y" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 mPrevCellPosition4;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevCellPosition5.x" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 mPrevCellPosition5;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevCellPosition5.y" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 mPrevCellPosition5;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevCellPosition6.x" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 mPrevCellPosition6;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevCellPosition6.y" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 mPrevCellPosition6;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevCellPosition7.x" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 mPrevCellPosition7;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevCellPosition7.y" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 mPrevCellPosition7;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevCellPosition8.x" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 mPrevCellPosition8;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevCellPosition8.y" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 mPrevCellPosition8;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLatestPosition.x" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 mLatestPosition;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLatestPosition.y" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 mLatestPosition;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevFalling" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mPrevFalling = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mIsInitialized" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mIsInitialized = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mVelocityY" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mVelocityY = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mAngle" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mAngle = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mMovementStepAccumulator" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mMovementStepAccumulator = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="CutThroughWorldDoneHereComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class CutThroughWorldDoneHereComponent {<br>&emsp;&emsp;&emsp;&emsp;uint32 id_of_done_cut = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="id_of_done_cut" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint32 id_of_done_cut = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="DamageModelComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class DamageModelComponent {<br>&emsp;&emsp;&emsp;&emsp;double hp = 1; // [0, 4] hit points at the moment<br>&emsp;&emsp;&emsp;&emsp;double max_hp = 0; // [0, 4] the maximum hp that this can have, we'll set this when loading<br>&emsp;&emsp;&emsp;&emsp;double max_hp_cap = 0; // [0, 12] the maximum 'max_hp' that this can have, <= 0 means no limits. Used by perks such as GLASS_CANNON<br>&emsp;&emsp;&emsp;&emsp;double max_hp_old = 0; //  used for UI rendering<br>&emsp;&emsp;&emsp;&emsp;float critical_damage_resistance = 0; //  0.0 = all critical damage multiplier is applied. 1.0 = no critical damage multiplier is applied<br>&emsp;&emsp;&emsp;&emsp;int invincibility_frames = 0; // [0, 1024] if positive, doesn't take damage<br>&emsp;&emsp;&emsp;&emsp;bool falling_damages = 1; //  do we take fall damage<br>&emsp;&emsp;&emsp;&emsp;float falling_damage_height_min = 70; //  how far do we need to fall to take damage, we start with this height, the peasant takes min damage from this<br>&emsp;&emsp;&emsp;&emsp;float falling_damage_height_max = 250; //  after this the peasant always takes the maximum fall damage<br>&emsp;&emsp;&emsp;&emsp;float falling_damage_damage_min = 0.1; //  when we fall over height_min we take this much, lineary ramping to damage_max<br>&emsp;&emsp;&emsp;&emsp;float falling_damage_damage_max = 1.2; //  when we fall over height_min we take this much, lineary ramping to damage_max<br>&emsp;&emsp;&emsp;&emsp;bool air_needed = 1; //  Do we breath, can we take damage from not breathing?<br>&emsp;&emsp;&emsp;&emsp;float air_in_lungs = 5; //  How much air do we have in our lungs? - after the air runs out we take damage<br>&emsp;&emsp;&emsp;&emsp;float air_in_lungs_max = 5; //  how much air can we have in our lungs, it's filled to this point if we're not in water<br>&emsp;&emsp;&emsp;&emsp;float air_lack_of_damage = 0.2; //  (* dt)... damage in a second if we're in the water<br>&emsp;&emsp;&emsp;&emsp;float minimum_knockback_force = 0; //  Minimum knockback force required to do the knockback<br>&emsp;&emsp;&emsp;&emsp;bool materials_damage = 1; //  should materials do damage or not?<br>&emsp;&emsp;&emsp;&emsp;int material_damage_min_cell_count = 4; //  if material damage is received from less than 'material_damage_min_cell_count' this frame, it is ignored<br>&emsp;&emsp;&emsp;&emsp;std::string materials_that_damage = "acid"; //  list of materials that do damage, separated by ',' e.g. 'acid, fire, smoke'<br>&emsp;&emsp;&emsp;&emsp;std::string materials_how_much_damage = "0.1"; //  list of damage amount per material in materials_that_damage, separated by ','<br>&emsp;&emsp;&emsp;&emsp;bool materials_damage_proportional_to_maxhp = 0; //  if damage from materials is proportional to max hp, instead of just damage<br>&emsp;&emsp;&emsp;&emsp;bool physics_objects_damage = 0; //  if true, will take damage from physics objects that hit it<br>&emsp;&emsp;&emsp;&emsp;bool materials_create_messages = 0; //  should collisions with certain materials create messages or not?<br>&emsp;&emsp;&emsp;&emsp;std::string materials_that_create_messages = "meat"; //  list of materials that generate CollisionWithCell messages, separated by ',' e.g. 'acid, fire, smoke'<br>&emsp;&emsp;&emsp;&emsp;std::string ragdoll_filenames_file = "data/temp/ragdoll/filenames.txt"; //  the file from which to load a ragdoll on death'<br>&emsp;&emsp;&emsp;&emsp;std::string ragdoll_material = "meat"; //  what material is the ragdoll made out of<br>&emsp;&emsp;&emsp;&emsp;float ragdoll_offset_x = 0; //  where should the ragdoll be created relative to our entity position'<br>&emsp;&emsp;&emsp;&emsp;float ragdoll_offset_y = 0; //  where should the ragdoll be created relative to our entity position'<br>&emsp;&emsp;&emsp;&emsp;std::string blood_material = "blood_fading"; //  this is the material that gets thrown as particles when this entity takes damage<br>&emsp;&emsp;&emsp;&emsp;std::string blood_spray_material; //  this is the material that gets thrown as particles when this entity sprays blood on death<br>&emsp;&emsp;&emsp;&emsp;bool blood_spray_create_some_cosmetic = 0; //  if true, we force some blood spray particles to be cosmetic (can be enabled to avoid making a huge mess of blood spray)<br>&emsp;&emsp;&emsp;&emsp;float blood_multiplier = 1; // [0, 10] how much blood, this is the multiplier used for sprouting lots or little blood<br>&emsp;&emsp;&emsp;&emsp;int ragdoll_blood_amount_absolute = -1; // [-1, 1000] if > -1, this is the absolute amount of blood we share between particle emitters in the ragdoll<br>&emsp;&emsp;&emsp;&emsp;std::string blood_sprite_directional; //  this sprite is loaded at damage position if we take damage that creates a blood effect<br>&emsp;&emsp;&emsp;&emsp;std::string blood_sprite_large; //  this sprite is loaded at damage position if we take explosion/heavy damage<br>&emsp;&emsp;&emsp;&emsp;std::string healing_particle_effect_entity; //  if this is set, will load this entity as a child of this entity, when this entity is healed<br>&emsp;&emsp;&emsp;&emsp;bool create_ragdoll = 1; //  if 0, we skip ragdoll creation on death<br>&emsp;&emsp;&emsp;&emsp;bool ragdollify_child_entity_sprites = 0; //  if 1, we ragdollify child entity sprites<br>&emsp;&emsp;&emsp;&emsp;float ragdollify_root_angular_damping = 0; //  If ragdoll_filenames_file= and > 0, the angular damping of the first ragdoll body is set to this value.<br>&emsp;&emsp;&emsp;&emsp;bool ragdollify_disintegrate_nonroot = 0; //  If ragdoll_filenames_file= and true, all but the first sprite on the root entity will be disintegrated instead of being turned into physics bodies.<br>&emsp;&emsp;&emsp;&emsp;bool wait_for_kill_flag_on_death = 0; //  if 1, we wont kill the entity along with kill fx and ragdoll until 'kill' is 1<br>&emsp;&emsp;&emsp;&emsp;bool kill_now = 0; //  if 1, we wont kill the entity along with kill fx and ragdoll until 'kill_now' is 1<br>&emsp;&emsp;&emsp;&emsp;bool drop_items_on_death = 1; //  drop the abilities as items on death?<br>&emsp;&emsp;&emsp;&emsp;bool ui_report_damage = 1; //  If 1, damage numbers are displayed when this entity is damaged<br>&emsp;&emsp;&emsp;&emsp;bool ui_force_report_damage = 0; //  If 1, damage numbers are displayed when this entity is damaged, even if the numbers are disabled in settings<br>&emsp;&emsp;&emsp;&emsp;int in_liquid_shooting_electrify_prob = 0; // [0, 100] when shooting underwater how likely are we to electrify the water<br>&emsp;&emsp;&emsp;&emsp;float wet_status_effect_damage = 0; // [0, 0.1] how much damage per 10 frames is done if entity has 'wet' status effect<br>&emsp;&emsp;&emsp;&emsp;bool is_on_fire = 0; //  Tells us we're on fire or not<br>&emsp;&emsp;&emsp;&emsp;float fire_probability_of_ignition = 0.5; //  what is the probability that we'll ignite, 0 means won't ever ignite<br>&emsp;&emsp;&emsp;&emsp;int fire_how_much_fire_generates = 4; // [0, 10] how many fire particles do we generate each frame<br>&emsp;&emsp;&emsp;&emsp;float fire_damage_ignited_amount = 0.0003; // [0, 2] how much damage does being ignited do?<br>&emsp;&emsp;&emsp;&emsp;float fire_damage_amount = 0.2; // [0, 2] how much damage does fire do?, 0.2 is pretty good<br>&emsp;&emsp;&emsp;&emsp;int mLastElectricityResistanceFrame = -2147483648; //  Last frame electricity has no effect. Should not be private!<br>&emsp;&emsp;&emsp;&emsp;int mLastFrameReportedBlock = -2147483648; //  Last frame a damage block message was displayed for this entity<br>&emsp;&emsp;&emsp;&emsp;int mLastMaxHpChangeFrame = -10000; //  used for UI rendering<br>&emsp;&emsp;&emsp;&emsp;ConfigDamagesByType damage_multipliers; //  the multipliers applied to different types of damage<br>&emsp;&emsp;&emsp;&emsp;RAGDOLL_FX::Enum ragdoll_fx_forced; //  if set, will force this ragdoll fx to happen everytime<br>&emsp;&emsp;&emsp;&emsp;bool mIsOnFire = 0; //  private variable to check when we're on fire and not<br>&emsp;&emsp;&emsp;&emsp;int mFireProbability = 100; //  this gets decreased if we can't ignite anything else<br>&emsp;&emsp;&emsp;&emsp;int mFireFramesLeft = 0; //  this is the remaining frames we're on fire<br>&emsp;&emsp;&emsp;&emsp;int mFireDurationFrames = 0; //  this is the total duration in frames we're on fire<br>&emsp;&emsp;&emsp;&emsp;bool mFireTriedIgniting = 0; //  private variable to check when we could have been ignited or not<br>&emsp;&emsp;&emsp;&emsp;int mLastCheckX = 0; //  an optimization, so we don't have to check everything every frame<br>&emsp;&emsp;&emsp;&emsp;int mLastCheckY = 0; //  an optimization, so we don't have to check everything every frame<br>&emsp;&emsp;&emsp;&emsp;int mLastCheckTime = 0; //  an optimization, so we don't have to check everything every frame<br>&emsp;&emsp;&emsp;&emsp;int mLastMaterialDamageFrame = 0; //  this is the last frame we took material damage<br>&emsp;&emsp;&emsp;&emsp;bool mFallIsOnGround = 0; //  for fall damage, keeps a private variable about if we're on ground or not<br>&emsp;&emsp;&emsp;&emsp;float mFallHighestY = 3.40282e+038; //  private var to keep track of how high have we flown to<br>&emsp;&emsp;&emsp;&emsp;int mFallCount = 0; //  how many times have we fallen? This is used to make sure we don't take damage from the first fall<br>&emsp;&emsp;&emsp;&emsp;bool mAirAreWeInWater = 0; //  a private variable to track our state in drowning<br>&emsp;&emsp;&emsp;&emsp;int mAirFramesNotInWater = 0; //  how many frames have been with air to breathe<br>&emsp;&emsp;&emsp;&emsp;bool mAirDoWeHave = 0; //  a private variable to track our state in drowning<br>&emsp;&emsp;&emsp;&emsp;int mTotalCells = 0; //  how many cells are there total<br>&emsp;&emsp;&emsp;&emsp;int mLiquidCount = 0; //  how many of the cells are liquid<br>&emsp;&emsp;&emsp;&emsp;int mLiquidMaterialWeAreIn = -1; //  stores the liquid material we're in... may not be the most accurate<br>&emsp;&emsp;&emsp;&emsp;std::vector< int > mDamageMaterials; //  NOTE! Sorted! a list of materials that do damage (materials_that_damage)<br>&emsp;&emsp;&emsp;&emsp;std::vector< float > mDamageMaterialsHowMuch; //  NOTE! Sorted! a list of materials that do damage (materials_that_damage)<br>&emsp;&emsp;&emsp;&emsp;std::vector< int > mCollisionMessageMaterials; //  NOTE! Sorted! a list of materials that create messages (materials_that_create_messages)<br>&emsp;&emsp;&emsp;&emsp;std::vector< int > mCollisionMessageMaterialCountsThisFrame; //  Number of cells per collided with this frame. Order matches mCollisionMessageMaterials<br>&emsp;&emsp;&emsp;&emsp;std::vector< float > mMaterialDamageThisFrame; //  A list of damage per material that damages us. In same order as materials<br>&emsp;&emsp;&emsp;&emsp;float mFallDamageThisFrame = 0; //  Amount of fall damage received this frame<br>&emsp;&emsp;&emsp;&emsp;float mElectricityDamageThisFrame = 0; //  Amount of electricity damage received this frame<br>&emsp;&emsp;&emsp;&emsp;float mPhysicsDamageThisFrame = 0; //  max physics damage we have taken this round<br>&emsp;&emsp;&emsp;&emsp;vec2 mPhysicsDamageVecThisFrame; //  direction of physics damage<br>&emsp;&emsp;&emsp;&emsp;int mPhysicsDamageLastFrame = 0; //  frame number when we took physics damage<br>&emsp;&emsp;&emsp;&emsp;EntityTypeID mPhysicsDamageEntity = 0; //  the physics entity that hit us<br>&emsp;&emsp;&emsp;&emsp;EntityTypeID mPhysicsDamageTelekinesisCasterEntity = 0; //  who moved an object that hit us via telekinesis<br>&emsp;&emsp;&emsp;&emsp;int mLastDamageFrame = -120; //  frame number when we took any damage<br>&emsp;&emsp;&emsp;&emsp;double mHpBeforeLastDamage = 0; //  how much hp did we have a while ago?<br>&emsp;&emsp;&emsp;&emsp;float mFireDamageBuffered = 0; //  used to optimized cases where lots of entities are taking fire damage<br>&emsp;&emsp;&emsp;&emsp;int32 mFireDamageBufferedNextDeliveryFrame = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
			<xs:all>
				<xs:element name="damage_multipliers" type="ConfigDamagesByType" minOccurs="0"/>
			</xs:all>
		<xs:attribute name="hp" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>double hp = 1; // [0, 4] hit points at the moment<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="max_hp" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>double max_hp = 0; // [0, 4] the maximum hp that this can have, we'll set this when loading<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="max_hp_cap" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>double max_hp_cap = 0; // [0, 12] the maximum 'max_hp' that this can have, <= 0 means no limits. Used by perks such as GLASS_CANNON<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="max_hp_old" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>double max_hp_old = 0; //  used for UI rendering<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="critical_damage_resistance" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float critical_damage_resistance = 0; //  0.0 = all critical damage multiplier is applied. 1.0 = no critical damage multiplier is applied<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="invincibility_frames" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int invincibility_frames = 0; // [0, 1024] if positive, doesn't take damage<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="falling_damages" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool falling_damages = 1; //  do we take fall damage<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="falling_damage_height_min" type="xs:decimal" default="70">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float falling_damage_height_min = 70; //  how far do we need to fall to take damage, we start with this height, the peasant takes min damage from this<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="falling_damage_height_max" type="xs:decimal" default="250">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float falling_damage_height_max = 250; //  after this the peasant always takes the maximum fall damage<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="falling_damage_damage_min" type="xs:decimal" default="0.1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float falling_damage_damage_min = 0.1; //  when we fall over height_min we take this much, lineary ramping to damage_max<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="falling_damage_damage_max" type="xs:decimal" default="1.2">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float falling_damage_damage_max = 1.2; //  when we fall over height_min we take this much, lineary ramping to damage_max<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="air_needed" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool air_needed = 1; //  Do we breath, can we take damage from not breathing?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="air_in_lungs" type="xs:decimal" default="5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float air_in_lungs = 5; //  How much air do we have in our lungs? - after the air runs out we take damage<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="air_in_lungs_max" type="xs:decimal" default="5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float air_in_lungs_max = 5; //  how much air can we have in our lungs, it's filled to this point if we're not in water<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="air_lack_of_damage" type="xs:decimal" default="0.2">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float air_lack_of_damage = 0.2; //  (* dt)... damage in a second if we're in the water<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="minimum_knockback_force" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float minimum_knockback_force = 0; //  Minimum knockback force required to do the knockback<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="materials_damage" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool materials_damage = 1; //  should materials do damage or not?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="material_damage_min_cell_count" type="xs:int" default="4">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int material_damage_min_cell_count = 4; //  if material damage is received from less than 'material_damage_min_cell_count' this frame, it is ignored<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="materials_that_damage" type="xs:string" default="acid">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string materials_that_damage = "acid"; //  list of materials that do damage, separated by ',' e.g. 'acid, fire, smoke'<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="materials_how_much_damage" type="xs:string" default="0.1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string materials_how_much_damage = "0.1"; //  list of damage amount per material in materials_that_damage, separated by ','<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="materials_damage_proportional_to_maxhp" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool materials_damage_proportional_to_maxhp = 0; //  if damage from materials is proportional to max hp, instead of just damage<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="physics_objects_damage" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool physics_objects_damage = 0; //  if true, will take damage from physics objects that hit it<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="materials_create_messages" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool materials_create_messages = 0; //  should collisions with certain materials create messages or not?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="materials_that_create_messages" type="xs:string" default="meat">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string materials_that_create_messages = "meat"; //  list of materials that generate CollisionWithCell messages, separated by ',' e.g. 'acid, fire, smoke'<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ragdoll_filenames_file" type="xs:string" default="data/temp/ragdoll/filenames.txt">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string ragdoll_filenames_file = "data/temp/ragdoll/filenames.txt"; //  the file from which to load a ragdoll on death'<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ragdoll_material" type="xs:string" default="meat">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string ragdoll_material = "meat"; //  what material is the ragdoll made out of<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ragdoll_offset_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float ragdoll_offset_x = 0; //  where should the ragdoll be created relative to our entity position'<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ragdoll_offset_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float ragdoll_offset_y = 0; //  where should the ragdoll be created relative to our entity position'<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="blood_material" type="xs:string" default="blood_fading">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string blood_material = "blood_fading"; //  this is the material that gets thrown as particles when this entity takes damage<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="blood_spray_material" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string blood_spray_material; //  this is the material that gets thrown as particles when this entity sprays blood on death<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="blood_spray_create_some_cosmetic" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool blood_spray_create_some_cosmetic = 0; //  if true, we force some blood spray particles to be cosmetic (can be enabled to avoid making a huge mess of blood spray)<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="blood_multiplier" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float blood_multiplier = 1; // [0, 10] how much blood, this is the multiplier used for sprouting lots or little blood<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ragdoll_blood_amount_absolute" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int ragdoll_blood_amount_absolute = -1; // [-1, 1000] if > -1, this is the absolute amount of blood we share between particle emitters in the ragdoll<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="blood_sprite_directional" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string blood_sprite_directional; //  this sprite is loaded at damage position if we take damage that creates a blood effect<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="blood_sprite_large" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string blood_sprite_large; //  this sprite is loaded at damage position if we take explosion/heavy damage<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="healing_particle_effect_entity" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string healing_particle_effect_entity; //  if this is set, will load this entity as a child of this entity, when this entity is healed<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="create_ragdoll" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool create_ragdoll = 1; //  if 0, we skip ragdoll creation on death<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ragdollify_child_entity_sprites" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool ragdollify_child_entity_sprites = 0; //  if 1, we ragdollify child entity sprites<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ragdollify_root_angular_damping" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float ragdollify_root_angular_damping = 0; //  If ragdoll_filenames_file= and > 0, the angular damping of the first ragdoll body is set to this value.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ragdollify_disintegrate_nonroot" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool ragdollify_disintegrate_nonroot = 0; //  If ragdoll_filenames_file= and true, all but the first sprite on the root entity will be disintegrated instead of being turned into physics bodies.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="wait_for_kill_flag_on_death" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool wait_for_kill_flag_on_death = 0; //  if 1, we wont kill the entity along with kill fx and ragdoll until 'kill' is 1<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="kill_now" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool kill_now = 0; //  if 1, we wont kill the entity along with kill fx and ragdoll until 'kill_now' is 1<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="drop_items_on_death" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool drop_items_on_death = 1; //  drop the abilities as items on death?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ui_report_damage" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool ui_report_damage = 1; //  If 1, damage numbers are displayed when this entity is damaged<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ui_force_report_damage" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool ui_force_report_damage = 0; //  If 1, damage numbers are displayed when this entity is damaged, even if the numbers are disabled in settings<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="in_liquid_shooting_electrify_prob" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int in_liquid_shooting_electrify_prob = 0; // [0, 100] when shooting underwater how likely are we to electrify the water<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="wet_status_effect_damage" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float wet_status_effect_damage = 0; // [0, 0.1] how much damage per 10 frames is done if entity has 'wet' status effect<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_on_fire" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_on_fire = 0; //  Tells us we're on fire or not<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fire_probability_of_ignition" type="xs:decimal" default="0.5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float fire_probability_of_ignition = 0.5; //  what is the probability that we'll ignite, 0 means won't ever ignite<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fire_how_much_fire_generates" type="xs:int" default="4">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int fire_how_much_fire_generates = 4; // [0, 10] how many fire particles do we generate each frame<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fire_damage_ignited_amount" type="xs:decimal" default="0.0003">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float fire_damage_ignited_amount = 0.0003; // [0, 2] how much damage does being ignited do?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fire_damage_amount" type="xs:decimal" default="0.2">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float fire_damage_amount = 0.2; // [0, 2] how much damage does fire do?, 0.2 is pretty good<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLastElectricityResistanceFrame" type="xs:int" default="-2147483648">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mLastElectricityResistanceFrame = -2147483648; //  Last frame electricity has no effect. Should not be private!<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLastFrameReportedBlock" type="xs:int" default="-2147483648">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mLastFrameReportedBlock = -2147483648; //  Last frame a damage block message was displayed for this entity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLastMaxHpChangeFrame" type="xs:int" default="-10000">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mLastMaxHpChangeFrame = -10000; //  used for UI rendering<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ragdoll_fx_forced" type="RAGDOLL_FX" default="NONE">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>RAGDOLL_FX::Enum ragdoll_fx_forced; //  if set, will force this ragdoll fx to happen everytime<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mIsOnFire" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mIsOnFire = 0; //  private variable to check when we're on fire and not<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mFireProbability" type="xs:int" default="100">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mFireProbability = 100; //  this gets decreased if we can't ignite anything else<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mFireFramesLeft" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mFireFramesLeft = 0; //  this is the remaining frames we're on fire<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mFireDurationFrames" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mFireDurationFrames = 0; //  this is the total duration in frames we're on fire<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mFireTriedIgniting" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mFireTriedIgniting = 0; //  private variable to check when we could have been ignited or not<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLastCheckX" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mLastCheckX = 0; //  an optimization, so we don't have to check everything every frame<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLastCheckY" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mLastCheckY = 0; //  an optimization, so we don't have to check everything every frame<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLastCheckTime" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mLastCheckTime = 0; //  an optimization, so we don't have to check everything every frame<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLastMaterialDamageFrame" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mLastMaterialDamageFrame = 0; //  this is the last frame we took material damage<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mFallIsOnGround" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mFallIsOnGround = 0; //  for fall damage, keeps a private variable about if we're on ground or not<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mFallHighestY" type="xs:decimal" default="340282000000000014192072600942972764160">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mFallHighestY = 3.40282e+038; //  private var to keep track of how high have we flown to<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mFallCount" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mFallCount = 0; //  how many times have we fallen? This is used to make sure we don't take damage from the first fall<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mAirAreWeInWater" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mAirAreWeInWater = 0; //  a private variable to track our state in drowning<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mAirFramesNotInWater" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mAirFramesNotInWater = 0; //  how many frames have been with air to breathe<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mAirDoWeHave" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mAirDoWeHave = 0; //  a private variable to track our state in drowning<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mTotalCells" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mTotalCells = 0; //  how many cells are there total<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLiquidCount" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mLiquidCount = 0; //  how many of the cells are liquid<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLiquidMaterialWeAreIn" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mLiquidMaterialWeAreIn = -1; //  stores the liquid material we're in... may not be the most accurate<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: std::vector< int > for mDamageMaterials -->
		<!-- Some Unknown Type: std::vector< float > for mDamageMaterialsHowMuch -->
		<!-- Some Unknown Type: std::vector< int > for mCollisionMessageMaterials -->
		<!-- Some Unknown Type: std::vector< int > for mCollisionMessageMaterialCountsThisFrame -->
		<!-- Some Unknown Type: std::vector< float > for mMaterialDamageThisFrame -->
		<xs:attribute name="mFallDamageThisFrame" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mFallDamageThisFrame = 0; //  Amount of fall damage received this frame<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mElectricityDamageThisFrame" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mElectricityDamageThisFrame = 0; //  Amount of electricity damage received this frame<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPhysicsDamageThisFrame" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mPhysicsDamageThisFrame = 0; //  max physics damage we have taken this round<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPhysicsDamageVecThisFrame.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mPhysicsDamageVecThisFrame; //  direction of physics damage<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPhysicsDamageVecThisFrame.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mPhysicsDamageVecThisFrame; //  direction of physics damage<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPhysicsDamageLastFrame" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mPhysicsDamageLastFrame = 0; //  frame number when we took physics damage<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: EntityTypeID for mPhysicsDamageEntity -->
		<!-- Some Unknown Type: EntityTypeID for mPhysicsDamageTelekinesisCasterEntity -->
		<xs:attribute name="mLastDamageFrame" type="xs:int" default="-120">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mLastDamageFrame = -120; //  frame number when we took any damage<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mHpBeforeLastDamage" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>double mHpBeforeLastDamage = 0; //  how much hp did we have a while ago?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mFireDamageBuffered" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mFireDamageBuffered = 0; //  used to optimized cases where lots of entities are taking fire damage<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mFireDamageBufferedNextDeliveryFrame" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int32 mFireDamageBufferedNextDeliveryFrame = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="DamageNearbyEntitiesComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class DamageNearbyEntitiesComponent {<br>&emsp;&emsp;&emsp;&emsp;float radius = 10;<br>&emsp;&emsp;&emsp;&emsp;float damage_min = 0.1;<br>&emsp;&emsp;&emsp;&emsp;float damage_max = 0.2;<br>&emsp;&emsp;&emsp;&emsp;float target_vec_max_len = 5;<br>&emsp;&emsp;&emsp;&emsp;float knockback_multiplier = 1;<br>&emsp;&emsp;&emsp;&emsp;int time_between_damaging = 20;<br>&emsp;&emsp;&emsp;&emsp;std::string damage_description = "bite";<br>&emsp;&emsp;&emsp;&emsp;std::string target_tag = "mortal";<br>&emsp;&emsp;&emsp;&emsp;DAMAGE_TYPES::Enum damage_type; //  the damage type<br>&emsp;&emsp;&emsp;&emsp;RAGDOLL_FX::Enum ragdoll_fx;<br>&emsp;&emsp;&emsp;&emsp;vec2 mVelocity;<br>&emsp;&emsp;&emsp;&emsp;int mNextDamageFrame = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="radius" type="xs:decimal" default="10">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float radius = 10;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_min" type="xs:decimal" default="0.1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float damage_min = 0.1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_max" type="xs:decimal" default="0.2">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float damage_max = 0.2;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="target_vec_max_len" type="xs:decimal" default="5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float target_vec_max_len = 5;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="knockback_multiplier" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float knockback_multiplier = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="time_between_damaging" type="xs:int" default="20">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int time_between_damaging = 20;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_description" type="xs:string" default="bite">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string damage_description = "bite";<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="target_tag" type="xs:string" default="mortal">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string target_tag = "mortal";<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_type" type="DAMAGE_TYPES" default="NONE">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>DAMAGE_TYPES::Enum damage_type; //  the damage type<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ragdoll_fx" type="RAGDOLL_FX" default="NONE">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>RAGDOLL_FX::Enum ragdoll_fx;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mVelocity.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mVelocity;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mVelocity.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mVelocity;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mNextDamageFrame" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mNextDamageFrame = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="DebugFollowMouseComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class DebugFollowMouseComponent {<br><br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="DebugLogMessagesComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class DebugLogMessagesComponent {<br>&emsp;&emsp;&emsp;&emsp;float TEMP_TEMPY = 0; // [0, 3.5] <br>&emsp;&emsp;&emsp;&emsp;float TEMP_TEMP_TEMP = 0; // [0, 3.5] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="TEMP_TEMPY" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float TEMP_TEMPY = 0; // [0, 3.5] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="TEMP_TEMP_TEMP" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float TEMP_TEMP_TEMP = 0; // [0, 3.5] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="DebugSpatialVisualizerComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class DebugSpatialVisualizerComponent {<br>&emsp;&emsp;&emsp;&emsp;float min_x = 0;<br>&emsp;&emsp;&emsp;&emsp;float min_y = 0;<br>&emsp;&emsp;&emsp;&emsp;float max_x = 0;<br>&emsp;&emsp;&emsp;&emsp;float max_y = 0;<br>&emsp;&emsp;&emsp;&emsp;unsigned int color = 4294967295;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="min_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float min_x = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="min_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float min_y = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="max_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float max_x = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="max_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float max_y = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="color" type="xs:unsignedInt" default="4294967295">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>unsigned int color = 4294967295;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="DieIfSpeedBelowComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class DieIfSpeedBelowComponent {<br>&emsp;&emsp;&emsp;&emsp;float min_speed = 1; // [0, 1000] The entity that owns this component is killed if its speed (via VelocityComponent) falls below this value.<br>&emsp;&emsp;&emsp;&emsp;float mMinSpeedSquared = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="min_speed" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float min_speed = 1; // [0, 1000] The entity that owns this component is killed if its speed (via VelocityComponent) falls below this value.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mMinSpeedSquared" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mMinSpeedSquared = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="DroneLauncherComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class DroneLauncherComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string drone_entity_file = "data/entities/misc/player_drone.xml";<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="drone_entity_file" type="xs:string" default="data/entities/misc/player_drone.xml">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string drone_entity_file = "data/entities/misc/player_drone.xml";<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="DrugEffectComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class DrugEffectComponent {<br>&emsp;&emsp;&emsp;&emsp;ConfigDrugFx drug_fx_target;<br>&emsp;&emsp;&emsp;&emsp;ConfigDrugFx m_drug_fx_current;<br>};<br>```]]> </xs:documentation> </xs:annotation>
			<xs:all>
				<xs:element name="drug_fx_target" type="ConfigDrugFx" minOccurs="0"/>
				<xs:element name="m_drug_fx_current" type="ConfigDrugFx" minOccurs="0"/>
			</xs:all>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="DrugEffectModifierComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class DrugEffectModifierComponent {<br>&emsp;&emsp;&emsp;&emsp;ConfigDrugFx fx_add;<br>&emsp;&emsp;&emsp;&emsp;ConfigDrugFx fx_multiply;<br>};<br>```]]> </xs:documentation> </xs:annotation>
			<xs:all>
				<xs:element name="fx_add" type="ConfigDrugFx" minOccurs="0"/>
				<xs:element name="fx_multiply" type="ConfigDrugFx" minOccurs="0"/>
			</xs:all>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="ElectricChargeComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ElectricChargeComponent {<br>&emsp;&emsp;&emsp;&emsp;int charge_time_frames = 120; // [0, 240] <br>&emsp;&emsp;&emsp;&emsp;float fx_velocity_max = 120; // [0, 240] <br>&emsp;&emsp;&emsp;&emsp;int electricity_emission_interval_frames = 5; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;int fx_emission_interval_min = 2; // [0, 20] <br>&emsp;&emsp;&emsp;&emsp;int fx_emission_interval_max = 15; // [0, 30] <br>&emsp;&emsp;&emsp;&emsp;int charge = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="charge_time_frames" type="xs:int" default="120">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int charge_time_frames = 120; // [0, 240] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fx_velocity_max" type="xs:decimal" default="120">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float fx_velocity_max = 120; // [0, 240] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="electricity_emission_interval_frames" type="xs:int" default="5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int electricity_emission_interval_frames = 5; // [0, 10] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fx_emission_interval_min" type="xs:int" default="2">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int fx_emission_interval_min = 2; // [0, 20] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fx_emission_interval_max" type="xs:int" default="15">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int fx_emission_interval_max = 15; // [0, 30] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="charge" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int charge = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="ElectricityComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ElectricityComponent {<br>&emsp;&emsp;&emsp;&emsp;int energy = 1000; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float probability_to_heat = 0;<br>&emsp;&emsp;&emsp;&emsp;int speed = 32; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;int splittings_min = 0; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;int splittings_max = 0; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;int splitting_energy_min = 0; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;int splitting_energy_max = 0; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;bool hack_is_material_crack = 0;<br>&emsp;&emsp;&emsp;&emsp;bool hack_crack_ice = 0;<br>&emsp;&emsp;&emsp;&emsp;bool hack_is_set_fire = 0; //  if set will set the thing on fire where this is located at<br>&emsp;&emsp;&emsp;&emsp;int mSplittingsLeft = 0;<br>&emsp;&emsp;&emsp;&emsp;int mSplittingEnergy = 0;<br>&emsp;&emsp;&emsp;&emsp;vec2 mAvgDir;<br>&emsp;&emsp;&emsp;&emsp;ivec2 mPrevPos;<br>&emsp;&emsp;&emsp;&emsp;int mPrevMaterial = 0;<br>&emsp;&emsp;&emsp;&emsp;bool mShouldPlaySound = 1;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="energy" type="xs:int" default="1000">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int energy = 1000; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="probability_to_heat" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float probability_to_heat = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="speed" type="xs:int" default="32">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int speed = 32; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="splittings_min" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int splittings_min = 0; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="splittings_max" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int splittings_max = 0; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="splitting_energy_min" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int splitting_energy_min = 0; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="splitting_energy_max" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int splitting_energy_max = 0; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="hack_is_material_crack" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool hack_is_material_crack = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="hack_crack_ice" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool hack_crack_ice = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="hack_is_set_fire" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool hack_is_set_fire = 0; //  if set will set the thing on fire where this is located at<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mSplittingsLeft" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mSplittingsLeft = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mSplittingEnergy" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mSplittingEnergy = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mAvgDir.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mAvgDir;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mAvgDir.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mAvgDir;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevPos.x" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 mPrevPos;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevPos.y" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 mPrevPos;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevMaterial" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mPrevMaterial = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mShouldPlaySound" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mShouldPlaySound = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="ElectricityReceiverComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ElectricityReceiverComponent {<br>&emsp;&emsp;&emsp;&emsp;int offset_x = 0; // [1, 3] <br>&emsp;&emsp;&emsp;&emsp;int offset_y = 0; // [1, 3] <br>&emsp;&emsp;&emsp;&emsp;int radius = 1; // [1, 3] <br>&emsp;&emsp;&emsp;&emsp;int active_time_frames = 1; // [1, 15] <br>&emsp;&emsp;&emsp;&emsp;int switch_on_msg_interval_frames = 0; // [0, 60] <br>&emsp;&emsp;&emsp;&emsp;int electrified_msg_interval_frames = -1; // [0, 15] <br>&emsp;&emsp;&emsp;&emsp;int mLastFrameElectrified = -1000;<br>&emsp;&emsp;&emsp;&emsp;int mNextElectrifiedMsgFrame = 0;<br>&emsp;&emsp;&emsp;&emsp;int mNextSwitchOnMsgFrame = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="offset_x" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int offset_x = 0; // [1, 3] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="offset_y" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int offset_y = 0; // [1, 3] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="radius" type="xs:int" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int radius = 1; // [1, 3] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="active_time_frames" type="xs:int" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int active_time_frames = 1; // [1, 15] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="switch_on_msg_interval_frames" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int switch_on_msg_interval_frames = 0; // [0, 60] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="electrified_msg_interval_frames" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int electrified_msg_interval_frames = -1; // [0, 15] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLastFrameElectrified" type="xs:int" default="-1000">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mLastFrameElectrified = -1000;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mNextElectrifiedMsgFrame" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mNextElectrifiedMsgFrame = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mNextSwitchOnMsgFrame" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mNextSwitchOnMsgFrame = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="ElectricitySourceComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ElectricitySourceComponent {<br>&emsp;&emsp;&emsp;&emsp;int radius = 5; // [1, 16] <br>&emsp;&emsp;&emsp;&emsp;int emission_interval_frames = 15; // [1, 10] <br>&emsp;&emsp;&emsp;&emsp;int mNextFrameEmitElectricity = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="radius" type="xs:int" default="5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int radius = 5; // [1, 16] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="emission_interval_frames" type="xs:int" default="15">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int emission_interval_frames = 15; // [1, 10] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mNextFrameEmitElectricity" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mNextFrameEmitElectricity = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="EndingMcGuffinComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class EndingMcGuffinComponent {<br>&emsp;&emsp;&emsp;&emsp;float TEMP_TEMPY = 0; // [0, 3.5] <br>&emsp;&emsp;&emsp;&emsp;float TEMP_TEMP_TEMP = 0; // [0, 3.5] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="TEMP_TEMPY" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float TEMP_TEMPY = 0; // [0, 3.5] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="TEMP_TEMP_TEMP" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float TEMP_TEMP_TEMP = 0; // [0, 3.5] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="EnergyShieldComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class EnergyShieldComponent {<br>&emsp;&emsp;&emsp;&emsp;float radius = 16; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;float damage_multiplier = 1.5; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;float max_energy = 1; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;float energy_required_to_shield = 0.2; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;float recharge_speed = 1; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;float sector_degrees = 360; // [0, 360] if less than 180 we only provide partial cover to the current direction of the entity<br>&emsp;&emsp;&emsp;&emsp;float energy = 0; // [0, 3] <br>&emsp;&emsp;&emsp;&emsp;vec2 mPrevPosition;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="radius" type="xs:decimal" default="16">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float radius = 16; // [0, 100] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_multiplier" type="xs:decimal" default="1.5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float damage_multiplier = 1.5; // [0, 10] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="max_energy" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float max_energy = 1; // [0, 10] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="energy_required_to_shield" type="xs:decimal" default="0.2">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float energy_required_to_shield = 0.2; // [0, 10] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="recharge_speed" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float recharge_speed = 1; // [0, 10] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="sector_degrees" type="xs:decimal" default="360">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float sector_degrees = 360; // [0, 360] if less than 180 we only provide partial cover to the current direction of the entity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="energy" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float energy = 0; // [0, 3] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevPosition.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mPrevPosition;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevPosition.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mPrevPosition;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="ExplodeOnDamageComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ExplodeOnDamageComponent {<br>&emsp;&emsp;&emsp;&emsp;float explode_on_death_percent = 1; //  rolls a dice (0 - 1) if we explode on death<br>&emsp;&emsp;&emsp;&emsp;float explode_on_damage_percent = 1; //  rolls a dice (0 - 1) if we explode on damage<br>&emsp;&emsp;&emsp;&emsp;float physics_body_modified_death_probability = 0; //  if we get message about the physics body being modified, do we explode on what percent<br>&emsp;&emsp;&emsp;&emsp;float physics_body_destruction_required = 0.5; //  how big of percent of our body, do we need to lose before we explode<br>&emsp;&emsp;&emsp;&emsp;ConfigExplosion config_explosion; //  if we have explosion, it's the setup for it<br>&emsp;&emsp;&emsp;&emsp;bool mDone = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
			<xs:all>
				<xs:element name="config_explosion" type="ConfigExplosion" minOccurs="0"/>
			</xs:all>
		<xs:attribute name="explode_on_death_percent" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float explode_on_death_percent = 1; //  rolls a dice (0 - 1) if we explode on death<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="explode_on_damage_percent" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float explode_on_damage_percent = 1; //  rolls a dice (0 - 1) if we explode on damage<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="physics_body_modified_death_probability" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float physics_body_modified_death_probability = 0; //  if we get message about the physics body being modified, do we explode on what percent<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="physics_body_destruction_required" type="xs:decimal" default="0.5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float physics_body_destruction_required = 0.5; //  how big of percent of our body, do we need to lose before we explode<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mDone" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mDone = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="ExplosionComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ExplosionComponent {<br>&emsp;&emsp;&emsp;&emsp;int timeout_frames = 0; // [0, 180] for timer<br>&emsp;&emsp;&emsp;&emsp;int timeout_frames_random = 0; // [0, 180] a random value between 0 and 'timout_frames_random' is added to timer<br>&emsp;&emsp;&emsp;&emsp;bool kill_entity = 1; //  if 1, we kill the entity when exploding<br>&emsp;&emsp;&emsp;&emsp;int mTimerTriggerFrame = -1;<br>&emsp;&emsp;&emsp;&emsp;ConfigExplosion config_explosion; //  setup for out explosion<br>&emsp;&emsp;&emsp;&emsp;EXPLOSION_TRIGGER_TYPE::Enum trigger; //  what triggers the explosion<br>};<br>```]]> </xs:documentation> </xs:annotation>
			<xs:all>
				<xs:element name="config_explosion" type="ConfigExplosion" minOccurs="0"/>
			</xs:all>
		<xs:attribute name="timeout_frames" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int timeout_frames = 0; // [0, 180] for timer<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="timeout_frames_random" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int timeout_frames_random = 0; // [0, 180] a random value between 0 and 'timout_frames_random' is added to timer<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="kill_entity" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool kill_entity = 1; //  if 1, we kill the entity when exploding<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mTimerTriggerFrame" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mTimerTriggerFrame = -1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="trigger" type="EXPLOSION_TRIGGER_TYPE" default="ON_CREATE">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>EXPLOSION_TRIGGER_TYPE::Enum trigger; //  what triggers the explosion<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="FishAIComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class FishAIComponent {<br>&emsp;&emsp;&emsp;&emsp;int direction = 0; // [-1, 1] <br>&emsp;&emsp;&emsp;&emsp;float speed = 100; // [1, 1000] <br>&emsp;&emsp;&emsp;&emsp;vec2 aabb_min;<br>&emsp;&emsp;&emsp;&emsp;vec2 aabb_max;<br>&emsp;&emsp;&emsp;&emsp;vec2 velocity;<br>&emsp;&emsp;&emsp;&emsp;int stuck_counter = 0;<br>&emsp;&emsp;&emsp;&emsp;vec2 mLastCheckPos;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="direction" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int direction = 0; // [-1, 1] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="speed" type="xs:decimal" default="100">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float speed = 100; // [1, 1000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="aabb_min.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 aabb_min;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="aabb_min.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 aabb_min;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="aabb_max.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 aabb_max;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="aabb_max.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 aabb_max;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="velocity.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 velocity;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="velocity.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 velocity;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="stuck_counter" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int stuck_counter = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLastCheckPos.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mLastCheckPos;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLastCheckPos.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mLastCheckPos;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="FlyingComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class FlyingComponent {<br>&emsp;&emsp;&emsp;&emsp;int type = 0; //  type of flight, 1 = perlin noise<br>&emsp;&emsp;&emsp;&emsp;float perlin_freq = 0.2; //  frequency of the perlin noise sampling<br>&emsp;&emsp;&emsp;&emsp;float perlin_time_freq = 0.3; //  t *= perlin_time_freq<br>&emsp;&emsp;&emsp;&emsp;float perlin_wind_x = 0; // [-1, 1] wind velocity that gets added to the samples<br>&emsp;&emsp;&emsp;&emsp;float perlin_wind_y = 0; // [-1, 1] wind velocity that gets added to the samples<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="type" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int type = 0; //  type of flight, 1 = perlin noise<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="perlin_freq" type="xs:decimal" default="0.2">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float perlin_freq = 0.2; //  frequency of the perlin noise sampling<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="perlin_time_freq" type="xs:decimal" default="0.3">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float perlin_time_freq = 0.3; //  t *= perlin_time_freq<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="perlin_wind_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float perlin_wind_x = 0; // [-1, 1] wind velocity that gets added to the samples<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="perlin_wind_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float perlin_wind_y = 0; // [-1, 1] wind velocity that gets added to the samples<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="FogOfWarRadiusComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class FogOfWarRadiusComponent {<br>&emsp;&emsp;&emsp;&emsp;float radius = 256; // [0, 1024] 256 is the default player has<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="radius" type="xs:decimal" default="256">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float radius = 256; // [0, 1024] 256 is the default player has<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="FogOfWarRemoverComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class FogOfWarRemoverComponent {<br>&emsp;&emsp;&emsp;&emsp;float radius = 140; // [0, 2000] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="radius" type="xs:decimal" default="140">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float radius = 140; // [0, 2000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="GameAreaEffectComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class GameAreaEffectComponent {<br>&emsp;&emsp;&emsp;&emsp;float radius = 0; // [0, 3.5] what's the radius (in pixels) of the area effect<br>&emsp;&emsp;&emsp;&emsp;std::string collide_with_tag = "hittable"; //  the tags we're looking for<br>&emsp;&emsp;&emsp;&emsp;int frame_length = -1; //  if not 0 will reapply this effect after this many frames have gone by<br>&emsp;&emsp;&emsp;&emsp;VECTOR_STR game_effect_entitities; //  just a vector of the game_effect entities<br>&emsp;&emsp;&emsp;&emsp;VECTOR_ENTITYID mEntitiesAppliedOutTo;<br>&emsp;&emsp;&emsp;&emsp;VECTOR_INT mEntitiesAppliedFrame;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="radius" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float radius = 0; // [0, 3.5] what's the radius (in pixels) of the area effect<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="collide_with_tag" type="xs:string" default="hittable">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string collide_with_tag = "hittable"; //  the tags we're looking for<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="frame_length" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int frame_length = -1; //  if not 0 will reapply this effect after this many frames have gone by<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: VECTOR_STR for game_effect_entitities -->
		<!-- Some Unknown Type: VECTOR_ENTITYID for mEntitiesAppliedOutTo -->
		<!-- Some Unknown Type: VECTOR_INT for mEntitiesAppliedFrame -->
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="GameEffectComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class GameEffectComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string custom_effect_id; //  if 'effect' is set to 'CUSTOM', this will define effect uniqueness.<br>&emsp;&emsp;&emsp;&emsp;int frames = -1; //  how many frames does it affect -1 = forever<br>&emsp;&emsp;&emsp;&emsp;int exclusivity_group = 0; //  if > 0, previous game effects with the same exclusivity group as new one will be removed when calling LoadGameEffectEntityTo<br>&emsp;&emsp;&emsp;&emsp;bool report_block_msg = 1; //  to disable the block message that rises<br>&emsp;&emsp;&emsp;&emsp;bool disable_movement = 0; //  if set, will disable movement<br>&emsp;&emsp;&emsp;&emsp;std::string ragdoll_effect_custom_entity_file; //  an entity that is loaded to each ragdoll part if 'ragdoll_effect' is set to 'CUSTOM_RAGDOLL_ENTITY'<br>&emsp;&emsp;&emsp;&emsp;bool ragdoll_fx_custom_entity_apply_only_to_largest_body = 0; //  if 1, 'ragdoll_effect_custom_entity_file' is loaded only to the largest piece in the ragdoll <br>&emsp;&emsp;&emsp;&emsp;std::string polymorph_target; //  when doing a polymorph, this is what we convert it to<br>&emsp;&emsp;&emsp;&emsp;USTRING mSerializedData; //  polymorph stores the serialized entity here...<br>&emsp;&emsp;&emsp;&emsp;EntityID mCaster = 0; //  Contains a handle to the caster of this GameEffect<br>&emsp;&emsp;&emsp;&emsp;int mCasterHerdId = 0; //  Contains the herd if of the caster of this GameEffect<br>&emsp;&emsp;&emsp;&emsp;int teleportation_probability = 600; //  How likely is it that we teleport, larger = less often<br>&emsp;&emsp;&emsp;&emsp;int teleportation_delay_min_frames = 30; //  Never teleports more often that this<br>&emsp;&emsp;&emsp;&emsp;float teleportation_radius_min = 128;<br>&emsp;&emsp;&emsp;&emsp;float teleportation_radius_max = 1024;<br>&emsp;&emsp;&emsp;&emsp;int teleportations_num = 0; //  How many times has this GameEffectComponent teleported the owner?<br>&emsp;&emsp;&emsp;&emsp;double no_heal_max_hp_cap = 3.40282e+038; //  If current hp is less than this, we store it here. Then we make sure the hp never exceeds this.<br>&emsp;&emsp;&emsp;&emsp;bool caused_by_ingestion_status_effect = 0; //  Did this effect occur because someone ate something?<br>&emsp;&emsp;&emsp;&emsp;bool caused_by_stains = 0; //  was this caused by stains<br>&emsp;&emsp;&emsp;&emsp;bool mCharmDisabledCameraBound = 0; //  When charmed, will try to disable CameraBound. This keeps track if we've done it, so we can enable it back<br>&emsp;&emsp;&emsp;&emsp;bool mCharmEnabledTeleporting = 0; //  When charmed, will try to enable teleporting (tag:teleportable_NOT). This keeps track if we've done it, so we can disable it again<br>&emsp;&emsp;&emsp;&emsp;bool mInvisible = 0; //  Are we invisible?<br>&emsp;&emsp;&emsp;&emsp;int mCounter = 0; //  Counts stuff<br>&emsp;&emsp;&emsp;&emsp;int mCooldown = 0; //  Counts cooldown<br>&emsp;&emsp;&emsp;&emsp;bool mIsExtension = 0; //  If 1, this is an effect extension and shouldn't create an extension when removed<br>&emsp;&emsp;&emsp;&emsp;bool mIsSpent = 0; //  NOTE( Petri ): 29.4.2024 - this is used internally to make RESPAWN perk disabled in the UI<br>&emsp;&emsp;&emsp;&emsp;GAME_EFFECT::Enum effect; //  GAME_EFFECT<br>&emsp;&emsp;&emsp;&emsp;RAGDOLL_FX::Enum ragdoll_effect; //  if set, will use this for ragdoll effect<br>&emsp;&emsp;&emsp;&emsp;int ragdoll_material = 0; //  converts to string name of the material that ragdoll is made out of<br>&emsp;&emsp;&emsp;&emsp;StatusEffectType causing_status_effect = 0; //  Status effect that caused this game effect, if any<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="custom_effect_id" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string custom_effect_id; //  if 'effect' is set to 'CUSTOM', this will define effect uniqueness.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="frames" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int frames = -1; //  how many frames does it affect -1 = forever<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="exclusivity_group" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int exclusivity_group = 0; //  if > 0, previous game effects with the same exclusivity group as new one will be removed when calling LoadGameEffectEntityTo<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="report_block_msg" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool report_block_msg = 1; //  to disable the block message that rises<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="disable_movement" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool disable_movement = 0; //  if set, will disable movement<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ragdoll_effect_custom_entity_file" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string ragdoll_effect_custom_entity_file; //  an entity that is loaded to each ragdoll part if 'ragdoll_effect' is set to 'CUSTOM_RAGDOLL_ENTITY'<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ragdoll_fx_custom_entity_apply_only_to_largest_body" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool ragdoll_fx_custom_entity_apply_only_to_largest_body = 0; //  if 1, 'ragdoll_effect_custom_entity_file' is loaded only to the largest piece in the ragdoll <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="polymorph_target" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string polymorph_target; //  when doing a polymorph, this is what we convert it to<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: USTRING for mSerializedData -->
		<!-- Some Unknown Type: EntityID for mCaster -->
		<xs:attribute name="mCasterHerdId" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mCasterHerdId = 0; //  Contains the herd if of the caster of this GameEffect<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="teleportation_probability" type="xs:int" default="600">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int teleportation_probability = 600; //  How likely is it that we teleport, larger = less often<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="teleportation_delay_min_frames" type="xs:int" default="30">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int teleportation_delay_min_frames = 30; //  Never teleports more often that this<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="teleportation_radius_min" type="xs:decimal" default="128">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float teleportation_radius_min = 128;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="teleportation_radius_max" type="xs:decimal" default="1024">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float teleportation_radius_max = 1024;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="teleportations_num" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int teleportations_num = 0; //  How many times has this GameEffectComponent teleported the owner?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="no_heal_max_hp_cap" type="xs:decimal" default="340282000000000014192072600942972764160">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>double no_heal_max_hp_cap = 3.40282e+038; //  If current hp is less than this, we store it here. Then we make sure the hp never exceeds this.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="caused_by_ingestion_status_effect" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool caused_by_ingestion_status_effect = 0; //  Did this effect occur because someone ate something?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="caused_by_stains" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool caused_by_stains = 0; //  was this caused by stains<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mCharmDisabledCameraBound" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mCharmDisabledCameraBound = 0; //  When charmed, will try to disable CameraBound. This keeps track if we've done it, so we can enable it back<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mCharmEnabledTeleporting" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mCharmEnabledTeleporting = 0; //  When charmed, will try to enable teleporting (tag:teleportable_NOT). This keeps track if we've done it, so we can disable it again<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mInvisible" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mInvisible = 0; //  Are we invisible?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mCounter" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mCounter = 0; //  Counts stuff<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mCooldown" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mCooldown = 0; //  Counts cooldown<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mIsExtension" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mIsExtension = 0; //  If 1, this is an effect extension and shouldn't create an extension when removed<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mIsSpent" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mIsSpent = 0; //  NOTE( Petri ): 29.4.2024 - this is used internally to make RESPAWN perk disabled in the UI<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="effect" type="GAME_EFFECT" default="ELECTROCUTION">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>GAME_EFFECT::Enum effect; //  GAME_EFFECT<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ragdoll_effect" type="RAGDOLL_FX" default="NONE">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>RAGDOLL_FX::Enum ragdoll_effect; //  if set, will use this for ragdoll effect<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ragdoll_material" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int ragdoll_material = 0; //  converts to string name of the material that ragdoll is made out of<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="causing_status_effect" type="GAME_EFFECT" default="ELECTROCUTION">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>StatusEffectType causing_status_effect = 0; //  Status effect that caused this game effect, if any<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="GameLogComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class GameLogComponent {<br>&emsp;&emsp;&emsp;&emsp;bool report_death = 1; //  switches on reporting things<br>&emsp;&emsp;&emsp;&emsp;bool report_damage = 0; //  if set, will report when receiving damage<br>&emsp;&emsp;&emsp;&emsp;bool report_new_biomes = 1; //  if false, won't report when player enters new biomes<br>&emsp;&emsp;&emsp;&emsp;VISITED_VEC mVisitiedBiomes; //  list of visited biomes<br>&emsp;&emsp;&emsp;&emsp;int mNewBiomeCheckFrame = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="report_death" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool report_death = 1; //  switches on reporting things<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="report_damage" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool report_damage = 0; //  if set, will report when receiving damage<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="report_new_biomes" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool report_new_biomes = 1; //  if false, won't report when player enters new biomes<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: VISITED_VEC for mVisitiedBiomes -->
		<xs:attribute name="mNewBiomeCheckFrame" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mNewBiomeCheckFrame = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="GameStatsComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class GameStatsComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string name; //  no one uses the name variable on entity, so we have to do this to make it happen<br>&emsp;&emsp;&emsp;&emsp;std::string stats_filename; //  also generated from the gunk<br>&emsp;&emsp;&emsp;&emsp;bool is_player = 0; //  if true, will use the session file for loading stats<br>&emsp;&emsp;&emsp;&emsp;std::string extra_death_msg; //  set when e.g. polymorphed<br>&emsp;&emsp;&emsp;&emsp;bool dont_do_logplayerkill = 0; //  if 1, StatsLogPlayerKill must be manually called from lua<br>&emsp;&emsp;&emsp;&emsp;int player_polymorph_count = 0; //  skip loading of stats if this higher than 0 and decrament this by one<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="name" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string name; //  no one uses the name variable on entity, so we have to do this to make it happen<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="stats_filename" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string stats_filename; //  also generated from the gunk<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_player" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_player = 0; //  if true, will use the session file for loading stats<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="extra_death_msg" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string extra_death_msg; //  set when e.g. polymorphed<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="dont_do_logplayerkill" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool dont_do_logplayerkill = 0; //  if 1, StatsLogPlayerKill must be manually called from lua<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="player_polymorph_count" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int player_polymorph_count = 0; //  skip loading of stats if this higher than 0 and decrament this by one<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="GasBubbleComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class GasBubbleComponent {<br>&emsp;&emsp;&emsp;&emsp;float acceleration = -1; // [-100, 0] <br>&emsp;&emsp;&emsp;&emsp;float max_speed = 20; // [0, 20] <br>&emsp;&emsp;&emsp;&emsp;float mVelocity = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="acceleration" type="xs:decimal" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float acceleration = -1; // [-100, 0] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="max_speed" type="xs:decimal" default="20">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float max_speed = 20; // [0, 20] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mVelocity" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mVelocity = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="GenomeDataComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class GenomeDataComponent {<br>&emsp;&emsp;&emsp;&emsp;bool is_predator = 0; //  Predators are considered threats by other species and hunt for food.<br>&emsp;&emsp;&emsp;&emsp;float food_chain_rank = 0; // [0, 200] 0 means king of the hill. Greater number = more likely to get eaten by other species.<br>&emsp;&emsp;&emsp;&emsp;bool berserk_dont_attack_friends = 0; //  if 1, this animal will not try to attack player who would normally be its friend<br>&emsp;&emsp;&emsp;&emsp;LensValue<int> herd_id; //  This is used for example to separate people in different tribes.<br>&emsp;&emsp;&emsp;&emsp;LensValue<bool> friend_thundermage; //  if 1, thunder mage doesn't attack this<br>&emsp;&emsp;&emsp;&emsp;LensValue<bool> friend_firemage; //  if 1, fire mage doesn't attack this<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="is_predator" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_predator = 0; //  Predators are considered threats by other species and hunt for food.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="food_chain_rank" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float food_chain_rank = 0; // [0, 200] 0 means king of the hill. Greater number = more likely to get eaten by other species.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="berserk_dont_attack_friends" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool berserk_dont_attack_friends = 0; //  if 1, this animal will not try to attack player who would normally be its friend<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="herd_id" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>LensValue<int> herd_id; //  This is used for example to separate people in different tribes.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="friend_thundermage" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>LensValue<bool> friend_thundermage; //  if 1, thunder mage doesn't attack this<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="friend_firemage" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>LensValue<bool> friend_firemage; //  if 1, fire mage doesn't attack this<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="GhostComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class GhostComponent {<br>&emsp;&emsp;&emsp;&emsp;float speed = 5; //  pixels per second<br>&emsp;&emsp;&emsp;&emsp;int new_hunt_target_check_every = 0; //  how often do we look for targets<br>&emsp;&emsp;&emsp;&emsp;float hunt_box_radius = 512;<br>&emsp;&emsp;&emsp;&emsp;float aggressiveness = 100; //  if higher than relations then will attack<br>&emsp;&emsp;&emsp;&emsp;float max_distance_from_home = 300; //  how far from home can we go?<br>&emsp;&emsp;&emsp;&emsp;bool die_if_no_home = 1; //  if set to false will die, if it can't find home<br>&emsp;&emsp;&emsp;&emsp;std::string target_tag = "player_unit"; //  if something else (like mortal), will attack the home<br>&emsp;&emsp;&emsp;&emsp;vec2 velocity;<br>&emsp;&emsp;&emsp;&emsp;EntityID mEntityHome = 0; //  where is our home?<br>&emsp;&emsp;&emsp;&emsp;int mFramesWithoutHome = 0;<br>&emsp;&emsp;&emsp;&emsp;vec2 mTargetPosition;<br>&emsp;&emsp;&emsp;&emsp;int mTargetEntityId = 0;<br>&emsp;&emsp;&emsp;&emsp;vec2 mRandomTarget;<br>&emsp;&emsp;&emsp;&emsp;int mNextTargetCheckFrame = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="speed" type="xs:decimal" default="5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float speed = 5; //  pixels per second<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="new_hunt_target_check_every" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int new_hunt_target_check_every = 0; //  how often do we look for targets<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="hunt_box_radius" type="xs:decimal" default="512">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float hunt_box_radius = 512;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="aggressiveness" type="xs:decimal" default="100">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float aggressiveness = 100; //  if higher than relations then will attack<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="max_distance_from_home" type="xs:decimal" default="300">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float max_distance_from_home = 300; //  how far from home can we go?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="die_if_no_home" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool die_if_no_home = 1; //  if set to false will die, if it can't find home<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="target_tag" type="xs:string" default="player_unit">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string target_tag = "player_unit"; //  if something else (like mortal), will attack the home<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="velocity.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 velocity;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="velocity.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 velocity;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: EntityID for mEntityHome -->
		<xs:attribute name="mFramesWithoutHome" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mFramesWithoutHome = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mTargetPosition.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mTargetPosition;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mTargetPosition.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mTargetPosition;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mTargetEntityId" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mTargetEntityId = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mRandomTarget.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mRandomTarget;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mRandomTarget.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mRandomTarget;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mNextTargetCheckFrame" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mNextTargetCheckFrame = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="GodInfoComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class GodInfoComponent {<br>&emsp;&emsp;&emsp;&emsp;float mana_current = 0; // [0, 1000] How much mana the player now has to use<br>&emsp;&emsp;&emsp;&emsp;float mana_max = 500; // [0, 1000] Max size of the mana pool<br>&emsp;&emsp;&emsp;&emsp;float gold = 0; // [0, 1000] How much gold the player has<br>&emsp;&emsp;&emsp;&emsp;Entity* god_entity;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="mana_current" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mana_current = 0; // [0, 1000] How much mana the player now has to use<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mana_max" type="xs:decimal" default="500">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mana_max = 500; // [0, 1000] Max size of the mana pool<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="gold" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float gold = 0; // [0, 1000] How much gold the player has<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: Entity* for god_entity -->
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="GunComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class GunComponent {<br>&emsp;&emsp;&emsp;&emsp;LuaManager* mLuaManager;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<!-- Some Unknown Type: LuaManager* for mLuaManager -->
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="HealthBarComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class HealthBarComponent {<br><br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="HitEffectComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class HitEffectComponent {<br>&emsp;&emsp;&emsp;&emsp;int value = 0; // [0, 100] Usage depends on selected 'effect_hit'<br>&emsp;&emsp;&emsp;&emsp;std::string value_string; //  Usage depends on selected 'effect_hit'<br>&emsp;&emsp;&emsp;&emsp;GAME_EFFECT::Enum condition_effect; //  Hit entity needs to have this 'GAME_EFFECT' for effects to apply. If both 'condition_effect' and 'condition_status' are set, they are combined with AND logic<br>&emsp;&emsp;&emsp;&emsp;StatusEffectType condition_status = 0; //  Hit entity needs to have this 'STATUS_EFFECT' for effects to apply<br>&emsp;&emsp;&emsp;&emsp;HIT_EFFECT::Enum effect_hit; //  What kind of 'HIT_EFFECT' is applied to hit entity if condition is true<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="value" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int value = 0; // [0, 100] Usage depends on selected 'effect_hit'<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="value_string" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string value_string; //  Usage depends on selected 'effect_hit'<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="condition_effect" type="GAME_EFFECT" default="NONE">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>GAME_EFFECT::Enum condition_effect; //  Hit entity needs to have this 'GAME_EFFECT' for effects to apply. If both 'condition_effect' and 'condition_status' are set, they are combined with AND logic<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="condition_status" type="GAME_EFFECT" default="NONE">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>StatusEffectType condition_status = 0; //  Hit entity needs to have this 'STATUS_EFFECT' for effects to apply<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="effect_hit" type="HIT_EFFECT" default="NONE">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>HIT_EFFECT::Enum effect_hit; //  What kind of 'HIT_EFFECT' is applied to hit entity if condition is true<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="HitboxComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class HitboxComponent {<br>&emsp;&emsp;&emsp;&emsp;bool is_player = 0;<br>&emsp;&emsp;&emsp;&emsp;bool is_enemy = 1;<br>&emsp;&emsp;&emsp;&emsp;bool is_item = 0;<br>&emsp;&emsp;&emsp;&emsp;float aabb_min_x = -5; // [-15, 15] <br>&emsp;&emsp;&emsp;&emsp;float aabb_max_x = 5; // [-15, 15] <br>&emsp;&emsp;&emsp;&emsp;float aabb_min_y = -5; // [-15, 15] <br>&emsp;&emsp;&emsp;&emsp;float aabb_max_y = 5; // [-15, 15] <br>&emsp;&emsp;&emsp;&emsp;float damage_multiplier = 1; //  All damage from hits to this hitbox is multiplied with this value before applying it.<br>&emsp;&emsp;&emsp;&emsp;vec2 offset;<br>&emsp;&emsp;&emsp;&emsp;bool dead = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="is_player" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_player = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_enemy" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_enemy = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_item" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_item = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="aabb_min_x" type="xs:decimal" default="-5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float aabb_min_x = -5; // [-15, 15] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="aabb_max_x" type="xs:decimal" default="5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float aabb_max_x = 5; // [-15, 15] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="aabb_min_y" type="xs:decimal" default="-5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float aabb_min_y = -5; // [-15, 15] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="aabb_max_y" type="xs:decimal" default="5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float aabb_max_y = 5; // [-15, 15] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_multiplier" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float damage_multiplier = 1; //  All damage from hits to this hitbox is multiplied with this value before applying it.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="offset.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 offset;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="offset.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 offset;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="dead" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool dead = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="HomingComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class HomingComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string target_tag = "homing_target";<br>&emsp;&emsp;&emsp;&emsp;bool target_who_shot = 0; //  If 1, targets who shot the projectile, ignores 'target_tag'.<br>&emsp;&emsp;&emsp;&emsp;float detect_distance = 150; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;float homing_velocity_multiplier = 0.9; // [-100, 100] <br>&emsp;&emsp;&emsp;&emsp;float homing_targeting_coeff = 160; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;bool just_rotate_towards_target = 0; //  the default accelerates towards a target. If true will only rotate towards the target.<br>&emsp;&emsp;&emsp;&emsp;float max_turn_rate = 0.05; // [0, 6.283] radians. If just_rotate_towards_target then this is the maximum radians it can turn per frame<br>&emsp;&emsp;&emsp;&emsp;EntityID predefined_target = 0; //  If set, we track this entity<br>&emsp;&emsp;&emsp;&emsp;bool look_for_root_entities_only = 0; //  if set, will only look for entities that are _not_ child entities.<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="target_tag" type="xs:string" default="homing_target">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string target_tag = "homing_target";<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="target_who_shot" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool target_who_shot = 0; //  If 1, targets who shot the projectile, ignores 'target_tag'.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="detect_distance" type="xs:decimal" default="150">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float detect_distance = 150; // [0, 1000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="homing_velocity_multiplier" type="xs:decimal" default="0.9">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float homing_velocity_multiplier = 0.9; // [-100, 100] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="homing_targeting_coeff" type="xs:decimal" default="160">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float homing_targeting_coeff = 160; // [0, 1000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="just_rotate_towards_target" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool just_rotate_towards_target = 0; //  the default accelerates towards a target. If true will only rotate towards the target.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="max_turn_rate" type="xs:decimal" default="0.05">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float max_turn_rate = 0.05; // [0, 6.283] radians. If just_rotate_towards_target then this is the maximum radians it can turn per frame<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: EntityID for predefined_target -->
		<xs:attribute name="look_for_root_entities_only" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool look_for_root_entities_only = 0; //  if set, will only look for entities that are _not_ child entities.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="HotspotComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class HotspotComponent {<br>&emsp;&emsp;&emsp;&emsp;bool transform_with_scale = 1;<br>&emsp;&emsp;&emsp;&emsp;std::string sprite_hotspot_name;<br>&emsp;&emsp;&emsp;&emsp;vec2 offset;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="transform_with_scale" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool transform_with_scale = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="sprite_hotspot_name" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string sprite_hotspot_name;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="offset.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 offset;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="offset.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 offset;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="IKLimbAttackerComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class IKLimbAttackerComponent {<br>&emsp;&emsp;&emsp;&emsp;float radius = 54;<br>&emsp;&emsp;&emsp;&emsp;float leg_velocity_coeff = 15;<br>&emsp;&emsp;&emsp;&emsp;float targeting_radius = 120;<br>&emsp;&emsp;&emsp;&emsp;bool targeting_raytrace = 1;<br>&emsp;&emsp;&emsp;&emsp;std::string target_entities_with_tag = "mortal";<br>&emsp;&emsp;&emsp;&emsp;vec2 mTarget;<br>&emsp;&emsp;&emsp;&emsp;EntityID mTargetEntity = 0;<br>&emsp;&emsp;&emsp;&emsp;IKLimbAttackerState mState;<br>&emsp;&emsp;&emsp;&emsp;float mStateTimer = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="radius" type="xs:decimal" default="54">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float radius = 54;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="leg_velocity_coeff" type="xs:decimal" default="15">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float leg_velocity_coeff = 15;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="targeting_radius" type="xs:decimal" default="120">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float targeting_radius = 120;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="targeting_raytrace" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool targeting_raytrace = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="target_entities_with_tag" type="xs:string" default="mortal">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string target_entities_with_tag = "mortal";<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mTarget.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mTarget;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mTarget.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mTarget;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: EntityID for mTargetEntity -->
		<!-- Some Unknown Type: IKLimbAttackerState for mState -->
		<xs:attribute name="mStateTimer" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mStateTimer = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="IKLimbComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class IKLimbComponent {<br>&emsp;&emsp;&emsp;&emsp;float length = 40;<br>&emsp;&emsp;&emsp;&emsp;float thigh_extra_lenght = 2;<br>&emsp;&emsp;&emsp;&emsp;float mJointSideInterpolation = 0;<br>&emsp;&emsp;&emsp;&emsp;vec2 end_position;<br>&emsp;&emsp;&emsp;&emsp;vec2 mJointWorldPos;<br>&emsp;&emsp;&emsp;&emsp;vec2 mEndPrevPos;<br>&emsp;&emsp;&emsp;&emsp;vec2 mPart0PrevPos;<br>&emsp;&emsp;&emsp;&emsp;float mPart0PrevRotation = 0;<br>&emsp;&emsp;&emsp;&emsp;vec2 mPart1PrevPos;<br>&emsp;&emsp;&emsp;&emsp;float mPart1PrevRotation = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="length" type="xs:decimal" default="40">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float length = 40;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="thigh_extra_lenght" type="xs:decimal" default="2">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float thigh_extra_lenght = 2;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mJointSideInterpolation" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mJointSideInterpolation = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="end_position.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 end_position;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="end_position.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 end_position;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mJointWorldPos.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mJointWorldPos;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mJointWorldPos.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mJointWorldPos;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mEndPrevPos.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mEndPrevPos;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mEndPrevPos.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mEndPrevPos;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPart0PrevPos.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mPart0PrevPos;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPart0PrevPos.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mPart0PrevPos;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPart0PrevRotation" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mPart0PrevRotation = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPart1PrevPos.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mPart1PrevPos;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPart1PrevPos.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mPart1PrevPos;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPart1PrevRotation" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mPart1PrevRotation = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="IKLimbWalkerComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class IKLimbWalkerComponent {<br>&emsp;&emsp;&emsp;&emsp;float ground_attachment_min_spread = 16;<br>&emsp;&emsp;&emsp;&emsp;int ground_attachment_max_tries = 10;<br>&emsp;&emsp;&emsp;&emsp;float ground_attachment_max_angle = 0.8;<br>&emsp;&emsp;&emsp;&emsp;float ground_attachment_ray_length_coeff = 1.15;<br>&emsp;&emsp;&emsp;&emsp;float leg_velocity_coeff = 15;<br>&emsp;&emsp;&emsp;&emsp;bool affect_flying = 0; //  if set, will cause the mFlyingTime (in CharacterDataComponent) of the parent to be 0 or 1 depending on if we're touching anything<br>&emsp;&emsp;&emsp;&emsp;int mState = 0; //  0 = detached, 1 = attached<br>&emsp;&emsp;&emsp;&emsp;int ray_skip_material = 0; //  String name of material to not cast rays against. Defaults to 'aluminium'<br>&emsp;&emsp;&emsp;&emsp;vec2 mTarget;<br>&emsp;&emsp;&emsp;&emsp;vec2 mPrevTarget;<br>&emsp;&emsp;&emsp;&emsp;vec2 mPrevCenterPosition;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="ground_attachment_min_spread" type="xs:decimal" default="16">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float ground_attachment_min_spread = 16;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ground_attachment_max_tries" type="xs:int" default="10">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int ground_attachment_max_tries = 10;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ground_attachment_max_angle" type="xs:decimal" default="0.8">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float ground_attachment_max_angle = 0.8;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ground_attachment_ray_length_coeff" type="xs:decimal" default="1.15">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float ground_attachment_ray_length_coeff = 1.15;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="leg_velocity_coeff" type="xs:decimal" default="15">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float leg_velocity_coeff = 15;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="affect_flying" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool affect_flying = 0; //  if set, will cause the mFlyingTime (in CharacterDataComponent) of the parent to be 0 or 1 depending on if we're touching anything<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mState" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mState = 0; //  0 = detached, 1 = attached<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ray_skip_material" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int ray_skip_material = 0; //  String name of material to not cast rays against. Defaults to 'aluminium'<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mTarget.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mTarget;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mTarget.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mTarget;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevTarget.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mPrevTarget;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevTarget.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mPrevTarget;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevCenterPosition.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mPrevCenterPosition;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevCenterPosition.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mPrevCenterPosition;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="IKLimbsAnimatorComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class IKLimbsAnimatorComponent {<br>&emsp;&emsp;&emsp;&emsp;int future_state_samples = 10; //  The number of future animation states evaluated to find the next state<br>&emsp;&emsp;&emsp;&emsp;float ground_attachment_ray_length_coeff = 1.15; //  Limb raycast length is (ground_attachment_ray_length_coeff * limb length)<br>&emsp;&emsp;&emsp;&emsp;float leg_velocity_coeff = 15; //  Limbs are moved towards target position at a pace affected by this value.<br>&emsp;&emsp;&emsp;&emsp;bool affect_flying = 0; //  If set, will cause the mFlyingTime (in CharacterDataComponent) of the entity to be 0 or 1 depending on if the limbs are touching ground<br>&emsp;&emsp;&emsp;&emsp;float large_movement_penalty_coeff = 0.25; //  The movement score is multiplied by this value if a large move would occur<br>&emsp;&emsp;&emsp;&emsp;float no_ground_attachment_penalty_coeff = 0.75; //  If a limb movement would make it not collide with ground, the movement score is multiplied with this value. Use lower values to make the limbs prioritize attaching to walls.<br>&emsp;&emsp;&emsp;&emsp;bool is_limp = 0; //  If 1, will apply verlet animation to simulate ragdoll-like limbs<br>&emsp;&emsp;&emsp;&emsp;int ray_skip_material = 0; //  String name of material to not cast rays against. Defaults to 'aluminium'<br>&emsp;&emsp;&emsp;&emsp;vec2 mPrevBodyPosition;<br>&emsp;&emsp;&emsp;&emsp;IKLimbStateVec mLimbStates;<br>&emsp;&emsp;&emsp;&emsp;bool mHasGroundAttachmentOnAnyLeg = 0; //  Will be set to true if at least one leg is attached to ground.<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="future_state_samples" type="xs:int" default="10">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int future_state_samples = 10; //  The number of future animation states evaluated to find the next state<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ground_attachment_ray_length_coeff" type="xs:decimal" default="1.15">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float ground_attachment_ray_length_coeff = 1.15; //  Limb raycast length is (ground_attachment_ray_length_coeff * limb length)<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="leg_velocity_coeff" type="xs:decimal" default="15">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float leg_velocity_coeff = 15; //  Limbs are moved towards target position at a pace affected by this value.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="affect_flying" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool affect_flying = 0; //  If set, will cause the mFlyingTime (in CharacterDataComponent) of the entity to be 0 or 1 depending on if the limbs are touching ground<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="large_movement_penalty_coeff" type="xs:decimal" default="0.25">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float large_movement_penalty_coeff = 0.25; //  The movement score is multiplied by this value if a large move would occur<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="no_ground_attachment_penalty_coeff" type="xs:decimal" default="0.75">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float no_ground_attachment_penalty_coeff = 0.75; //  If a limb movement would make it not collide with ground, the movement score is multiplied with this value. Use lower values to make the limbs prioritize attaching to walls.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_limp" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_limp = 0; //  If 1, will apply verlet animation to simulate ragdoll-like limbs<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ray_skip_material" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int ray_skip_material = 0; //  String name of material to not cast rays against. Defaults to 'aluminium'<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevBodyPosition.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mPrevBodyPosition;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevBodyPosition.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mPrevBodyPosition;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: IKLimbStateVec for mLimbStates -->
		<xs:attribute name="mHasGroundAttachmentOnAnyLeg" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mHasGroundAttachmentOnAnyLeg = 0; //  Will be set to true if at least one leg is attached to ground.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="IngestionComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class IngestionComponent {<br>&emsp;&emsp;&emsp;&emsp;int64 ingestion_size = 0; //  How many units of material we currently store<br>&emsp;&emsp;&emsp;&emsp;int64 ingestion_capacity = 7500; //  How many units of material we can store<br>&emsp;&emsp;&emsp;&emsp;uint32 ingestion_cooldown_delay_frames = 600; //  How many frames is ingestion_size retained after last time eating?<br>&emsp;&emsp;&emsp;&emsp;uint32 ingestion_reduce_every_n_frame = 5; //  One unit of ingestion_size is removed every N frame<br>&emsp;&emsp;&emsp;&emsp;float overingestion_damage = 0.002; //  How much damage per overingested cell is applied<br>&emsp;&emsp;&emsp;&emsp;float blood_healing_speed = 0.0008; // [0, 1000] affects healing speed if entity has HEALING_BLOOD game effect. The amount of hp restored per one blood cell.<br>&emsp;&emsp;&emsp;&emsp;std::string ingestion_satiation_material_tag; //  If set, only materials with this tag will increase satiation level<br>&emsp;&emsp;&emsp;&emsp;int32 m_ingestion_cooldown_frames = 0; //  Next frame ingestion_size cooldown can occur<br>&emsp;&emsp;&emsp;&emsp;int32 m_next_overeating_msg_frame = 0;<br>&emsp;&emsp;&emsp;&emsp;std::string m_ingestion_satiation_material_tag_cached;<br>&emsp;&emsp;&emsp;&emsp;std::set<int32> m_ingestion_satiation_material_cache;<br>&emsp;&emsp;&emsp;&emsp;int32 m_damage_effect_lifetime = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="ingestion_size" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int64 ingestion_size = 0; //  How many units of material we currently store<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ingestion_capacity" type="xs:int" default="7500">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int64 ingestion_capacity = 7500; //  How many units of material we can store<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ingestion_cooldown_delay_frames" type="xs:unsignedInt" default="600">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint32 ingestion_cooldown_delay_frames = 600; //  How many frames is ingestion_size retained after last time eating?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ingestion_reduce_every_n_frame" type="xs:unsignedInt" default="5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint32 ingestion_reduce_every_n_frame = 5; //  One unit of ingestion_size is removed every N frame<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="overingestion_damage" type="xs:decimal" default="0.002">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float overingestion_damage = 0.002; //  How much damage per overingested cell is applied<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="blood_healing_speed" type="xs:decimal" default="0.0008">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float blood_healing_speed = 0.0008; // [0, 1000] affects healing speed if entity has HEALING_BLOOD game effect. The amount of hp restored per one blood cell.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ingestion_satiation_material_tag" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string ingestion_satiation_material_tag; //  If set, only materials with this tag will increase satiation level<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="m_ingestion_cooldown_frames" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int32 m_ingestion_cooldown_frames = 0; //  Next frame ingestion_size cooldown can occur<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="m_next_overeating_msg_frame" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int32 m_next_overeating_msg_frame = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="m_ingestion_satiation_material_tag_cached" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string m_ingestion_satiation_material_tag_cached;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: std::set<int32> for m_ingestion_satiation_material_cache -->
		<xs:attribute name="m_damage_effect_lifetime" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int32 m_damage_effect_lifetime = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="InheritTransformComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class InheritTransformComponent {<br>&emsp;&emsp;&emsp;&emsp;bool use_root_parent = 0; //  if 1, we use the root of our entity hierarchy instead of the immediate parent<br>&emsp;&emsp;&emsp;&emsp;bool only_position = 0; //  if 1, we only inherit position. it is calculated as follows: parent_position + parent_offset * parent_scale<br>&emsp;&emsp;&emsp;&emsp;std::string parent_hotspot_tag; //  if set, we apply the offset of parent HotSpot with this tag<br>&emsp;&emsp;&emsp;&emsp;int parent_sprite_id = -1; //  if >= 0, the Nth sprite transform in parent entity is inherited<br>&emsp;&emsp;&emsp;&emsp;bool always_use_immediate_parent_rotation = 0; //  if 1, we use the immediate parent for rotation, no matter what other properties say<br>&emsp;&emsp;&emsp;&emsp;bool rotate_based_on_x_scale = 0; //  if 1, the rotation is set to 0 deg if scale >= 0 else to 180 deg<br>&emsp;&emsp;&emsp;&emsp;types::xform Transform;<br>&emsp;&emsp;&emsp;&emsp;int mUpdateFrame = -1;<br>};<br>```]]> </xs:documentation> </xs:annotation>
			<xs:all>
				<xs:element name="Transform" type="Transform" minOccurs="0"/>
			</xs:all>
		<xs:attribute name="use_root_parent" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool use_root_parent = 0; //  if 1, we use the root of our entity hierarchy instead of the immediate parent<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="only_position" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool only_position = 0; //  if 1, we only inherit position. it is calculated as follows: parent_position + parent_offset * parent_scale<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="parent_hotspot_tag" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string parent_hotspot_tag; //  if set, we apply the offset of parent HotSpot with this tag<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="parent_sprite_id" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int parent_sprite_id = -1; //  if >= 0, the Nth sprite transform in parent entity is inherited<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="always_use_immediate_parent_rotation" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool always_use_immediate_parent_rotation = 0; //  if 1, we use the immediate parent for rotation, no matter what other properties say<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="rotate_based_on_x_scale" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool rotate_based_on_x_scale = 0; //  if 1, the rotation is set to 0 deg if scale >= 0 else to 180 deg<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mUpdateFrame" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mUpdateFrame = -1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="InteractableComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class InteractableComponent {<br>&emsp;&emsp;&emsp;&emsp;float radius = 10; //  Distance from entity position where interaction is possible<br>&emsp;&emsp;&emsp;&emsp;std::string ui_text; //  key or string for the text to display<br>&emsp;&emsp;&emsp;&emsp;std::string name; //  this name is called to the on_interacted function on LuaComponents<br>&emsp;&emsp;&emsp;&emsp;int exclusivity_group = 0; //  If > 0, only 1 instance of this interaction can be display at the same time<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="radius" type="xs:decimal" default="10">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float radius = 10; //  Distance from entity position where interaction is possible<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ui_text" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string ui_text; //  key or string for the text to display<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="name" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string name; //  this name is called to the on_interacted function on LuaComponents<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="exclusivity_group" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int exclusivity_group = 0; //  If > 0, only 1 instance of this interaction can be display at the same time<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="Inventory2Component" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class Inventory2Component {<br>&emsp;&emsp;&emsp;&emsp;int quick_inventory_slots = 10; // [0, 30] <br>&emsp;&emsp;&emsp;&emsp;int full_inventory_slots_x = 8; // [0, 30] <br>&emsp;&emsp;&emsp;&emsp;int full_inventory_slots_y = 8; // [0, 30] <br>&emsp;&emsp;&emsp;&emsp;uint32 mSavedActiveItemIndex = 0; //  Used to retain active item across save/load. Don't touch this unless you know what you're doing!<br>&emsp;&emsp;&emsp;&emsp;EntityID mActiveItem = 0; //  NOTE: Don't attempt to directly change the value of this field via lua code. It will probably break the game logic in obvious or subtle ways.<br>&emsp;&emsp;&emsp;&emsp;EntityID mActualActiveItem = 0; //  NOTE: Don't attempt to directly change the value of this field via lua code. It will probably break the game logic in obvious or subtle ways.<br>&emsp;&emsp;&emsp;&emsp;EntityID mActiveStash = 0;<br>&emsp;&emsp;&emsp;&emsp;EntityID mThrowItem = 0; //  Is used to store the item that is being thrown, instead of mActiveItem, since the player can switch items (mActiveItem) during the throwing animation<br>&emsp;&emsp;&emsp;&emsp;bool mItemHolstered = 0;<br>&emsp;&emsp;&emsp;&emsp;bool mInitialized = 0;<br>&emsp;&emsp;&emsp;&emsp;bool mForceRefresh = 0;<br>&emsp;&emsp;&emsp;&emsp;bool mDontLogNextItemEquip = 0;<br>&emsp;&emsp;&emsp;&emsp;float mSmoothedItemXOffset = 0;<br>&emsp;&emsp;&emsp;&emsp;int mLastItemSwitchFrame = 0;<br>&emsp;&emsp;&emsp;&emsp;float mIntroEquipItemLerp = 1;<br>&emsp;&emsp;&emsp;&emsp;vec2 mSmoothedItemAngleVec;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="quick_inventory_slots" type="xs:int" default="10">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int quick_inventory_slots = 10; // [0, 30] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="full_inventory_slots_x" type="xs:int" default="8">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int full_inventory_slots_x = 8; // [0, 30] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="full_inventory_slots_y" type="xs:int" default="8">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int full_inventory_slots_y = 8; // [0, 30] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mSavedActiveItemIndex" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint32 mSavedActiveItemIndex = 0; //  Used to retain active item across save/load. Don't touch this unless you know what you're doing!<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: EntityID for mActiveItem -->
		<!-- Some Unknown Type: EntityID for mActualActiveItem -->
		<!-- Some Unknown Type: EntityID for mActiveStash -->
		<!-- Some Unknown Type: EntityID for mThrowItem -->
		<xs:attribute name="mItemHolstered" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mItemHolstered = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mInitialized" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mInitialized = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mForceRefresh" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mForceRefresh = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mDontLogNextItemEquip" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mDontLogNextItemEquip = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mSmoothedItemXOffset" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mSmoothedItemXOffset = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLastItemSwitchFrame" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mLastItemSwitchFrame = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mIntroEquipItemLerp" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mIntroEquipItemLerp = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mSmoothedItemAngleVec.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mSmoothedItemAngleVec;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mSmoothedItemAngleVec.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mSmoothedItemAngleVec;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="InventoryComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class InventoryComponent {<br>&emsp;&emsp;&emsp;&emsp;int ui_container_type = 1; //  UI_CONTAINER_TYPES enum<br>&emsp;&emsp;&emsp;&emsp;std::string ui_element_sprite = "data/ui_gfx/inventory/inventory_box.png"; //  ui back sprite<br>&emsp;&emsp;&emsp;&emsp;std::string actions; //  list of actions, used for serialization<br>&emsp;&emsp;&emsp;&emsp;ivec2 ui_container_size; //  ui size, how many items x*y we can fit in<br>&emsp;&emsp;&emsp;&emsp;ivec2 ui_element_size; //  ui size<br>&emsp;&emsp;&emsp;&emsp;ivec2 ui_position_on_screen; //  where do we load this on screen<br>&emsp;&emsp;&emsp;&emsp;InvenentoryUpdateListener* update_listener; //  listener to keep ui up with ability changes<br>&emsp;&emsp;&emsp;&emsp;INVENTORYITEM_VECTOR items;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="ui_container_type" type="xs:int" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int ui_container_type = 1; //  UI_CONTAINER_TYPES enum<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ui_element_sprite" type="xs:string" default="data/ui_gfx/inventory/inventory_box.png">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string ui_element_sprite = "data/ui_gfx/inventory/inventory_box.png"; //  ui back sprite<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="actions" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string actions; //  list of actions, used for serialization<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ui_container_size.x" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 ui_container_size; //  ui size, how many items x*y we can fit in<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ui_container_size.y" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 ui_container_size; //  ui size, how many items x*y we can fit in<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ui_element_size.x" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 ui_element_size; //  ui size<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ui_element_size.y" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 ui_element_size; //  ui size<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ui_position_on_screen.x" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 ui_position_on_screen; //  where do we load this on screen<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ui_position_on_screen.y" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 ui_position_on_screen; //  where do we load this on screen<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: InvenentoryUpdateListener* for update_listener -->
		<!-- Some Unknown Type: INVENTORYITEM_VECTOR for items -->
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="InventoryGuiComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class InventoryGuiComponent {<br>&emsp;&emsp;&emsp;&emsp;bool has_opened_inventory_edit = 0;<br>&emsp;&emsp;&emsp;&emsp;int wallet_money_target = 0;<br>&emsp;&emsp;&emsp;&emsp;bool mDisplayFireRateWaitBar = 0; //  hax, don't touch!<br>&emsp;&emsp;&emsp;&emsp;ImGuiContext* imgui;<br>&emsp;&emsp;&emsp;&emsp;int mLastFrameInteracted = -100;<br>&emsp;&emsp;&emsp;&emsp;int mLastFrameActionsVisible = -1;<br>&emsp;&emsp;&emsp;&emsp;Entity* mLastPurchasedAction;<br>&emsp;&emsp;&emsp;&emsp;bool mActive = 0;<br>&emsp;&emsp;&emsp;&emsp;float mAlpha = 1;<br>&emsp;&emsp;&emsp;&emsp;float mBackgroundOverlayAlpha = 0;<br>&emsp;&emsp;&emsp;&emsp;int mFrameShake_ReloadBar = 0; //  for animations of shaking them bars<br>&emsp;&emsp;&emsp;&emsp;int mFrameShake_ManaBar = 0; //  for animations of shaking them bars<br>&emsp;&emsp;&emsp;&emsp;int mFrameShake_FlyBar = 0; //  for animations of shaking them bars<br>&emsp;&emsp;&emsp;&emsp;int mFrameShake_FireRateWaitBar = 0; //  for animations of shaking them bars<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="has_opened_inventory_edit" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool has_opened_inventory_edit = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="wallet_money_target" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int wallet_money_target = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mDisplayFireRateWaitBar" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mDisplayFireRateWaitBar = 0; //  hax, don't touch!<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: ImGuiContext* for imgui -->
		<xs:attribute name="mLastFrameInteracted" type="xs:int" default="-100">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mLastFrameInteracted = -100;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLastFrameActionsVisible" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mLastFrameActionsVisible = -1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: Entity* for mLastPurchasedAction -->
		<xs:attribute name="mActive" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mActive = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mAlpha" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mAlpha = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mBackgroundOverlayAlpha" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mBackgroundOverlayAlpha = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mFrameShake_ReloadBar" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mFrameShake_ReloadBar = 0; //  for animations of shaking them bars<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mFrameShake_ManaBar" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mFrameShake_ManaBar = 0; //  for animations of shaking them bars<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mFrameShake_FlyBar" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mFrameShake_FlyBar = 0; //  for animations of shaking them bars<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mFrameShake_FireRateWaitBar" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mFrameShake_FireRateWaitBar = 0; //  for animations of shaking them bars<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="ItemAIKnowledgeComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ItemAIKnowledgeComponent {<br>&emsp;&emsp;&emsp;&emsp;bool is_ranged_weapon = 0;<br>&emsp;&emsp;&emsp;&emsp;bool is_throwable_weapon = 0;<br>&emsp;&emsp;&emsp;&emsp;bool is_melee_weapon = 0;<br>&emsp;&emsp;&emsp;&emsp;bool is_self_healing = 0;<br>&emsp;&emsp;&emsp;&emsp;bool is_other_healing = 0;<br>&emsp;&emsp;&emsp;&emsp;bool is_self_buffing = 0;<br>&emsp;&emsp;&emsp;&emsp;bool is_other_buffing = 0;<br>&emsp;&emsp;&emsp;&emsp;bool is_weapon = 0;<br>&emsp;&emsp;&emsp;&emsp;bool is_known = 0;<br>&emsp;&emsp;&emsp;&emsp;bool is_safe = 1;<br>&emsp;&emsp;&emsp;&emsp;bool is_consumed = 0;<br>&emsp;&emsp;&emsp;&emsp;bool never_use = 0;<br>&emsp;&emsp;&emsp;&emsp;float ranged_min_distance = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="is_ranged_weapon" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_ranged_weapon = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_throwable_weapon" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_throwable_weapon = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_melee_weapon" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_melee_weapon = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_self_healing" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_self_healing = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_other_healing" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_other_healing = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_self_buffing" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_self_buffing = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_other_buffing" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_other_buffing = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_weapon" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_weapon = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_known" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_known = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_safe" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_safe = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_consumed" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_consumed = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="never_use" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool never_use = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ranged_min_distance" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float ranged_min_distance = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="ItemActionComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ItemActionComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string action_id; //  the name ID of the action<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="action_id" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string action_id; //  the name ID of the action<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="ItemAlchemyComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ItemAlchemyComponent {<br>&emsp;&emsp;&emsp;&emsp;int material_make_always_cast = 0;<br>&emsp;&emsp;&emsp;&emsp;int material_remove_shuffle = 0;<br>&emsp;&emsp;&emsp;&emsp;int material_animate_wand = 0;<br>&emsp;&emsp;&emsp;&emsp;int material_animate_wand_alt = 0;<br>&emsp;&emsp;&emsp;&emsp;int material_increase_uses_remaining = 0;<br>&emsp;&emsp;&emsp;&emsp;int material_sacrifice = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="material_make_always_cast" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int material_make_always_cast = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="material_remove_shuffle" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int material_remove_shuffle = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="material_animate_wand" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int material_animate_wand = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="material_animate_wand_alt" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int material_animate_wand_alt = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="material_increase_uses_remaining" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int material_increase_uses_remaining = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="material_sacrifice" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int material_sacrifice = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="ItemChestComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ItemChestComponent {<br>&emsp;&emsp;&emsp;&emsp;int item_count_min = 0; // [0, 1e+006] <br>&emsp;&emsp;&emsp;&emsp;int item_count_max = 0; // [0, 1e+006] <br>&emsp;&emsp;&emsp;&emsp;int level = 0; // [0, 1e+006] <br>&emsp;&emsp;&emsp;&emsp;bool enemy_drop = 0; //  enemy_drop, if set will modify the item_count_min, item_count_max...<br>&emsp;&emsp;&emsp;&emsp;std::string actions; //  e.g. 'bullet,bullet,damage' ... actions are parsed into a string<br>&emsp;&emsp;&emsp;&emsp;std::string action_uses_remaining; //  e.g. '10,10,-1' ... action uses remaining counts are parsed into a string<br>&emsp;&emsp;&emsp;&emsp;std::string other_entities_to_spawn; //  file names of other entities we should spawn from this chest, comma separated<br>&emsp;&emsp;&emsp;&emsp;unsigned int mSeed = 0; //  this is used to figure out what we spawn from this chest<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="item_count_min" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int item_count_min = 0; // [0, 1e+006] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="item_count_max" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int item_count_max = 0; // [0, 1e+006] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="level" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int level = 0; // [0, 1e+006] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="enemy_drop" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool enemy_drop = 0; //  enemy_drop, if set will modify the item_count_min, item_count_max...<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="actions" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string actions; //  e.g. 'bullet,bullet,damage' ... actions are parsed into a string<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="action_uses_remaining" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string action_uses_remaining; //  e.g. '10,10,-1' ... action uses remaining counts are parsed into a string<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="other_entities_to_spawn" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string other_entities_to_spawn; //  file names of other entities we should spawn from this chest, comma separated<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mSeed" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>unsigned int mSeed = 0; //  this is used to figure out what we spawn from this chest<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="ItemComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ItemComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string item_name; //  the name of the item<br>&emsp;&emsp;&emsp;&emsp;bool is_stackable = 0; //  does this item stack on other items the same 'item_name' in the inventory?<br>&emsp;&emsp;&emsp;&emsp;bool is_consumable = 0; //  if 1, using this item will reduce 'uses_remaining'. When it reaches zero the item is destroyed<br>&emsp;&emsp;&emsp;&emsp;bool stats_count_as_item_pick_up = 1; //  does this count as an item that was picked up in the stats<br>&emsp;&emsp;&emsp;&emsp;bool auto_pickup = 0; //  if 1, item will be automatically picked up, no pickup hint is shown<br>&emsp;&emsp;&emsp;&emsp;bool permanently_attached = 0; //  if 1, this item can't be removed from a container once it is put inside one<br>&emsp;&emsp;&emsp;&emsp;int uses_remaining = -1; //  how many times can this item be used? -1 = unlimited, will be reset to gun_actions.lua max_uses by inventorygui_system, -2 = unlimited unlimited<br>&emsp;&emsp;&emsp;&emsp;bool is_identified = 1; //  is it known what this item does?<br>&emsp;&emsp;&emsp;&emsp;bool is_frozen = 0; //  if 1, this item can't be modified or moved from a wand<br>&emsp;&emsp;&emsp;&emsp;bool collect_nondefault_actions = 0; //  does player keep this item when respawning?<br>&emsp;&emsp;&emsp;&emsp;bool remove_on_death = 0; //  is this entity destroyed when it's in an inventory and the inventory owner dies?<br>&emsp;&emsp;&emsp;&emsp;bool remove_on_death_if_empty = 0; //  is this entity destroyed when it's in an inventory, empty and the inventory owner dies?<br>&emsp;&emsp;&emsp;&emsp;bool remove_default_child_actions_on_death = 0; //  if true, the default AbilityComponent.child_actions in this items will be removed when it dies<br>&emsp;&emsp;&emsp;&emsp;bool play_hover_animation = 0; //  if 1, the item will play a hovering animation<br>&emsp;&emsp;&emsp;&emsp;bool play_spinning_animation = 1; //  if 1, the item will play a spinning animation, if player_hover_animation is 0<br>&emsp;&emsp;&emsp;&emsp;bool is_equipable_forced = 0; //  if 1, the default logic for determining if an item can be equiped in inventory is overridden and this can be always equipped<br>&emsp;&emsp;&emsp;&emsp;bool play_pick_sound = 1; //  if 1, plays a default sound when picked<br>&emsp;&emsp;&emsp;&emsp;bool drinkable = 1; //  if 0 you cannot drink this, default is 1, because that's how it was implemented and backwards compatibility<br>&emsp;&emsp;&emsp;&emsp;int max_child_items = 0; //  number of items this can hold inside itself. TODO: get rid of all uses of 'ability->gun_config.deck_capacity' and replace them with this!<br>&emsp;&emsp;&emsp;&emsp;std::string ui_sprite; //  sprite displayed for the item in various UIs. If not empty overrides sprites declared by Ability and ItemAction<br>&emsp;&emsp;&emsp;&emsp;std::string ui_description; //  item description displayed in various UIs<br>&emsp;&emsp;&emsp;&emsp;bool enable_orb_hacks = 0;<br>&emsp;&emsp;&emsp;&emsp;bool is_all_spells_book = 0;<br>&emsp;&emsp;&emsp;&emsp;bool always_use_item_name_in_ui = 0;<br>&emsp;&emsp;&emsp;&emsp;std::string custom_pickup_string; //  if set, this is used for the 'Press $0 to pick $1' message<br>&emsp;&emsp;&emsp;&emsp;bool ui_display_description_on_pick_up_hint = 0;<br>&emsp;&emsp;&emsp;&emsp;int next_frame_pickable = 0;<br>&emsp;&emsp;&emsp;&emsp;int npc_next_frame_pickable = 0; //  NPC have their own next_frame_pickable, because this is used to make NPCs not pick up gold, which also meant player couldn't pick up that gold<br>&emsp;&emsp;&emsp;&emsp;bool is_pickable = 1; //  can this be picked up and placed on someone's inventory<br>&emsp;&emsp;&emsp;&emsp;bool is_hittable_always = 0; //  to override the weirdness that is is_pickable, which affects if this is hittable or not. If true, will always be hittable regardless of is_pickable<br>&emsp;&emsp;&emsp;&emsp;float item_pickup_radius = 14.1; //  how many pixels away can this item be picked up from<br>&emsp;&emsp;&emsp;&emsp;float camera_max_distance = 50; //  how far can we move the camera from the player when this item is equipped<br>&emsp;&emsp;&emsp;&emsp;float camera_smooth_speed_multiplier = 1; //  how quickly does the camera follow player?<br>&emsp;&emsp;&emsp;&emsp;bool has_been_picked_by_player = 0;<br>&emsp;&emsp;&emsp;&emsp;int mFramePickedUp = 0;<br>&emsp;&emsp;&emsp;&emsp;vec2 spawn_pos; //  the position where this item spawned<br>&emsp;&emsp;&emsp;&emsp;INVENTORY_KIND::Enum preferred_inventory; //  Which inventory do we go to when we're picked up, if it's not full.<br>&emsp;&emsp;&emsp;&emsp;ivec2 inventory_slot; //  our preferred slot (x,y) in the inventory<br>&emsp;&emsp;&emsp;&emsp;int mItemUid = 0;<br>&emsp;&emsp;&emsp;&emsp;bool mIsIdentified = 1;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="item_name" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string item_name; //  the name of the item<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_stackable" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_stackable = 0; //  does this item stack on other items the same 'item_name' in the inventory?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_consumable" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_consumable = 0; //  if 1, using this item will reduce 'uses_remaining'. When it reaches zero the item is destroyed<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="stats_count_as_item_pick_up" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool stats_count_as_item_pick_up = 1; //  does this count as an item that was picked up in the stats<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="auto_pickup" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool auto_pickup = 0; //  if 1, item will be automatically picked up, no pickup hint is shown<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="permanently_attached" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool permanently_attached = 0; //  if 1, this item can't be removed from a container once it is put inside one<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="uses_remaining" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int uses_remaining = -1; //  how many times can this item be used? -1 = unlimited, will be reset to gun_actions.lua max_uses by inventorygui_system, -2 = unlimited unlimited<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_identified" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_identified = 1; //  is it known what this item does?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_frozen" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_frozen = 0; //  if 1, this item can't be modified or moved from a wand<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="collect_nondefault_actions" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool collect_nondefault_actions = 0; //  does player keep this item when respawning?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="remove_on_death" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool remove_on_death = 0; //  is this entity destroyed when it's in an inventory and the inventory owner dies?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="remove_on_death_if_empty" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool remove_on_death_if_empty = 0; //  is this entity destroyed when it's in an inventory, empty and the inventory owner dies?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="remove_default_child_actions_on_death" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool remove_default_child_actions_on_death = 0; //  if true, the default AbilityComponent.child_actions in this items will be removed when it dies<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="play_hover_animation" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool play_hover_animation = 0; //  if 1, the item will play a hovering animation<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="play_spinning_animation" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool play_spinning_animation = 1; //  if 1, the item will play a spinning animation, if player_hover_animation is 0<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_equipable_forced" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_equipable_forced = 0; //  if 1, the default logic for determining if an item can be equiped in inventory is overridden and this can be always equipped<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="play_pick_sound" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool play_pick_sound = 1; //  if 1, plays a default sound when picked<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="drinkable" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool drinkable = 1; //  if 0 you cannot drink this, default is 1, because that's how it was implemented and backwards compatibility<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="max_child_items" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int max_child_items = 0; //  number of items this can hold inside itself. TODO: get rid of all uses of 'ability->gun_config.deck_capacity' and replace them with this!<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ui_sprite" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string ui_sprite; //  sprite displayed for the item in various UIs. If not empty overrides sprites declared by Ability and ItemAction<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ui_description" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string ui_description; //  item description displayed in various UIs<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="enable_orb_hacks" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool enable_orb_hacks = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_all_spells_book" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_all_spells_book = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="always_use_item_name_in_ui" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool always_use_item_name_in_ui = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="custom_pickup_string" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string custom_pickup_string; //  if set, this is used for the 'Press $0 to pick $1' message<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ui_display_description_on_pick_up_hint" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool ui_display_description_on_pick_up_hint = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="next_frame_pickable" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int next_frame_pickable = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="npc_next_frame_pickable" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int npc_next_frame_pickable = 0; //  NPC have their own next_frame_pickable, because this is used to make NPCs not pick up gold, which also meant player couldn't pick up that gold<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_pickable" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_pickable = 1; //  can this be picked up and placed on someone's inventory<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_hittable_always" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_hittable_always = 0; //  to override the weirdness that is is_pickable, which affects if this is hittable or not. If true, will always be hittable regardless of is_pickable<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="item_pickup_radius" type="xs:decimal" default="14.1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float item_pickup_radius = 14.1; //  how many pixels away can this item be picked up from<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="camera_max_distance" type="xs:decimal" default="50">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float camera_max_distance = 50; //  how far can we move the camera from the player when this item is equipped<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="camera_smooth_speed_multiplier" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float camera_smooth_speed_multiplier = 1; //  how quickly does the camera follow player?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="has_been_picked_by_player" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool has_been_picked_by_player = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mFramePickedUp" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mFramePickedUp = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="spawn_pos.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 spawn_pos; //  the position where this item spawned<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="spawn_pos.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 spawn_pos; //  the position where this item spawned<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="preferred_inventory" type="INVENTORY_KIND" default="QUICK">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>INVENTORY_KIND::Enum preferred_inventory; //  Which inventory do we go to when we're picked up, if it's not full.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="inventory_slot.x" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 inventory_slot; //  our preferred slot (x,y) in the inventory<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="inventory_slot.y" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 inventory_slot; //  our preferred slot (x,y) in the inventory<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mItemUid" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mItemUid = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mIsIdentified" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mIsIdentified = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="ItemCostComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ItemCostComponent {<br>&emsp;&emsp;&emsp;&emsp;int64 cost = 100; // [0, 3500] <br>&emsp;&emsp;&emsp;&emsp;bool stealable = 0; //  if set - will check that it's within an area called shop<br>&emsp;&emsp;&emsp;&emsp;int64 mExCost = -1; //  used to change the text on the sprite<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="cost" type="xs:int" default="100">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int64 cost = 100; // [0, 3500] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="stealable" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool stealable = 0; //  if set - will check that it's within an area called shop<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mExCost" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int64 mExCost = -1; //  used to change the text on the sprite<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="ItemPickUpperComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ItemPickUpperComponent {<br>&emsp;&emsp;&emsp;&emsp;bool is_in_npc = 0;<br>&emsp;&emsp;&emsp;&emsp;bool pick_up_any_item_buggy = 0; //  If true, will pick up _any_ item. Breaks all kinds of things, but maybe mods will find this fun to mess around with<br>&emsp;&emsp;&emsp;&emsp;bool is_immune_to_kicks = 0; //  if set, won't drop the wand if kicked. Mainly used by wand ghosts.<br>&emsp;&emsp;&emsp;&emsp;EntityID only_pick_this_entity = 0; //  picks up this entity and only this entity. Overrides the is_in_npc checks that try to limit things to pickuppable wands<br>&emsp;&emsp;&emsp;&emsp;bool drop_items_on_death = 1; //  if true, will drop all items. E.g. if true for player, player drops their wands<br>&emsp;&emsp;&emsp;&emsp;vec2 mLatestItemOverlapInfoBoxPosition;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="is_in_npc" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_in_npc = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="pick_up_any_item_buggy" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool pick_up_any_item_buggy = 0; //  If true, will pick up _any_ item. Breaks all kinds of things, but maybe mods will find this fun to mess around with<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_immune_to_kicks" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_immune_to_kicks = 0; //  if set, won't drop the wand if kicked. Mainly used by wand ghosts.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: EntityID for only_pick_this_entity -->
		<xs:attribute name="drop_items_on_death" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool drop_items_on_death = 1; //  if true, will drop all items. E.g. if true for player, player drops their wands<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLatestItemOverlapInfoBoxPosition.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mLatestItemOverlapInfoBoxPosition;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLatestItemOverlapInfoBoxPosition.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mLatestItemOverlapInfoBoxPosition;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="ItemRechargeNearGroundComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ItemRechargeNearGroundComponent {<br>&emsp;&emsp;&emsp;&emsp;float TEMP_TEMPY = 0; // [0, 3.5] <br>&emsp;&emsp;&emsp;&emsp;float TEMP_TEMP_TEMP = 0; // [0, 3.5] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="TEMP_TEMPY" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float TEMP_TEMPY = 0; // [0, 3.5] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="TEMP_TEMP_TEMP" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float TEMP_TEMP_TEMP = 0; // [0, 3.5] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="ItemStashComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ItemStashComponent {<br>&emsp;&emsp;&emsp;&emsp;int throw_openable_cooldown_frames = 30; // [0, 180] <br>&emsp;&emsp;&emsp;&emsp;bool init_children = 1;<br>&emsp;&emsp;&emsp;&emsp;int mNextFrameOpenable = 0;<br>&emsp;&emsp;&emsp;&emsp;int mFrameOpened = -1;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="throw_openable_cooldown_frames" type="xs:int" default="30">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int throw_openable_cooldown_frames = 30; // [0, 180] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="init_children" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool init_children = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mNextFrameOpenable" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mNextFrameOpenable = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mFrameOpened" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mFrameOpened = -1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="KickComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class KickComponent {<br>&emsp;&emsp;&emsp;&emsp;bool can_kick = 1; //  e.g. telekinetic kick disables this<br>&emsp;&emsp;&emsp;&emsp;float kick_radius = 3; // [0, 3.5] <br>&emsp;&emsp;&emsp;&emsp;float telekinesis_throw_speed = 25; //  this is here, so that STRONG_KICK -perk can affect telekinetic kick as well<br>&emsp;&emsp;&emsp;&emsp;std::string kick_entities; //  comma separated list of entities that are loaded when player kicks<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> max_force;<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> player_kickforce;<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> kick_damage; //  ( 1.f / 25.f )<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> kick_knockback; //  knockback force for entities<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="can_kick" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool can_kick = 1; //  e.g. telekinetic kick disables this<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="kick_radius" type="xs:decimal" default="3">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float kick_radius = 3; // [0, 3.5] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="telekinesis_throw_speed" type="xs:decimal" default="25">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float telekinesis_throw_speed = 25; //  this is here, so that STRONG_KICK -perk can affect telekinetic kick as well<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="kick_entities" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string kick_entities; //  comma separated list of entities that are loaded when player kicks<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="max_force" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>LensValue<float> max_force;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="player_kickforce" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>LensValue<float> player_kickforce;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="kick_damage" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>LensValue<float> kick_damage; //  ( 1.f / 25.f )<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="kick_knockback" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>LensValue<float> kick_knockback; //  knockback force for entities<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="LaserEmitterComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class LaserEmitterComponent {<br>&emsp;&emsp;&emsp;&emsp;bool is_emitting = 1; //  If 1, will emit all the time<br>&emsp;&emsp;&emsp;&emsp;int32 emit_until_frame = -1; //  Can be used to activate a laser temporarily<br>&emsp;&emsp;&emsp;&emsp;float laser_angle_add_rad = 0; //  Beam angle = entity angle + laser_angle_add_rad<br>&emsp;&emsp;&emsp;&emsp;ConfigLaser laser;<br>};<br>```]]> </xs:documentation> </xs:annotation>
			<xs:all>
				<xs:element name="laser" type="ConfigLaser" minOccurs="0"/>
			</xs:all>
		<xs:attribute name="is_emitting" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_emitting = 1; //  If 1, will emit all the time<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="emit_until_frame" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int32 emit_until_frame = -1; //  Can be used to activate a laser temporarily<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="laser_angle_add_rad" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float laser_angle_add_rad = 0; //  Beam angle = entity angle + laser_angle_add_rad<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="LevitationComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class LevitationComponent {<br>&emsp;&emsp;&emsp;&emsp;float radius = 20; // [1, 50] the radius in which we look for entities / bodies to float<br>&emsp;&emsp;&emsp;&emsp;float entity_force = 0.3; //  how much do we apply the mouse movements to the entitiy<br>&emsp;&emsp;&emsp;&emsp;float box2d_force = 0.3; //  how much do we apply the mouse movements to the entitiy<br>&emsp;&emsp;&emsp;&emsp;int effect_lifetime_frames = 600; // [1, 600] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="radius" type="xs:decimal" default="20">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float radius = 20; // [1, 50] the radius in which we look for entities / bodies to float<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="entity_force" type="xs:decimal" default="0.3">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float entity_force = 0.3; //  how much do we apply the mouse movements to the entitiy<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="box2d_force" type="xs:decimal" default="0.3">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float box2d_force = 0.3; //  how much do we apply the mouse movements to the entitiy<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="effect_lifetime_frames" type="xs:int" default="600">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int effect_lifetime_frames = 600; // [1, 600] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="LifetimeComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class LifetimeComponent {<br>&emsp;&emsp;&emsp;&emsp;int lifetime = -1; //  if anything else than -1 will kill this entity when this many frames have passed<br>&emsp;&emsp;&emsp;&emsp;bool fade_sprites = 0; //  if 1, sprites will be faded as lifetime gets lower<br>&emsp;&emsp;&emsp;&emsp;bool kill_parent = 0; //  if 1, will kill the parent entity<br>&emsp;&emsp;&emsp;&emsp;bool kill_all_parents = 0; //  if 1, will kill all the parents entity<br>&emsp;&emsp;&emsp;&emsp;bool serialize_duration = 0; //  if 1, will retain kill_frame and creation_frame over serialization<br>&emsp;&emsp;&emsp;&emsp;int kill_frame_serialized = 0; //  frame that this is killed at<br>&emsp;&emsp;&emsp;&emsp;int creation_frame_serialized = 0; //  frame that this is killed at<br>&emsp;&emsp;&emsp;&emsp;ValueRange randomize_lifetime; //  this is added to the lifetime<br>&emsp;&emsp;&emsp;&emsp;int creation_frame = 0; //  we'll set this to GG.GetFrameNum() when this component is created<br>&emsp;&emsp;&emsp;&emsp;int kill_frame = 0; //  frame that this is killed at<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="lifetime" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int lifetime = -1; //  if anything else than -1 will kill this entity when this many frames have passed<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fade_sprites" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool fade_sprites = 0; //  if 1, sprites will be faded as lifetime gets lower<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="kill_parent" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool kill_parent = 0; //  if 1, will kill the parent entity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="kill_all_parents" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool kill_all_parents = 0; //  if 1, will kill all the parents entity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="serialize_duration" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool serialize_duration = 0; //  if 1, will retain kill_frame and creation_frame over serialization<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="kill_frame_serialized" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int kill_frame_serialized = 0; //  frame that this is killed at<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="creation_frame_serialized" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int creation_frame_serialized = 0; //  frame that this is killed at<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="randomize_lifetime.min" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ValueRange randomize_lifetime; //  this is added to the lifetime<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="randomize_lifetime.max" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ValueRange randomize_lifetime; //  this is added to the lifetime<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="creation_frame" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int creation_frame = 0; //  we'll set this to GG.GetFrameNum() when this component is created<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="kill_frame" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int kill_frame = 0; //  frame that this is killed at<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="LightComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class LightComponent {<br>&emsp;&emsp;&emsp;&emsp;bool update_properties = 0; //  turn this on if you expect this to function like the other components<br>&emsp;&emsp;&emsp;&emsp;float radius = 0; // [0, 3000] The radius of the light in world pixels.<br>&emsp;&emsp;&emsp;&emsp;unsigned int r = 255; // [0, 255] Color red 0-255<br>&emsp;&emsp;&emsp;&emsp;unsigned int g = 178; // [0, 255] Color green 0-255<br>&emsp;&emsp;&emsp;&emsp;unsigned int b = 118; // [0, 255] Color blue 0-255<br>&emsp;&emsp;&emsp;&emsp;float offset_x = 0; // [-3000, 3000] Offset from the center of entity.<br>&emsp;&emsp;&emsp;&emsp;float offset_y = 0; // [-3000, 3000] Offset from the center of entity.<br>&emsp;&emsp;&emsp;&emsp;float fade_out_time = 0; // [0, 5] time in seconds, if not 0, this is how long this takes to die, when the component is destroyed<br>&emsp;&emsp;&emsp;&emsp;float blinking_freq = 1; //  if less than 1, will blink randomly when rand() < blinking_freq<br>&emsp;&emsp;&emsp;&emsp;float mAlpha = 1;<br>&emsp;&emsp;&emsp;&emsp;as::Sprite* mSprite;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="update_properties" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool update_properties = 0; //  turn this on if you expect this to function like the other components<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="radius" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float radius = 0; // [0, 3000] The radius of the light in world pixels.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="r" type="xs:unsignedInt" default="255">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>unsigned int r = 255; // [0, 255] Color red 0-255<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="g" type="xs:unsignedInt" default="178">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>unsigned int g = 178; // [0, 255] Color green 0-255<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="b" type="xs:unsignedInt" default="118">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>unsigned int b = 118; // [0, 255] Color blue 0-255<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="offset_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float offset_x = 0; // [-3000, 3000] Offset from the center of entity.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="offset_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float offset_y = 0; // [-3000, 3000] Offset from the center of entity.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fade_out_time" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float fade_out_time = 0; // [0, 5] time in seconds, if not 0, this is how long this takes to die, when the component is destroyed<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="blinking_freq" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float blinking_freq = 1; //  if less than 1, will blink randomly when rand() < blinking_freq<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mAlpha" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mAlpha = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: as::Sprite* for mSprite -->
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="LightningComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class LightningComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string sprite_lightning_file = "data/particles/lightning_ray.png"; //  particle effect, from where the file is loaded that lightning is generated from<br>&emsp;&emsp;&emsp;&emsp;bool is_projectile = 0; //  if this is true, it's a projectile lightning and looks for ProjectileComponent and uses the data from there to move it<br>&emsp;&emsp;&emsp;&emsp;int explosion_type = 1; //  1 = lightning trail<br>&emsp;&emsp;&emsp;&emsp;int arc_lifetime = 60; //  remaining number of frames the arc exists<br>&emsp;&emsp;&emsp;&emsp;ConfigExplosion config_explosion;<br>&emsp;&emsp;&emsp;&emsp;vec2 mExPosition; //  stores the ex position of this entity<br>&emsp;&emsp;&emsp;&emsp;EntityID mArcTarget = 0; //  if 'mArcTarget' points to an existing entity a lighting arc will be created between this entity and 'mArcTarget'<br>};<br>```]]> </xs:documentation> </xs:annotation>
			<xs:all>
				<xs:element name="config_explosion" type="ConfigExplosion" minOccurs="0"/>
			</xs:all>
		<xs:attribute name="sprite_lightning_file" type="xs:string" default="data/particles/lightning_ray.png">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string sprite_lightning_file = "data/particles/lightning_ray.png"; //  particle effect, from where the file is loaded that lightning is generated from<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_projectile" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_projectile = 0; //  if this is true, it's a projectile lightning and looks for ProjectileComponent and uses the data from there to move it<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="explosion_type" type="xs:int" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int explosion_type = 1; //  1 = lightning trail<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="arc_lifetime" type="xs:int" default="60">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int arc_lifetime = 60; //  remaining number of frames the arc exists<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mExPosition.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mExPosition; //  stores the ex position of this entity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mExPosition.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mExPosition; //  stores the ex position of this entity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: EntityID for mArcTarget -->
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="LimbBossComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class LimbBossComponent {<br>&emsp;&emsp;&emsp;&emsp;int state = 0;<br>&emsp;&emsp;&emsp;&emsp;int mStatePrev = -1;<br>&emsp;&emsp;&emsp;&emsp;float mMoveToPositionX = 0;<br>&emsp;&emsp;&emsp;&emsp;float mMoveToPositionY = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="state" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int state = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mStatePrev" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mStatePrev = -1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mMoveToPositionX" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mMoveToPositionX = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mMoveToPositionY" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mMoveToPositionY = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="LiquidDisplacerComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class LiquidDisplacerComponent {<br>&emsp;&emsp;&emsp;&emsp;int radius = 1; // [0, 20] <br>&emsp;&emsp;&emsp;&emsp;float velocity_x = 30; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;float velocity_y = 30; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;int mPrevX = 0;<br>&emsp;&emsp;&emsp;&emsp;int mPrevY = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="radius" type="xs:int" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int radius = 1; // [0, 20] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="velocity_x" type="xs:decimal" default="30">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float velocity_x = 30; // [0, 100] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="velocity_y" type="xs:decimal" default="30">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float velocity_y = 30; // [0, 100] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevX" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mPrevX = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevY" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mPrevY = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="LoadEntitiesComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class LoadEntitiesComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string entity_file; //  path to the entity file we should load<br>&emsp;&emsp;&emsp;&emsp;bool kill_entity = 1; //  if 1, we kill our entity when it is created<br>&emsp;&emsp;&emsp;&emsp;int timeout_frames = 0; // [0, 180] for timer<br>&emsp;&emsp;&emsp;&emsp;int mTimerTriggerFrame = -1;<br>&emsp;&emsp;&emsp;&emsp;ValueRangeInt count; //  how many entities should be loaded (random range)<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="entity_file" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string entity_file; //  path to the entity file we should load<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="kill_entity" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool kill_entity = 1; //  if 1, we kill our entity when it is created<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="timeout_frames" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int timeout_frames = 0; // [0, 180] for timer<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mTimerTriggerFrame" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mTimerTriggerFrame = -1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="count.min" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ValueRangeInt count; //  how many entities should be loaded (random range)<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="count.max" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ValueRangeInt count; //  how many entities should be loaded (random range)<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="LocationMarkerComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class LocationMarkerComponent {<br>&emsp;&emsp;&emsp;&emsp;int id = 0; // [0, 3] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="id" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int id = 0; // [0, 3] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="LooseGroundComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class LooseGroundComponent {<br>&emsp;&emsp;&emsp;&emsp;float probability = 0; //  how often do we do this... shoots a ray in random direction and does the loosening<br>&emsp;&emsp;&emsp;&emsp;int max_durability = 2147483647; //  if material durability > max_durability, it is not loosened<br>&emsp;&emsp;&emsp;&emsp;float max_distance = 256; //  how far raytraces to find things to loosen up<br>&emsp;&emsp;&emsp;&emsp;float max_angle = 1.57; //  how much raytraces go to different directions around the up-vector. pi=full circle<br>&emsp;&emsp;&emsp;&emsp;int min_radius = 3; //  the minimum radius of our loosening of pixels<br>&emsp;&emsp;&emsp;&emsp;int max_radius = 8; //  the maximum radius of our loosening of pixels<br>&emsp;&emsp;&emsp;&emsp;float chunk_probability = 0; //  if > 0, will drop box2d chunks of the ceiling<br>&emsp;&emsp;&emsp;&emsp;float chunk_max_angle = 0.7; //  how much raytraces go to different directions around the up-vector. pi=full circle<br>&emsp;&emsp;&emsp;&emsp;int chunk_count = -1; //  how many chunks are we allowed to do, -1 = infinite<br>&emsp;&emsp;&emsp;&emsp;std::string collapse_images = "data/procedural_gfx/collapse_big/$[0-14].png"; //  loads these files randomly to do the collapse shapes<br>&emsp;&emsp;&emsp;&emsp;int chunk_material = 0; //  String name of chunk material<br>&emsp;&emsp;&emsp;&emsp;int mChunkCount = 0; //  how many chunks are we allowed to do, -1 = infinite<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="probability" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float probability = 0; //  how often do we do this... shoots a ray in random direction and does the loosening<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="max_durability" type="xs:int" default="2147483647">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int max_durability = 2147483647; //  if material durability > max_durability, it is not loosened<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="max_distance" type="xs:decimal" default="256">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float max_distance = 256; //  how far raytraces to find things to loosen up<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="max_angle" type="xs:decimal" default="1.57">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float max_angle = 1.57; //  how much raytraces go to different directions around the up-vector. pi=full circle<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="min_radius" type="xs:int" default="3">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int min_radius = 3; //  the minimum radius of our loosening of pixels<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="max_radius" type="xs:int" default="8">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int max_radius = 8; //  the maximum radius of our loosening of pixels<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="chunk_probability" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float chunk_probability = 0; //  if > 0, will drop box2d chunks of the ceiling<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="chunk_max_angle" type="xs:decimal" default="0.7">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float chunk_max_angle = 0.7; //  how much raytraces go to different directions around the up-vector. pi=full circle<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="chunk_count" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int chunk_count = -1; //  how many chunks are we allowed to do, -1 = infinite<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="collapse_images" type="xs:string" default="data/procedural_gfx/collapse_big/$[0-14].png">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string collapse_images = "data/procedural_gfx/collapse_big/$[0-14].png"; //  loads these files randomly to do the collapse shapes<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="chunk_material" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int chunk_material = 0; //  String name of chunk material<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mChunkCount" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mChunkCount = 0; //  how many chunks are we allowed to do, -1 = infinite<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="LuaComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class LuaComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string script_source_file;<br>&emsp;&emsp;&emsp;&emsp;bool execute_on_added = 0;<br>&emsp;&emsp;&emsp;&emsp;bool execute_on_removed = 0;<br>&emsp;&emsp;&emsp;&emsp;int execute_every_n_frame = 1; // [1, 150] 1 = execute every frame. 2 = execute every second frame. 3 = execute every third frame and so on. -1 = execute only on add/remove/event<br>&emsp;&emsp;&emsp;&emsp;int execute_times = 0; //  How many times should the script be executed? < 1 means infinite<br>&emsp;&emsp;&emsp;&emsp;int limit_how_many_times_per_frame = -1; //  -1 = infinite. Use this to limit how many times this can be executed per frame. Currently only used to limit script_shot from being executed forever.<br>&emsp;&emsp;&emsp;&emsp;int limit_to_every_n_frame = -1; //  -1 = no limit. Currently only used to limit script_shot from being executed every frame.<br>&emsp;&emsp;&emsp;&emsp;bool limit_all_callbacks = 0; //  NOTE( Petri ): 19.8.2023 - by default limit_how_many_times_per_frame and limit_to_every_n_frame only works for script_shot. If this is set to true, will limit all callbacks. Also note that this limit is shared within this component. So if this is true and both script_shot and script_damage_received and both are called within limit_to_every_n_frame frames, only one of them will be called.<br>&emsp;&emsp;&emsp;&emsp;bool remove_after_executed = 0;<br>&emsp;&emsp;&emsp;&emsp;bool enable_coroutines = 0;<br>&emsp;&emsp;&emsp;&emsp;bool call_init_function = 0; //   if 1, calls function init( entity_id:int ) after running the code in the file scope of script_source_file along with all mod appends. Does nothing if execute_on_added is 0<br>&emsp;&emsp;&emsp;&emsp;std::string script_enabled_changed; //  if set, calls function 'enabled_changed( entity_id:int, is_enabled:bool )' when the IsEnabled status of this LuaComponent is changed<br>&emsp;&emsp;&emsp;&emsp;std::string script_damage_received; //  if set, calls function 'damage_received( damage:number, message:string, entity_thats_responsible:int, is_fatal:bool, projectile_thats_responsible:int )' when we receive a message about damage (Message_DamageReceived)<br>&emsp;&emsp;&emsp;&emsp;std::string script_damage_about_to_be_received; //  if set, calls function 'damage_about_to_be_received( damage:number, x:number, y:number, entity_thats_responsible:int, critical_hit_chance:int )' when we receive a message (Message_DamageAboutToBeReceived) -> new_damage:number,new_critical_hit_chance:int<br>&emsp;&emsp;&emsp;&emsp;std::string script_item_picked_up; //  if set, calls function 'item_pickup( int entity_item, int entity_pickupper, string item_name )' when message 'Message_ItemPickUp' is called<br>&emsp;&emsp;&emsp;&emsp;std::string script_shot; //  if set, calls function 'shot( projectile_entity_id )' when we receive Message_Shot<br>&emsp;&emsp;&emsp;&emsp;std::string script_collision_trigger_hit; //  if set, calls function 'collision_trigger( colliding_entity_id )' when we receive Message_CollisionTriggerHit<br>&emsp;&emsp;&emsp;&emsp;std::string script_collision_trigger_timer_finished; //  if set, calls function 'collision_trigger_timer_finished()' when we receive Message_CollisionTriggerTimerFinished<br>&emsp;&emsp;&emsp;&emsp;std::string script_physics_body_modified; //  if set, calls function 'physics_body_modified( is_destroyed )' when physics body has been modified<br>&emsp;&emsp;&emsp;&emsp;std::string script_pressure_plate_change; //  if set, calls function 'pressure_plate_change( new_state )' when PressurePlateComponent decides that things have change<br>&emsp;&emsp;&emsp;&emsp;std::string script_inhaled_material; //  if set, calls function 'inhaled_material( material_name, count )' once per second for each inhaled material<br>&emsp;&emsp;&emsp;&emsp;std::string script_death; //  if set, calls function 'death( int damage_type_bit_field, string damage_message, int entity_thats_responsible, bool drop_items )' when we receive message Message_Death<br>&emsp;&emsp;&emsp;&emsp;std::string script_throw_item; //  if set, calls function 'throw_item( from_x, from_y, to_x, to_y )' when we receive message Message_ThrowItem<br>&emsp;&emsp;&emsp;&emsp;std::string script_material_area_checker_failed; //  if set, calls function 'material_area_checker_failed( pos_x, pos_y, )' when we receive message Message_MaterialAreaCheckerFailed<br>&emsp;&emsp;&emsp;&emsp;std::string script_material_area_checker_success; //  if set, calls function 'material_area_checker_success( pos_x, pos_y, )' when we receive message Message_MaterialAreaCheckerSuccess<br>&emsp;&emsp;&emsp;&emsp;std::string script_electricity_receiver_switched; //  if set, calls function 'electricity_receiver_switched( bool is_electrified )' when we receive message Message_ElectricityReceiverSwitched<br>&emsp;&emsp;&emsp;&emsp;std::string script_electricity_receiver_electrified; //  if set, calls function 'electricity_receiver_electrified()' when we receive message Message_ElectricityReceiverElectrified<br>&emsp;&emsp;&emsp;&emsp;std::string script_kick; //  if set, calls function 'kick( entity_who_kicked )' when we receive message Message_Kick<br>&emsp;&emsp;&emsp;&emsp;std::string script_interacting; //  if set, calls function 'interacting( entity_who_interacted, entity_interacted, interactable_name )' when we receive message Message_Interaction<br>&emsp;&emsp;&emsp;&emsp;std::string script_audio_event_dead; //  if set, calls function 'audio_event_dead( bank_file, event_root )' when we receive message Message_AudioEventDead<br>&emsp;&emsp;&emsp;&emsp;std::string script_wand_fired; //  if set, calls function 'wand_fired( gun_entity_id )' when we receive Message_WandFired<br>&emsp;&emsp;&emsp;&emsp;std::string script_teleported; //  if set, calls function 'teleported( from_x, from_y, to_x, to_y, bool portal_teleport )' when we receive Message_Teleported<br>&emsp;&emsp;&emsp;&emsp;std::string script_portal_teleport_used; //  if set, calls function 'portal_teleport_used( entity_that_was_teleported, from_x, from_y, to_x, to_y )' when we receive Message_PortalTeleportUsed<br>&emsp;&emsp;&emsp;&emsp;std::string script_polymorphing_to; //  if set, calls function 'polymorphing_to( string_entity_we_are_about_to_polymorph_to )' when we receive Message_PolymorphingTo<br>&emsp;&emsp;&emsp;&emsp;std::string script_biome_entered; //  if set, calls function 'biome_entered( string_biome_name, string_biome_old_name )' when this entity changes biomes. Requires BiomeTrackerComponent<br>&emsp;&emsp;&emsp;&emsp;int mLastExecutionFrame = -1;<br>&emsp;&emsp;&emsp;&emsp;int mTimesExecutedThisFrame = 0; //  tracks how many times we've executed this frame. This will linger on and store the old value of the old frames. Used internally.<br>&emsp;&emsp;&emsp;&emsp;bool mModAppendsDone = 0;<br>&emsp;&emsp;&emsp;&emsp;LUA_VM_TYPE::Enum vm_type; //  Do we share a single Lua virtual machine for everyone who runs 'script_source_file' ('SHARED_BY_MANY_COMPONENTS'), create one VM per one LuaComponent and reuse the VM in case the component runs the script multiple times ('ONE_PER_COMPONENT_INSTANCE'), or create a new VM every time the script is executed ('CREATE_NEW_EVERY_EXECUTION', deprecated)?<br>&emsp;&emsp;&emsp;&emsp;int mNextExecutionTime = -1;<br>&emsp;&emsp;&emsp;&emsp;int mTimesExecuted = 0;<br>&emsp;&emsp;&emsp;&emsp;LuaManager* mLuaManager;<br>&emsp;&emsp;&emsp;&emsp;ValueMap mPersistentValues;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="script_source_file" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string script_source_file;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="execute_on_added" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool execute_on_added = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="execute_on_removed" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool execute_on_removed = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="execute_every_n_frame" type="xs:int" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int execute_every_n_frame = 1; // [1, 150] 1 = execute every frame. 2 = execute every second frame. 3 = execute every third frame and so on. -1 = execute only on add/remove/event<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="execute_times" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int execute_times = 0; //  How many times should the script be executed? < 1 means infinite<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="limit_how_many_times_per_frame" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int limit_how_many_times_per_frame = -1; //  -1 = infinite. Use this to limit how many times this can be executed per frame. Currently only used to limit script_shot from being executed forever.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="limit_to_every_n_frame" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int limit_to_every_n_frame = -1; //  -1 = no limit. Currently only used to limit script_shot from being executed every frame.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="limit_all_callbacks" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool limit_all_callbacks = 0; //  NOTE( Petri ): 19.8.2023 - by default limit_how_many_times_per_frame and limit_to_every_n_frame only works for script_shot. If this is set to true, will limit all callbacks. Also note that this limit is shared within this component. So if this is true and both script_shot and script_damage_received and both are called within limit_to_every_n_frame frames, only one of them will be called.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="remove_after_executed" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool remove_after_executed = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="enable_coroutines" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool enable_coroutines = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="call_init_function" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool call_init_function = 0; //   if 1, calls function init( entity_id:int ) after running the code in the file scope of script_source_file along with all mod appends. Does nothing if execute_on_added is 0<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="script_enabled_changed" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string script_enabled_changed; //  if set, calls function 'enabled_changed( entity_id:int, is_enabled:bool )' when the IsEnabled status of this LuaComponent is changed<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="script_damage_received" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string script_damage_received; //  if set, calls function 'damage_received( damage:number, message:string, entity_thats_responsible:int, is_fatal:bool, projectile_thats_responsible:int )' when we receive a message about damage (Message_DamageReceived)<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="script_damage_about_to_be_received" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string script_damage_about_to_be_received; //  if set, calls function 'damage_about_to_be_received( damage:number, x:number, y:number, entity_thats_responsible:int, critical_hit_chance:int )' when we receive a message (Message_DamageAboutToBeReceived) -> new_damage:number,new_critical_hit_chance:int<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="script_item_picked_up" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string script_item_picked_up; //  if set, calls function 'item_pickup( int entity_item, int entity_pickupper, string item_name )' when message 'Message_ItemPickUp' is called<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="script_shot" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string script_shot; //  if set, calls function 'shot( projectile_entity_id )' when we receive Message_Shot<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="script_collision_trigger_hit" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string script_collision_trigger_hit; //  if set, calls function 'collision_trigger( colliding_entity_id )' when we receive Message_CollisionTriggerHit<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="script_collision_trigger_timer_finished" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string script_collision_trigger_timer_finished; //  if set, calls function 'collision_trigger_timer_finished()' when we receive Message_CollisionTriggerTimerFinished<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="script_physics_body_modified" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string script_physics_body_modified; //  if set, calls function 'physics_body_modified( is_destroyed )' when physics body has been modified<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="script_pressure_plate_change" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string script_pressure_plate_change; //  if set, calls function 'pressure_plate_change( new_state )' when PressurePlateComponent decides that things have change<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="script_inhaled_material" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string script_inhaled_material; //  if set, calls function 'inhaled_material( material_name, count )' once per second for each inhaled material<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="script_death" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string script_death; //  if set, calls function 'death( int damage_type_bit_field, string damage_message, int entity_thats_responsible, bool drop_items )' when we receive message Message_Death<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="script_throw_item" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string script_throw_item; //  if set, calls function 'throw_item( from_x, from_y, to_x, to_y )' when we receive message Message_ThrowItem<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="script_material_area_checker_failed" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string script_material_area_checker_failed; //  if set, calls function 'material_area_checker_failed( pos_x, pos_y, )' when we receive message Message_MaterialAreaCheckerFailed<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="script_material_area_checker_success" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string script_material_area_checker_success; //  if set, calls function 'material_area_checker_success( pos_x, pos_y, )' when we receive message Message_MaterialAreaCheckerSuccess<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="script_electricity_receiver_switched" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string script_electricity_receiver_switched; //  if set, calls function 'electricity_receiver_switched( bool is_electrified )' when we receive message Message_ElectricityReceiverSwitched<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="script_electricity_receiver_electrified" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string script_electricity_receiver_electrified; //  if set, calls function 'electricity_receiver_electrified()' when we receive message Message_ElectricityReceiverElectrified<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="script_kick" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string script_kick; //  if set, calls function 'kick( entity_who_kicked )' when we receive message Message_Kick<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="script_interacting" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string script_interacting; //  if set, calls function 'interacting( entity_who_interacted, entity_interacted, interactable_name )' when we receive message Message_Interaction<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="script_audio_event_dead" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string script_audio_event_dead; //  if set, calls function 'audio_event_dead( bank_file, event_root )' when we receive message Message_AudioEventDead<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="script_wand_fired" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string script_wand_fired; //  if set, calls function 'wand_fired( gun_entity_id )' when we receive Message_WandFired<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="script_teleported" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string script_teleported; //  if set, calls function 'teleported( from_x, from_y, to_x, to_y, bool portal_teleport )' when we receive Message_Teleported<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="script_portal_teleport_used" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string script_portal_teleport_used; //  if set, calls function 'portal_teleport_used( entity_that_was_teleported, from_x, from_y, to_x, to_y )' when we receive Message_PortalTeleportUsed<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="script_polymorphing_to" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string script_polymorphing_to; //  if set, calls function 'polymorphing_to( string_entity_we_are_about_to_polymorph_to )' when we receive Message_PolymorphingTo<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="script_biome_entered" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string script_biome_entered; //  if set, calls function 'biome_entered( string_biome_name, string_biome_old_name )' when this entity changes biomes. Requires BiomeTrackerComponent<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLastExecutionFrame" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mLastExecutionFrame = -1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mTimesExecutedThisFrame" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mTimesExecutedThisFrame = 0; //  tracks how many times we've executed this frame. This will linger on and store the old value of the old frames. Used internally.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mModAppendsDone" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mModAppendsDone = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="vm_type" type="LUA_VM_TYPE" default="SHARED_BY_MANY_COMPONENTS">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>LUA_VM_TYPE::Enum vm_type; //  Do we share a single Lua virtual machine for everyone who runs 'script_source_file' ('SHARED_BY_MANY_COMPONENTS'), create one VM per one LuaComponent and reuse the VM in case the component runs the script multiple times ('ONE_PER_COMPONENT_INSTANCE'), or create a new VM every time the script is executed ('CREATE_NEW_EVERY_EXECUTION', deprecated)?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mNextExecutionTime" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mNextExecutionTime = -1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mTimesExecuted" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mTimesExecuted = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: LuaManager* for mLuaManager -->
		<!-- Some Unknown Type: ValueMap for mPersistentValues -->
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="MagicConvertMaterialComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class MagicConvertMaterialComponent {<br>&emsp;&emsp;&emsp;&emsp;int radius = 256; // [0, 512] <br>&emsp;&emsp;&emsp;&emsp;int min_radius = 0; // [0, 512] allows for convert to happen from x pixels from the center<br>&emsp;&emsp;&emsp;&emsp;bool is_circle = 0;<br>&emsp;&emsp;&emsp;&emsp;int steps_per_frame = 10; // [0, 512] <br>&emsp;&emsp;&emsp;&emsp;std::string from_material_tag; //  the tag of material, e.g. [liquid]<br>&emsp;&emsp;&emsp;&emsp;bool from_any_material = 0; //  if 1, converts any cells of any material to 'to_materia'<br>&emsp;&emsp;&emsp;&emsp;bool clean_stains = 0;<br>&emsp;&emsp;&emsp;&emsp;bool extinguish_fire = 0;<br>&emsp;&emsp;&emsp;&emsp;int fan_the_flames = 0; //  if > 0, will call UpdateFire() fan_the_flames times<br>&emsp;&emsp;&emsp;&emsp;int32 temperature_reaction_temp = 0; //  if != 0, will use the 'cold_freezes_to_materials' and 'warmth_melts_to_materials' in CellData to convert cells different materials<br>&emsp;&emsp;&emsp;&emsp;int ignite_materials = 0; //  if > 0, will call Ignite() with ingite_materials as probability_of_fire<br>&emsp;&emsp;&emsp;&emsp;bool loop = 0;<br>&emsp;&emsp;&emsp;&emsp;bool kill_when_finished = 1;<br>&emsp;&emsp;&emsp;&emsp;bool convert_entities = 0; //  if 1, kills entities with a damagemodel and converts them to 'to_material'<br>&emsp;&emsp;&emsp;&emsp;bool stain_frozen = 0; //  petri hax<br>&emsp;&emsp;&emsp;&emsp;float reaction_audio_amount = 0; //  if > 0, will generate chemical reaction audio at converted cells<br>&emsp;&emsp;&emsp;&emsp;bool convert_same_material = 1; //  9.10.2020 - added this because at the end this caused the 'white ring' to appear, set it to false if you don't want constant whiteout<br>&emsp;&emsp;&emsp;&emsp;std::string from_material_array;<br>&emsp;&emsp;&emsp;&emsp;std::string to_material_array;<br>&emsp;&emsp;&emsp;&emsp;int mRadius = 0; // [0, 512] <br>&emsp;&emsp;&emsp;&emsp;int from_material = 0;<br>&emsp;&emsp;&emsp;&emsp;int to_material = 0;<br>&emsp;&emsp;&emsp;&emsp;bool mUseArrays = 0;<br>&emsp;&emsp;&emsp;&emsp;std::vector<int> mFromMaterialArray;<br>&emsp;&emsp;&emsp;&emsp;std::vector<int> mToMaterialArray;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="radius" type="xs:int" default="256">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int radius = 256; // [0, 512] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="min_radius" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int min_radius = 0; // [0, 512] allows for convert to happen from x pixels from the center<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_circle" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_circle = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="steps_per_frame" type="xs:int" default="10">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int steps_per_frame = 10; // [0, 512] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="from_material_tag" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string from_material_tag; //  the tag of material, e.g. [liquid]<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="from_any_material" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool from_any_material = 0; //  if 1, converts any cells of any material to 'to_materia'<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="clean_stains" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool clean_stains = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="extinguish_fire" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool extinguish_fire = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fan_the_flames" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int fan_the_flames = 0; //  if > 0, will call UpdateFire() fan_the_flames times<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="temperature_reaction_temp" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int32 temperature_reaction_temp = 0; //  if != 0, will use the 'cold_freezes_to_materials' and 'warmth_melts_to_materials' in CellData to convert cells different materials<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ignite_materials" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int ignite_materials = 0; //  if > 0, will call Ignite() with ingite_materials as probability_of_fire<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="loop" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool loop = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="kill_when_finished" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool kill_when_finished = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="convert_entities" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool convert_entities = 0; //  if 1, kills entities with a damagemodel and converts them to 'to_material'<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="stain_frozen" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool stain_frozen = 0; //  petri hax<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="reaction_audio_amount" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float reaction_audio_amount = 0; //  if > 0, will generate chemical reaction audio at converted cells<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="convert_same_material" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool convert_same_material = 1; //  9.10.2020 - added this because at the end this caused the 'white ring' to appear, set it to false if you don't want constant whiteout<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="from_material_array" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string from_material_array;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="to_material_array" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string to_material_array;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mRadius" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mRadius = 0; // [0, 512] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="from_material" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int from_material = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="to_material" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int to_material = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mUseArrays" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mUseArrays = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: std::vector<int> for mFromMaterialArray -->
		<!-- Some Unknown Type: std::vector<int> for mToMaterialArray -->
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="MagicXRayComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class MagicXRayComponent {<br>&emsp;&emsp;&emsp;&emsp;int radius = 256; // [0, 512] <br>&emsp;&emsp;&emsp;&emsp;int steps_per_frame = 10; // [0, 512] <br>&emsp;&emsp;&emsp;&emsp;int mStep = 0;<br>&emsp;&emsp;&emsp;&emsp;int mRadius = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="radius" type="xs:int" default="256">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int radius = 256; // [0, 512] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="steps_per_frame" type="xs:int" default="10">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int steps_per_frame = 10; // [0, 512] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mStep" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mStep = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mRadius" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mRadius = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="ManaReloaderComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ManaReloaderComponent {<br><br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="MaterialAreaCheckerComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class MaterialAreaCheckerComponent {<br>&emsp;&emsp;&emsp;&emsp;int update_every_x_frame = 0; //  if something other than 0 or 1, will only update_every_x_frames <br>&emsp;&emsp;&emsp;&emsp;bool look_for_failure = 1; //  if true, will send message Message_MaterialAreaCheckerFailed if the material doesn't exist. If false, will send a message Message_MaterialAreaCheckerSuccess if the aabb is full of material and material2<br>&emsp;&emsp;&emsp;&emsp;int count_min = 0; //  If > 0, and look_for_failure=0, will send message if material count exceeds this number of cells<br>&emsp;&emsp;&emsp;&emsp;bool always_check_fullness = 0; //  if 1, and look_for_failure=0, will always check the whole area for cells<br>&emsp;&emsp;&emsp;&emsp;bool kill_after_message = 1; //  will kill this entity after sending the message<br>&emsp;&emsp;&emsp;&emsp;types::aabb area_aabb; //  aabb offset, we check that this aabb contains only material<br>&emsp;&emsp;&emsp;&emsp;int material = 0; //  String name of material that we check that the aabb contains<br>&emsp;&emsp;&emsp;&emsp;int material2 = 0; //  String name of material2 that we check that the aabb contains<br>&emsp;&emsp;&emsp;&emsp;int mPosition = 0; //  keeps track where we are<br>&emsp;&emsp;&emsp;&emsp;int mLastFrameChecked = 0; //  keeps track of how often we've checked<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="update_every_x_frame" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int update_every_x_frame = 0; //  if something other than 0 or 1, will only update_every_x_frames <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="look_for_failure" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool look_for_failure = 1; //  if true, will send message Message_MaterialAreaCheckerFailed if the material doesn't exist. If false, will send a message Message_MaterialAreaCheckerSuccess if the aabb is full of material and material2<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="count_min" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int count_min = 0; //  If > 0, and look_for_failure=0, will send message if material count exceeds this number of cells<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="always_check_fullness" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool always_check_fullness = 0; //  if 1, and look_for_failure=0, will always check the whole area for cells<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="kill_after_message" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool kill_after_message = 1; //  will kill this entity after sending the message<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="area_aabb.min_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>types::aabb area_aabb; //  aabb offset, we check that this aabb contains only material<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="area_aabb.min_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>types::aabb area_aabb; //  aabb offset, we check that this aabb contains only material<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="area_aabb.max_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>types::aabb area_aabb; //  aabb offset, we check that this aabb contains only material<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="area_aabb.max_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>types::aabb area_aabb; //  aabb offset, we check that this aabb contains only material<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="material" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int material = 0; //  String name of material that we check that the aabb contains<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="material2" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int material2 = 0; //  String name of material2 that we check that the aabb contains<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPosition" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mPosition = 0; //  keeps track where we are<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLastFrameChecked" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mLastFrameChecked = 0; //  keeps track of how often we've checked<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="MaterialInventoryComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class MaterialInventoryComponent {<br>&emsp;&emsp;&emsp;&emsp;bool drop_as_item = 1; //  if true, drops a bag that the player can big up<br>&emsp;&emsp;&emsp;&emsp;bool on_death_spill = 0; //  if true, on the death this will explode all the materials into air<br>&emsp;&emsp;&emsp;&emsp;bool leak_gently = 1; //  NOTE( Petri ): 11.8.2023 - set this to false for old style leaky hidden piles situation.<br>&emsp;&emsp;&emsp;&emsp;float leak_on_damage_percent = 0; //  if higher than 0 then it might leak when projectile damage happens<br>&emsp;&emsp;&emsp;&emsp;float leak_pressure_min = 0.7; //  leak pressure coefficient<br>&emsp;&emsp;&emsp;&emsp;float leak_pressure_max = 1.1; //  leak pressure coefficient<br>&emsp;&emsp;&emsp;&emsp;float min_damage_to_leak = 0.09; //  the minimum damage that has to be done in order for a leak to occur<br>&emsp;&emsp;&emsp;&emsp;float b2_force_on_leak = 0; // [0, 10] if 0, nothing happens, elsewise will add a b2 force to the particleemitter which will push the b2body<br>&emsp;&emsp;&emsp;&emsp;float death_throw_particle_velocity_coeff = 1; //  how far do we throw material particles on death?<br>&emsp;&emsp;&emsp;&emsp;bool kill_when_empty = 0; //  if set, will send MessageDeath when materials are drained<br>&emsp;&emsp;&emsp;&emsp;bool halftime_materials = 0; //  if true, will multiply the materials with the given halftimes<br>&emsp;&emsp;&emsp;&emsp;int do_reactions = 0; // [0, 100] NOTE( Petri ): 15.8.2023 - if > 0, will do CellReactions between the materials. Value is the percent chance of how often. 100 = every frame <br>&emsp;&emsp;&emsp;&emsp;bool do_reactions_explosions = 0; //  requires do_reactions > 0 - are we allowed to do reaction explosions?<br>&emsp;&emsp;&emsp;&emsp;bool do_reactions_entities = 0; //  requires do_reactions > 0 - are we allowed to load entities when doing reactions?<br>&emsp;&emsp;&emsp;&emsp;int reaction_speed = 5; //  Note( Petri ): 17.8.2023 - how 'fast' do we let reactions happen. How many pixels of material do we convert at one time (5-10) seems like a nice speed.<br>&emsp;&emsp;&emsp;&emsp;bool reactions_shaking_speeds_up = 1; //  Note( Petri ): 17.8.2023 - added the ability of shaking the bottle to cause reactions to happen quicker. <br>&emsp;&emsp;&emsp;&emsp;double max_capacity = -1; //  how much materials we can store in total. < 0 = infinite<br>&emsp;&emsp;&emsp;&emsp;float audio_collision_size_modifier_amount = 0; //  if > 0, 'fullness of this container' * 'audio_collision_size_modifier_amount' is added to collision audio event size<br>&emsp;&emsp;&emsp;&emsp;int32 last_frame_drank = -100; //  last frame someone ingested from this via IngestionSystem<br>&emsp;&emsp;&emsp;&emsp;MATERIAL_VEC_DOUBLES count_per_material_type; //  Count of each material indexed by material type ID<br>&emsp;&emsp;&emsp;&emsp;bool is_death_handled = 0;<br>&emsp;&emsp;&emsp;&emsp;vec2 ex_position; //  used to figure out movement velocity<br>&emsp;&emsp;&emsp;&emsp;float ex_angle = 0; //  used to figure out movement velocity<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="drop_as_item" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool drop_as_item = 1; //  if true, drops a bag that the player can big up<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="on_death_spill" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool on_death_spill = 0; //  if true, on the death this will explode all the materials into air<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="leak_gently" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool leak_gently = 1; //  NOTE( Petri ): 11.8.2023 - set this to false for old style leaky hidden piles situation.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="leak_on_damage_percent" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float leak_on_damage_percent = 0; //  if higher than 0 then it might leak when projectile damage happens<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="leak_pressure_min" type="xs:decimal" default="0.7">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float leak_pressure_min = 0.7; //  leak pressure coefficient<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="leak_pressure_max" type="xs:decimal" default="1.1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float leak_pressure_max = 1.1; //  leak pressure coefficient<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="min_damage_to_leak" type="xs:decimal" default="0.09">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float min_damage_to_leak = 0.09; //  the minimum damage that has to be done in order for a leak to occur<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="b2_force_on_leak" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float b2_force_on_leak = 0; // [0, 10] if 0, nothing happens, elsewise will add a b2 force to the particleemitter which will push the b2body<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="death_throw_particle_velocity_coeff" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float death_throw_particle_velocity_coeff = 1; //  how far do we throw material particles on death?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="kill_when_empty" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool kill_when_empty = 0; //  if set, will send MessageDeath when materials are drained<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="halftime_materials" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool halftime_materials = 0; //  if true, will multiply the materials with the given halftimes<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="do_reactions" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int do_reactions = 0; // [0, 100] NOTE( Petri ): 15.8.2023 - if > 0, will do CellReactions between the materials. Value is the percent chance of how often. 100 = every frame <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="do_reactions_explosions" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool do_reactions_explosions = 0; //  requires do_reactions > 0 - are we allowed to do reaction explosions?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="do_reactions_entities" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool do_reactions_entities = 0; //  requires do_reactions > 0 - are we allowed to load entities when doing reactions?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="reaction_speed" type="xs:int" default="5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int reaction_speed = 5; //  Note( Petri ): 17.8.2023 - how 'fast' do we let reactions happen. How many pixels of material do we convert at one time (5-10) seems like a nice speed.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="reactions_shaking_speeds_up" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool reactions_shaking_speeds_up = 1; //  Note( Petri ): 17.8.2023 - added the ability of shaking the bottle to cause reactions to happen quicker. <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="max_capacity" type="xs:decimal" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>double max_capacity = -1; //  how much materials we can store in total. < 0 = infinite<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="audio_collision_size_modifier_amount" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float audio_collision_size_modifier_amount = 0; //  if > 0, 'fullness of this container' * 'audio_collision_size_modifier_amount' is added to collision audio event size<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="last_frame_drank" type="xs:int" default="-100">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int32 last_frame_drank = -100; //  last frame someone ingested from this via IngestionSystem<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: MATERIAL_VEC_DOUBLES for count_per_material_type -->
		<xs:attribute name="is_death_handled" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_death_handled = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ex_position.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 ex_position; //  used to figure out movement velocity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ex_position.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 ex_position; //  used to figure out movement velocity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ex_angle" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float ex_angle = 0; //  used to figure out movement velocity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="MaterialSeaSpawnerComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class MaterialSeaSpawnerComponent {<br>&emsp;&emsp;&emsp;&emsp;int speed = 10; // [1, 100] How many pixels to cover per one direction per one frame<br>&emsp;&emsp;&emsp;&emsp;float sine_wavelength = 10; // [0, 2] Parameters for sine wave that affects material spawn pattern<br>&emsp;&emsp;&emsp;&emsp;float sine_amplitude = 5; // [0, 2] Parameters for sine wave that affects material spawn pattern<br>&emsp;&emsp;&emsp;&emsp;double noise_scale = 0.1; //  Parameters for noise that affects material spawn pattern<br>&emsp;&emsp;&emsp;&emsp;double noise_threshold = 0.05; //  Parameters for noise that affects material spawn pattern<br>&emsp;&emsp;&emsp;&emsp;int m_position = 0;<br>&emsp;&emsp;&emsp;&emsp;int frames_run = 0; //  to help keep the effect<br>&emsp;&emsp;&emsp;&emsp;int material = 0; //  String name of material this creates<br>&emsp;&emsp;&emsp;&emsp;ivec2 size; //  Size of the area to cover<br>&emsp;&emsp;&emsp;&emsp;ivec2 offset; //  Offset of the center of the area to cover<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="speed" type="xs:int" default="10">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int speed = 10; // [1, 100] How many pixels to cover per one direction per one frame<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="sine_wavelength" type="xs:decimal" default="10">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float sine_wavelength = 10; // [0, 2] Parameters for sine wave that affects material spawn pattern<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="sine_amplitude" type="xs:decimal" default="5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float sine_amplitude = 5; // [0, 2] Parameters for sine wave that affects material spawn pattern<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="noise_scale" type="xs:decimal" default="0.1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>double noise_scale = 0.1; //  Parameters for noise that affects material spawn pattern<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="noise_threshold" type="xs:decimal" default="0.05">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>double noise_threshold = 0.05; //  Parameters for noise that affects material spawn pattern<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="m_position" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int m_position = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="frames_run" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int frames_run = 0; //  to help keep the effect<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="material" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int material = 0; //  String name of material this creates<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="size.x" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 size; //  Size of the area to cover<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="size.y" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 size; //  Size of the area to cover<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="offset.x" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 offset; //  Offset of the center of the area to cover<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="offset.y" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 offset; //  Offset of the center of the area to cover<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="MaterialSuckerComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class MaterialSuckerComponent {<br>&emsp;&emsp;&emsp;&emsp;int material_type = 0; // [0, 3] 0 = liquid, 1 = sand, 2 = gas (arbitary order)<br>&emsp;&emsp;&emsp;&emsp;int barrel_size = 50; // [0, 1024] how many pixels can we suck up<br>&emsp;&emsp;&emsp;&emsp;int num_cells_sucked_per_frame = 1; // [0, 5] How many cells at max can we suck per frame?<br>&emsp;&emsp;&emsp;&emsp;bool set_projectile_to_liquid = 0; //  if set, will set the projectile what ever we're sucking...?<br>&emsp;&emsp;&emsp;&emsp;int last_material_id = 0; //  hax... this is set if we use set_projectile_to_liquid<br>&emsp;&emsp;&emsp;&emsp;bool suck_gold = 0; //  if set will just suck gold and update wallet<br>&emsp;&emsp;&emsp;&emsp;bool suck_health = 0; //  if set will just suck healthium material and add 1 hp every sucked healthium<br>&emsp;&emsp;&emsp;&emsp;bool suck_static_materials = 0; //  will suck static materials from the world<br>&emsp;&emsp;&emsp;&emsp;std::string suck_tag; //  if set, will only suck materials with this tag. NOTE, will also require the correct material_type to be set<br>&emsp;&emsp;&emsp;&emsp;int mAmountUsed = 0; //  how full are we<br>&emsp;&emsp;&emsp;&emsp;types::iaabb randomized_position; //  random offset for pos, where we look for pixels<br>&emsp;&emsp;&emsp;&emsp;int mGoldAccumulator = 0; //  accumulates amount of gold picked during consecutive frames<br>&emsp;&emsp;&emsp;&emsp;int mLastFramePickedGold = -2; //  last frame we picked gold<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="material_type" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int material_type = 0; // [0, 3] 0 = liquid, 1 = sand, 2 = gas (arbitary order)<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="barrel_size" type="xs:int" default="50">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int barrel_size = 50; // [0, 1024] how many pixels can we suck up<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="num_cells_sucked_per_frame" type="xs:int" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int num_cells_sucked_per_frame = 1; // [0, 5] How many cells at max can we suck per frame?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="set_projectile_to_liquid" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool set_projectile_to_liquid = 0; //  if set, will set the projectile what ever we're sucking...?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="last_material_id" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int last_material_id = 0; //  hax... this is set if we use set_projectile_to_liquid<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="suck_gold" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool suck_gold = 0; //  if set will just suck gold and update wallet<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="suck_health" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool suck_health = 0; //  if set will just suck healthium material and add 1 hp every sucked healthium<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="suck_static_materials" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool suck_static_materials = 0; //  will suck static materials from the world<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="suck_tag" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string suck_tag; //  if set, will only suck materials with this tag. NOTE, will also require the correct material_type to be set<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mAmountUsed" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mAmountUsed = 0; //  how full are we<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="randomized_position.min_x" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>types::iaabb randomized_position; //  random offset for pos, where we look for pixels<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="randomized_position.min_y" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>types::iaabb randomized_position; //  random offset for pos, where we look for pixels<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="randomized_position.max_x" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>types::iaabb randomized_position; //  random offset for pos, where we look for pixels<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="randomized_position.max_y" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>types::iaabb randomized_position; //  random offset for pos, where we look for pixels<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mGoldAccumulator" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mGoldAccumulator = 0; //  accumulates amount of gold picked during consecutive frames<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLastFramePickedGold" type="xs:int" default="-2">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mLastFramePickedGold = -2; //  last frame we picked gold<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="MoveToSurfaceOnCreateComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class MoveToSurfaceOnCreateComponent {<br>&emsp;&emsp;&emsp;&emsp;float lookup_radius = 64; // [0, 64] <br>&emsp;&emsp;&emsp;&emsp;float offset_from_surface = 2; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;int ray_count = 4; // [0, 8] <br>&emsp;&emsp;&emsp;&emsp;float verlet_min_joint_distance = 32; // [0, 128] <br>&emsp;&emsp;&emsp;&emsp;MOVETOSURFACE_TYPE::Enum type;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="lookup_radius" type="xs:decimal" default="64">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float lookup_radius = 64; // [0, 64] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="offset_from_surface" type="xs:decimal" default="2">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float offset_from_surface = 2; // [0, 10] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ray_count" type="xs:int" default="4">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int ray_count = 4; // [0, 8] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="verlet_min_joint_distance" type="xs:decimal" default="32">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float verlet_min_joint_distance = 32; // [0, 128] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="type" type="MOVETOSURFACE_TYPE" default="ENTITY">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>MOVETOSURFACE_TYPE::Enum type;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="MusicEnergyAffectorComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class MusicEnergyAffectorComponent {<br>&emsp;&emsp;&emsp;&emsp;float energy_target = 0.5; //  the energy this makes music go towards<br>&emsp;&emsp;&emsp;&emsp;float fade_range = 0; // [0, 256] if > 0, fade between 0 and energy_target based on distance to this entity<br>&emsp;&emsp;&emsp;&emsp;bool trigger_danger_music = 1; //  if 1, attempts to trigger danger music no matter what energy level is reached<br>&emsp;&emsp;&emsp;&emsp;int fog_of_war_threshold = 200; // [0, 255] if fog of war at position of this entity is greater than 'fog_of_war_threshold', this has  no effect<br>&emsp;&emsp;&emsp;&emsp;bool is_enemy = 1;<br>&emsp;&emsp;&emsp;&emsp;float energy_lerp_up_speed_multiplier = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="energy_target" type="xs:decimal" default="0.5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float energy_target = 0.5; //  the energy this makes music go towards<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fade_range" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float fade_range = 0; // [0, 256] if > 0, fade between 0 and energy_target based on distance to this entity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="trigger_danger_music" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool trigger_danger_music = 1; //  if 1, attempts to trigger danger music no matter what energy level is reached<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fog_of_war_threshold" type="xs:int" default="200">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int fog_of_war_threshold = 200; // [0, 255] if fog of war at position of this entity is greater than 'fog_of_war_threshold', this has  no effect<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_enemy" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_enemy = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="energy_lerp_up_speed_multiplier" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float energy_lerp_up_speed_multiplier = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="NinjaRopeComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class NinjaRopeComponent {<br>&emsp;&emsp;&emsp;&emsp;float max_length = 356; // [0, 2000] <br>&emsp;&emsp;&emsp;&emsp;float mLength = 0; // [0, 2000] <br>&emsp;&emsp;&emsp;&emsp;NINJA_ROPE_SEGMENT_VECTOR mSegments;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="max_length" type="xs:decimal" default="356">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float max_length = 356; // [0, 2000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLength" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mLength = 0; // [0, 2000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: NINJA_ROPE_SEGMENT_VECTOR for mSegments -->
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="NullDamageComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class NullDamageComponent {<br>&emsp;&emsp;&emsp;&emsp;float null_chance = 1; //  if less than 1, then will roll the die to see if it will NULL all damage. Stick this into your projectile entity<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="null_chance" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float null_chance = 1; //  if less than 1, then will roll the die to see if it will NULL all damage. Stick this into your projectile entity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="OrbComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class OrbComponent {<br>&emsp;&emsp;&emsp;&emsp;int orb_id = 0; // [0, 20] must be unique for every orb in the world<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="orb_id" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int orb_id = 0; // [0, 20] must be unique for every orb in the world<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="ParticleEmitterComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ParticleEmitterComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string emitted_material_name = "blood";<br>&emsp;&emsp;&emsp;&emsp;bool create_real_particles = 0; //  used to be emit_real_particles - creates these particles in the grid, if that happens velocity and lifetime are ignored<br>&emsp;&emsp;&emsp;&emsp;bool emit_real_particles = 0; //  this creates particles that will behave like particles, but work outside of the screen<br>&emsp;&emsp;&emsp;&emsp;bool emit_cosmetic_particles = 0; //  particle does have collisions, but no other physical interactions with the world. the particles are culled outside camera region<br>&emsp;&emsp;&emsp;&emsp;bool cosmetic_force_create = 1; //  cosmetic particles are created inside grid cells<br>&emsp;&emsp;&emsp;&emsp;bool render_back = 1; //  for cosmetic particles, if they are rendered on front or in the back...<br>&emsp;&emsp;&emsp;&emsp;bool render_ultrabright = 0; //  if 1, particles made of a glowing material will be 3x as bright as usually<br>&emsp;&emsp;&emsp;&emsp;bool collide_with_grid = 1; //  for cosmetic particles, if 1 the particles collide with grid and only exist in screen space<br>&emsp;&emsp;&emsp;&emsp;bool collide_with_gas_and_fire = 1; //  does it collide with gas and fire, works with create_real_particles and raytraced images <br>&emsp;&emsp;&emsp;&emsp;bool particle_single_width = 1; //  for cosmetic particles, forces them (gas,fire) to be only 1 pixel wide <br>&emsp;&emsp;&emsp;&emsp;bool emit_only_if_there_is_space = 0; //  This is turned for potions after they take some damage and start leaking<br>&emsp;&emsp;&emsp;&emsp;int emitter_lifetime_frames = -1; //  emitter lifetime in frames. -1 = infinite<br>&emsp;&emsp;&emsp;&emsp;bool fire_cells_dont_ignite_damagemodel = 0; //  if set, and fire cells are created, this changes their default behaviour of igniting DamageModels<br>&emsp;&emsp;&emsp;&emsp;bool color_is_based_on_pos = 0; //  if true, will get the particle color based on the world position (instead of randomizing it)<br>&emsp;&emsp;&emsp;&emsp;float custom_alpha = -1; //  if >= 0, will use this as particle alpha<br>&emsp;&emsp;&emsp;&emsp;float x_pos_offset_min = 0; // [-20, 20] <br>&emsp;&emsp;&emsp;&emsp;float y_pos_offset_min = 0; // [-20, 20] <br>&emsp;&emsp;&emsp;&emsp;float x_pos_offset_max = 0; // [-20, 20] <br>&emsp;&emsp;&emsp;&emsp;float y_pos_offset_max = 0; // [-20, 20] <br>&emsp;&emsp;&emsp;&emsp;float area_circle_sector_degrees = 360; // [0, 360] <br>&emsp;&emsp;&emsp;&emsp;float x_vel_min = 0; // [-100, 100] <br>&emsp;&emsp;&emsp;&emsp;float x_vel_max = 0; // [-100, 100] <br>&emsp;&emsp;&emsp;&emsp;float y_vel_min = 0; // [-100, 100] <br>&emsp;&emsp;&emsp;&emsp;float y_vel_max = 0; // [-100, 100] <br>&emsp;&emsp;&emsp;&emsp;float direction_random_deg = 0; // [0, 90] <br>&emsp;&emsp;&emsp;&emsp;float velocity_always_away_from_center = 0; // [-256, 256] if set, will make the velocity's rotation always away from center of randomized aabb<br>&emsp;&emsp;&emsp;&emsp;float lifetime_min = 5; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;float lifetime_max = 10; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;float airflow_force = 0; // [0, 6] <br>&emsp;&emsp;&emsp;&emsp;float airflow_time = 1; // [0, 2] <br>&emsp;&emsp;&emsp;&emsp;float airflow_scale = 1; // [0, 2] <br>&emsp;&emsp;&emsp;&emsp;float friction = 0; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;float attractor_force = 0; // [0, 100] If > 0, an attractor is created at the position of the entity that owns this component<br>&emsp;&emsp;&emsp;&emsp;int emission_interval_min_frames = 5; // [0, 120] <br>&emsp;&emsp;&emsp;&emsp;int emission_interval_max_frames = 10; // [0, 120] <br>&emsp;&emsp;&emsp;&emsp;int emission_chance = 100; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;int delay_frames = 0; //  if set will delay this many frames until starts<br>&emsp;&emsp;&emsp;&emsp;bool is_emitting = 1;<br>&emsp;&emsp;&emsp;&emsp;bool use_material_inventory = 0; //  if set, it'll use MaterialInventoryComponent as the source of the particles emitted<br>&emsp;&emsp;&emsp;&emsp;bool is_trail = 0; //  if set, will do a trail based on the previous position and current position<br>&emsp;&emsp;&emsp;&emsp;float trail_gap = 0; //  if > 0, trail particles will be generated this far from each other between our old and new position, else [count_min-count_max] particles will be generated on the line<br>&emsp;&emsp;&emsp;&emsp;bool render_on_grid = 0; //  if set, particle render positions will be snapped to cell grid<br>&emsp;&emsp;&emsp;&emsp;bool fade_based_on_lifetime = 0; //  if set, particle's position in its lifetime will determine the rendering alpha<br>&emsp;&emsp;&emsp;&emsp;bool draw_as_long = 0; //  if set, particle will rendered as a trail along it's movement vector<br>&emsp;&emsp;&emsp;&emsp;float b2_force = 0; // [0, 10] if 0 nothing happens, if 1 will apply a force to the physics body (if has one), also requires that we use the material inventory<br>&emsp;&emsp;&emsp;&emsp;bool set_magic_creation = 0; //  if set will set the magic creation 1 in the cells and do the white glow effect<br>&emsp;&emsp;&emsp;&emsp;std::string image_animation_file; //  file to use for image-based animation<br>&emsp;&emsp;&emsp;&emsp;std::string image_animation_colors_file; //  file to use for image-based animation<br>&emsp;&emsp;&emsp;&emsp;float image_animation_speed = 1; // [0, 255] how long do we stay on one frame of image-based animation. 0.5 means two game frames per one animation frame. 2.0 means two animation frames per one game frame, and so on. 0 means we always emit at time 0 of the animation.<br>&emsp;&emsp;&emsp;&emsp;bool image_animation_loop = 1; //  does image-based animation keep looping while this component is active?<br>&emsp;&emsp;&emsp;&emsp;float image_animation_phase = 0; //  the point in time [0,1] where the image-based animation will start the first cycle<br>&emsp;&emsp;&emsp;&emsp;float image_animation_emission_probability = 1; //  [0,1], probability of emitting image based particles is multiplied with this<br>&emsp;&emsp;&emsp;&emsp;bool image_animation_raytrace_from_center = 0; //  enable this to disable image_animations (from the center) going through the world<br>&emsp;&emsp;&emsp;&emsp;bool image_animation_use_entity_rotation = 0; //  if 1, image animation emission will be rotated based on entity rotation<br>&emsp;&emsp;&emsp;&emsp;bool ignore_transform_updated_msg = 0; //  if 1, mExPosition and m_last_emit_position will not be updated when receiving Message_TransformUpdated<br>&emsp;&emsp;&emsp;&emsp;uint32 color = 0;<br>&emsp;&emsp;&emsp;&emsp;vec2 offset;<br>&emsp;&emsp;&emsp;&emsp;ValueRange area_circle_radius; //  If > 0, the particles will be emitted inside a circular area defined by the min and max bounds of 'area_circle_radius'.<br>&emsp;&emsp;&emsp;&emsp;vec2 gravity;<br>&emsp;&emsp;&emsp;&emsp;LensValue<int> count_min;<br>&emsp;&emsp;&emsp;&emsp;LensValue<int> count_max;<br>&emsp;&emsp;&emsp;&emsp;PARTICLE_EMITTER_CUSTOM_STYLE::Enum custom_style; //  NONE or FIRE<br>&emsp;&emsp;&emsp;&emsp;vec2 mExPosition; //  is used with is_trail<br>&emsp;&emsp;&emsp;&emsp;int mMaterialInventoryMax = 1024; //  this is how we figure out the pressure, when using material_inventory<br>&emsp;&emsp;&emsp;&emsp;LensValue<int> m_material_id;<br>&emsp;&emsp;&emsp;&emsp;int m_next_emit_frame = 0;<br>&emsp;&emsp;&emsp;&emsp;bool m_has_emitted = 0;<br>&emsp;&emsp;&emsp;&emsp;ivec2 m_last_emit_position;<br>&emsp;&emsp;&emsp;&emsp;ParticleEmitter_Animation* m_cached_image_animation;<br>&emsp;&emsp;&emsp;&emsp;float m_image_based_animation_time = 0;<br>&emsp;&emsp;&emsp;&emsp;float* m_collision_angles;<br>&emsp;&emsp;&emsp;&emsp;int16 m_particle_attractor_id = -1;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="emitted_material_name" type="xs:string" default="blood">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string emitted_material_name = "blood";<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="create_real_particles" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool create_real_particles = 0; //  used to be emit_real_particles - creates these particles in the grid, if that happens velocity and lifetime are ignored<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="emit_real_particles" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool emit_real_particles = 0; //  this creates particles that will behave like particles, but work outside of the screen<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="emit_cosmetic_particles" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool emit_cosmetic_particles = 0; //  particle does have collisions, but no other physical interactions with the world. the particles are culled outside camera region<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="cosmetic_force_create" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool cosmetic_force_create = 1; //  cosmetic particles are created inside grid cells<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="render_back" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool render_back = 1; //  for cosmetic particles, if they are rendered on front or in the back...<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="render_ultrabright" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool render_ultrabright = 0; //  if 1, particles made of a glowing material will be 3x as bright as usually<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="collide_with_grid" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool collide_with_grid = 1; //  for cosmetic particles, if 1 the particles collide with grid and only exist in screen space<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="collide_with_gas_and_fire" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool collide_with_gas_and_fire = 1; //  does it collide with gas and fire, works with create_real_particles and raytraced images <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="particle_single_width" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool particle_single_width = 1; //  for cosmetic particles, forces them (gas,fire) to be only 1 pixel wide <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="emit_only_if_there_is_space" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool emit_only_if_there_is_space = 0; //  This is turned for potions after they take some damage and start leaking<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="emitter_lifetime_frames" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int emitter_lifetime_frames = -1; //  emitter lifetime in frames. -1 = infinite<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fire_cells_dont_ignite_damagemodel" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool fire_cells_dont_ignite_damagemodel = 0; //  if set, and fire cells are created, this changes their default behaviour of igniting DamageModels<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="color_is_based_on_pos" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool color_is_based_on_pos = 0; //  if true, will get the particle color based on the world position (instead of randomizing it)<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="custom_alpha" type="xs:decimal" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float custom_alpha = -1; //  if >= 0, will use this as particle alpha<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="x_pos_offset_min" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float x_pos_offset_min = 0; // [-20, 20] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="y_pos_offset_min" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float y_pos_offset_min = 0; // [-20, 20] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="x_pos_offset_max" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float x_pos_offset_max = 0; // [-20, 20] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="y_pos_offset_max" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float y_pos_offset_max = 0; // [-20, 20] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="area_circle_sector_degrees" type="xs:decimal" default="360">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float area_circle_sector_degrees = 360; // [0, 360] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="x_vel_min" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float x_vel_min = 0; // [-100, 100] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="x_vel_max" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float x_vel_max = 0; // [-100, 100] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="y_vel_min" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float y_vel_min = 0; // [-100, 100] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="y_vel_max" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float y_vel_max = 0; // [-100, 100] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="direction_random_deg" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float direction_random_deg = 0; // [0, 90] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="velocity_always_away_from_center" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float velocity_always_away_from_center = 0; // [-256, 256] if set, will make the velocity's rotation always away from center of randomized aabb<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lifetime_min" type="xs:decimal" default="5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float lifetime_min = 5; // [0, 10] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lifetime_max" type="xs:decimal" default="10">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float lifetime_max = 10; // [0, 10] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="airflow_force" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float airflow_force = 0; // [0, 6] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="airflow_time" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float airflow_time = 1; // [0, 2] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="airflow_scale" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float airflow_scale = 1; // [0, 2] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="friction" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float friction = 0; // [0, 10] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attractor_force" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float attractor_force = 0; // [0, 100] If > 0, an attractor is created at the position of the entity that owns this component<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="emission_interval_min_frames" type="xs:int" default="5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int emission_interval_min_frames = 5; // [0, 120] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="emission_interval_max_frames" type="xs:int" default="10">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int emission_interval_max_frames = 10; // [0, 120] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="emission_chance" type="xs:int" default="100">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int emission_chance = 100; // [0, 100] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="delay_frames" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int delay_frames = 0; //  if set will delay this many frames until starts<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_emitting" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_emitting = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="use_material_inventory" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool use_material_inventory = 0; //  if set, it'll use MaterialInventoryComponent as the source of the particles emitted<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_trail" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_trail = 0; //  if set, will do a trail based on the previous position and current position<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="trail_gap" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float trail_gap = 0; //  if > 0, trail particles will be generated this far from each other between our old and new position, else [count_min-count_max] particles will be generated on the line<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="render_on_grid" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool render_on_grid = 0; //  if set, particle render positions will be snapped to cell grid<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fade_based_on_lifetime" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool fade_based_on_lifetime = 0; //  if set, particle's position in its lifetime will determine the rendering alpha<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="draw_as_long" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool draw_as_long = 0; //  if set, particle will rendered as a trail along it's movement vector<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="b2_force" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float b2_force = 0; // [0, 10] if 0 nothing happens, if 1 will apply a force to the physics body (if has one), also requires that we use the material inventory<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="set_magic_creation" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool set_magic_creation = 0; //  if set will set the magic creation 1 in the cells and do the white glow effect<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="image_animation_file" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string image_animation_file; //  file to use for image-based animation<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="image_animation_colors_file" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string image_animation_colors_file; //  file to use for image-based animation<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="image_animation_speed" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float image_animation_speed = 1; // [0, 255] how long do we stay on one frame of image-based animation. 0.5 means two game frames per one animation frame. 2.0 means two animation frames per one game frame, and so on. 0 means we always emit at time 0 of the animation.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="image_animation_loop" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool image_animation_loop = 1; //  does image-based animation keep looping while this component is active?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="image_animation_phase" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float image_animation_phase = 0; //  the point in time [0,1] where the image-based animation will start the first cycle<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="image_animation_emission_probability" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float image_animation_emission_probability = 1; //  [0,1], probability of emitting image based particles is multiplied with this<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="image_animation_raytrace_from_center" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool image_animation_raytrace_from_center = 0; //  enable this to disable image_animations (from the center) going through the world<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="image_animation_use_entity_rotation" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool image_animation_use_entity_rotation = 0; //  if 1, image animation emission will be rotated based on entity rotation<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ignore_transform_updated_msg" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool ignore_transform_updated_msg = 0; //  if 1, mExPosition and m_last_emit_position will not be updated when receiving Message_TransformUpdated<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="color" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint32 color = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="offset.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 offset;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="offset.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 offset;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="area_circle_radius.min" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ValueRange area_circle_radius; //  If > 0, the particles will be emitted inside a circular area defined by the min and max bounds of 'area_circle_radius'.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="area_circle_radius.max" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ValueRange area_circle_radius; //  If > 0, the particles will be emitted inside a circular area defined by the min and max bounds of 'area_circle_radius'.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="gravity.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 gravity;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="gravity.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 gravity;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="count_min" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>LensValue<int> count_min;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="count_max" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>LensValue<int> count_max;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="custom_style" type="PARTICLE_EMITTER_CUSTOM_STYLE" default="NONE">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>PARTICLE_EMITTER_CUSTOM_STYLE::Enum custom_style; //  NONE or FIRE<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mExPosition.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mExPosition; //  is used with is_trail<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mExPosition.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mExPosition; //  is used with is_trail<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mMaterialInventoryMax" type="xs:int" default="1024">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mMaterialInventoryMax = 1024; //  this is how we figure out the pressure, when using material_inventory<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="m_material_id" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>LensValue<int> m_material_id;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="m_next_emit_frame" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int m_next_emit_frame = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="m_has_emitted" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool m_has_emitted = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="m_last_emit_position.x" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 m_last_emit_position;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="m_last_emit_position.y" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 m_last_emit_position;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: ParticleEmitter_Animation* for m_cached_image_animation -->
		<xs:attribute name="m_image_based_animation_time" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float m_image_based_animation_time = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: float* for m_collision_angles -->
		<xs:attribute name="m_particle_attractor_id" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int16 m_particle_attractor_id = -1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="PathFindingComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PathFindingComponent {<br>&emsp;&emsp;&emsp;&emsp;int search_depth_max_no_goal = 20; // [0, 1e+006] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;int iterations_max_no_goal = 1500; // [0, 1e+006] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;int search_depth_max_with_goal = 2500; // [0, 1e+006] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;int iterations_max_with_goal = 1500; // [0, 1e+006] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;float cost_of_flying = 20; // [0, 100000] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;int distance_to_reach_node_x = 2; // [0, 200] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;int distance_to_reach_node_y = 6; // [0, 200] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;int frames_to_get_stuck = 60; // [0, 600] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;int frames_between_searches = 30; // [0, 300] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;float y_walking_compensation = 0; // [-100, 100] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;bool can_fly = 1; //  TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;bool can_walk = 1; //  TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;bool can_jump = 0; //  TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;bool can_dive = 0; //  TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;bool can_swim_on_surface = 0; //  TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;bool never_consider_line_of_sight = 0; //  if 1, we require a path to have an entity at the goal, having line of sight to the entity is not enough<br>&emsp;&emsp;&emsp;&emsp;float space_required = 0; // [0, 20] how far (in cells) must a point on our route be from the nearest wall to consider it passable?<br>&emsp;&emsp;&emsp;&emsp;float max_jump_distance_from_camera = 400; // [0, 400] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;float jump_speed = 200; // [0, 1000] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;float initial_jump_lob = 1; // [0, 5] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;float initial_jump_max_distance_x = 100; // [0, 1000] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;float initial_jump_max_distance_y = 80; // [0, 1000] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;int read_state = 0; //  Read only value to get mState as an integer. Used to detect when the worst cheesers are trying to cheese our beloved squidward.<br>&emsp;&emsp;&emsp;&emsp;VECTOR_JUMPPARAMS jump_trajectories; //  TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;PathFindingInput input; //  TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;MSG_QUEUE_PATH_FINDING_RESULT job_result_receiver; //  TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;bool waiting_for = 0; //  TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;int next_search_frame = 0; //  TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;VECTOR_PATHNODE path; //  TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;PathFindingResultNode path_next_node; //  TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;vec2 path_next_node_vector_to; //  TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;float path_next_node_distance_to = 0; //  TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;PathFindingNodeHandle path_previous_node; //  TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;int path_frames_stuck = 0; //  TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;bool path_is_stuck = 0; //  TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;int path_last_frame_with_job = 0; //  TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;PathFindingLogic* mLogic; //  this defines what is an acceptable path<br>&emsp;&emsp;&emsp;&emsp;PathFindingLogic* mFallbackLogic; //  we use this to define an acceptable path if mLogic doesn't return one<br>&emsp;&emsp;&emsp;&emsp;PathFindingLogic* mSelectedLogic; //  TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;bool mEnabled = 0; //  TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;PathFindingComponentState::Enum mState; //  TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;int mTimesStuck = 0; //  TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;int mNextClearDontApproachListFrame = 0; //  TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;float mNodeProximityCheckCorrectionY = 0; //  TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;VECTOR_PATHNODE debug_path; //  TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> jump_velocity_multiplier; //  TODO: Comment<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="search_depth_max_no_goal" type="xs:int" default="20">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int search_depth_max_no_goal = 20; // [0, 1e+006] TODO: Comment<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="iterations_max_no_goal" type="xs:int" default="1500">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int iterations_max_no_goal = 1500; // [0, 1e+006] TODO: Comment<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="search_depth_max_with_goal" type="xs:int" default="2500">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int search_depth_max_with_goal = 2500; // [0, 1e+006] TODO: Comment<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="iterations_max_with_goal" type="xs:int" default="1500">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int iterations_max_with_goal = 1500; // [0, 1e+006] TODO: Comment<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="cost_of_flying" type="xs:decimal" default="20">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float cost_of_flying = 20; // [0, 100000] TODO: Comment<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="distance_to_reach_node_x" type="xs:int" default="2">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int distance_to_reach_node_x = 2; // [0, 200] TODO: Comment<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="distance_to_reach_node_y" type="xs:int" default="6">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int distance_to_reach_node_y = 6; // [0, 200] TODO: Comment<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="frames_to_get_stuck" type="xs:int" default="60">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int frames_to_get_stuck = 60; // [0, 600] TODO: Comment<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="frames_between_searches" type="xs:int" default="30">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int frames_between_searches = 30; // [0, 300] TODO: Comment<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="y_walking_compensation" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float y_walking_compensation = 0; // [-100, 100] TODO: Comment<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="can_fly" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool can_fly = 1; //  TODO: Comment<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="can_walk" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool can_walk = 1; //  TODO: Comment<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="can_jump" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool can_jump = 0; //  TODO: Comment<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="can_dive" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool can_dive = 0; //  TODO: Comment<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="can_swim_on_surface" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool can_swim_on_surface = 0; //  TODO: Comment<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="never_consider_line_of_sight" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool never_consider_line_of_sight = 0; //  if 1, we require a path to have an entity at the goal, having line of sight to the entity is not enough<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="space_required" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float space_required = 0; // [0, 20] how far (in cells) must a point on our route be from the nearest wall to consider it passable?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="max_jump_distance_from_camera" type="xs:decimal" default="400">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float max_jump_distance_from_camera = 400; // [0, 400] TODO: Comment<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="jump_speed" type="xs:decimal" default="200">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float jump_speed = 200; // [0, 1000] TODO: Comment<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="initial_jump_lob" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float initial_jump_lob = 1; // [0, 5] TODO: Comment<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="initial_jump_max_distance_x" type="xs:decimal" default="100">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float initial_jump_max_distance_x = 100; // [0, 1000] TODO: Comment<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="initial_jump_max_distance_y" type="xs:decimal" default="80">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float initial_jump_max_distance_y = 80; // [0, 1000] TODO: Comment<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="read_state" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int read_state = 0; //  Read only value to get mState as an integer. Used to detect when the worst cheesers are trying to cheese our beloved squidward.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: VECTOR_JUMPPARAMS for jump_trajectories -->
		<!-- Some Unknown Type: PathFindingInput for input -->
		<!-- Some Unknown Type: MSG_QUEUE_PATH_FINDING_RESULT for job_result_receiver -->
		<xs:attribute name="waiting_for" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool waiting_for = 0; //  TODO: Comment<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="next_search_frame" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int next_search_frame = 0; //  TODO: Comment<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: VECTOR_PATHNODE for path -->
		<!-- Some Unknown Type: PathFindingResultNode for path_next_node -->
		<xs:attribute name="path_next_node_vector_to.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 path_next_node_vector_to; //  TODO: Comment<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="path_next_node_vector_to.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 path_next_node_vector_to; //  TODO: Comment<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="path_next_node_distance_to" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float path_next_node_distance_to = 0; //  TODO: Comment<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: PathFindingNodeHandle for path_previous_node -->
		<xs:attribute name="path_frames_stuck" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int path_frames_stuck = 0; //  TODO: Comment<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="path_is_stuck" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool path_is_stuck = 0; //  TODO: Comment<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="path_last_frame_with_job" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int path_last_frame_with_job = 0; //  TODO: Comment<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: PathFindingLogic* for mLogic -->
		<!-- Some Unknown Type: PathFindingLogic* for mFallbackLogic -->
		<!-- Some Unknown Type: PathFindingLogic* for mSelectedLogic -->
		<xs:attribute name="mEnabled" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mEnabled = 0; //  TODO: Comment<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mState" type="PathFindingComponentState" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>PathFindingComponentState::Enum mState; //  TODO: Comment<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mTimesStuck" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mTimesStuck = 0; //  TODO: Comment<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mNextClearDontApproachListFrame" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mNextClearDontApproachListFrame = 0; //  TODO: Comment<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mNodeProximityCheckCorrectionY" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mNodeProximityCheckCorrectionY = 0; //  TODO: Comment<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: VECTOR_PATHNODE for debug_path -->
		<xs:attribute name="jump_velocity_multiplier" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>LensValue<float> jump_velocity_multiplier; //  TODO: Comment<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="PathFindingGridMarkerComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PathFindingGridMarkerComponent {<br>&emsp;&emsp;&emsp;&emsp;int marker_work_flag = 0; // [0, 255] <br>&emsp;&emsp;&emsp;&emsp;float marker_offset_x = 0; // [-1000, 1000] <br>&emsp;&emsp;&emsp;&emsp;float marker_offset_y = 0; // [-1000, 1000] <br>&emsp;&emsp;&emsp;&emsp;float player_marker_radius = 0; // [0, 128] <br>&emsp;&emsp;&emsp;&emsp;PathFindingNodeHandle mNode; //  we change the work state of this node. thus we need to keep a reference to it<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="marker_work_flag" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int marker_work_flag = 0; // [0, 255] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="marker_offset_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float marker_offset_x = 0; // [-1000, 1000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="marker_offset_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float marker_offset_y = 0; // [-1000, 1000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="player_marker_radius" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float player_marker_radius = 0; // [0, 128] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: PathFindingNodeHandle for mNode -->
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="PhysicsAIComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PhysicsAIComponent {<br>&emsp;&emsp;&emsp;&emsp;float target_vec_max_len = 5;<br>&emsp;&emsp;&emsp;&emsp;float force_coeff = 30;<br>&emsp;&emsp;&emsp;&emsp;float force_balancing_coeff = 1.5;<br>&emsp;&emsp;&emsp;&emsp;float force_max = 100;<br>&emsp;&emsp;&emsp;&emsp;float torque_coeff = 50;<br>&emsp;&emsp;&emsp;&emsp;float torque_balancing_coeff = 0.2;<br>&emsp;&emsp;&emsp;&emsp;float torque_max = 50;<br>&emsp;&emsp;&emsp;&emsp;float torque_damaged_max = 100;<br>&emsp;&emsp;&emsp;&emsp;float torque_jump_random = 0;<br>&emsp;&emsp;&emsp;&emsp;int damage_deactivation_probability = 80;<br>&emsp;&emsp;&emsp;&emsp;int damage_deactivation_time_min = 30;<br>&emsp;&emsp;&emsp;&emsp;int damage_deactivation_time_max = 60;<br>&emsp;&emsp;&emsp;&emsp;float die_on_remaining_mass_percentage = 0.3;<br>&emsp;&emsp;&emsp;&emsp;bool levitate = 1;<br>&emsp;&emsp;&emsp;&emsp;bool v0_jump_logic = 1;<br>&emsp;&emsp;&emsp;&emsp;bool v0_swim_logic = 1;<br>&emsp;&emsp;&emsp;&emsp;bool v0_body_id_logic = 1;<br>&emsp;&emsp;&emsp;&emsp;int swim_check_y_min = -2;<br>&emsp;&emsp;&emsp;&emsp;int swim_check_y_max = 2;<br>&emsp;&emsp;&emsp;&emsp;int swim_check_side_x = 4;<br>&emsp;&emsp;&emsp;&emsp;int swim_check_side_y = -2;<br>&emsp;&emsp;&emsp;&emsp;bool keep_inside_world = 1; //  fix to the bug in which the spiders spawned inside the holy mountain, if set will try not to go into places which aren't loaded <br>&emsp;&emsp;&emsp;&emsp;bool free_if_static = 0; //  set true for the boss, because box2d might turn this body into a static body, if it thinks it's glitching out. <br>&emsp;&emsp;&emsp;&emsp;float rotation_speed = 0;<br>&emsp;&emsp;&emsp;&emsp;float mStartingMass = 1;<br>&emsp;&emsp;&emsp;&emsp;bool mMainBodyFound = 0;<br>&emsp;&emsp;&emsp;&emsp;int mNextFrameActive = 0;<br>&emsp;&emsp;&emsp;&emsp;float mRotationTarget = 0;<br>&emsp;&emsp;&emsp;&emsp;vec2 mLastPositionWhenHadPath;<br>&emsp;&emsp;&emsp;&emsp;bool mHasLastPosition = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="target_vec_max_len" type="xs:decimal" default="5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float target_vec_max_len = 5;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="force_coeff" type="xs:decimal" default="30">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float force_coeff = 30;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="force_balancing_coeff" type="xs:decimal" default="1.5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float force_balancing_coeff = 1.5;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="force_max" type="xs:decimal" default="100">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float force_max = 100;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="torque_coeff" type="xs:decimal" default="50">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float torque_coeff = 50;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="torque_balancing_coeff" type="xs:decimal" default="0.2">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float torque_balancing_coeff = 0.2;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="torque_max" type="xs:decimal" default="50">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float torque_max = 50;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="torque_damaged_max" type="xs:decimal" default="100">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float torque_damaged_max = 100;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="torque_jump_random" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float torque_jump_random = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_deactivation_probability" type="xs:int" default="80">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int damage_deactivation_probability = 80;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_deactivation_time_min" type="xs:int" default="30">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int damage_deactivation_time_min = 30;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_deactivation_time_max" type="xs:int" default="60">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int damage_deactivation_time_max = 60;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="die_on_remaining_mass_percentage" type="xs:decimal" default="0.3">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float die_on_remaining_mass_percentage = 0.3;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="levitate" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool levitate = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="v0_jump_logic" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool v0_jump_logic = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="v0_swim_logic" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool v0_swim_logic = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="v0_body_id_logic" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool v0_body_id_logic = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="swim_check_y_min" type="xs:int" default="-2">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int swim_check_y_min = -2;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="swim_check_y_max" type="xs:int" default="2">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int swim_check_y_max = 2;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="swim_check_side_x" type="xs:int" default="4">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int swim_check_side_x = 4;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="swim_check_side_y" type="xs:int" default="-2">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int swim_check_side_y = -2;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="keep_inside_world" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool keep_inside_world = 1; //  fix to the bug in which the spiders spawned inside the holy mountain, if set will try not to go into places which aren't loaded <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="free_if_static" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool free_if_static = 0; //  set true for the boss, because box2d might turn this body into a static body, if it thinks it's glitching out. <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="rotation_speed" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float rotation_speed = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mStartingMass" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mStartingMass = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mMainBodyFound" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mMainBodyFound = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mNextFrameActive" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mNextFrameActive = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mRotationTarget" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mRotationTarget = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLastPositionWhenHadPath.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mLastPositionWhenHadPath;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLastPositionWhenHadPath.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mLastPositionWhenHadPath;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mHasLastPosition" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mHasLastPosition = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="PhysicsBody2Component" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PhysicsBody2Component {<br>&emsp;&emsp;&emsp;&emsp;b2ObjectID mBodyId = 0; //  this is mBody->GetBodyId() - not to be confused with uid, has to be tracked separately, since the mBody pointer is not unique<br>&emsp;&emsp;&emsp;&emsp;float linear_damping = 0;<br>&emsp;&emsp;&emsp;&emsp;float angular_damping = 0;<br>&emsp;&emsp;&emsp;&emsp;bool allow_sleep = 1;<br>&emsp;&emsp;&emsp;&emsp;bool fixed_rotation = 0;<br>&emsp;&emsp;&emsp;&emsp;bool is_bullet = 0;<br>&emsp;&emsp;&emsp;&emsp;bool is_static = 0;<br>&emsp;&emsp;&emsp;&emsp;float buoyancy = 0.7;<br>&emsp;&emsp;&emsp;&emsp;bool hax_fix_going_through_ground = 0; //  if 1, will lift the body upwards if it is inside ground<br>&emsp;&emsp;&emsp;&emsp;bool hax_fix_going_through_sand = 0; //  hax_fix_going_through_ground has to be set, if set will lift the body upwards if it is inside sand<br>&emsp;&emsp;&emsp;&emsp;bool hax_wait_till_pixel_scenes_loaded = 0;<br>&emsp;&emsp;&emsp;&emsp;bool go_through_sand = 0; //  if 1, will go through sand PhysicsBridge::mGoThroughSand = 1<br>&emsp;&emsp;&emsp;&emsp;bool auto_clean = 1; //  if 1, the simulation might destroy this body if it's hidden under sand. Problematic if you have a small piece with joint attached to something like the wheels of minecart. Set to 0 in cases like that<br>&emsp;&emsp;&emsp;&emsp;bool force_add_update_areas = 1; //  if 1, we will mark our predicted aabb as a box2d update area.<br>&emsp;&emsp;&emsp;&emsp;bool update_entity_transform = 1;<br>&emsp;&emsp;&emsp;&emsp;bool kill_entity_if_body_destroyed = 1; //  if 1, will kill the entity when physics body is destroyed<br>&emsp;&emsp;&emsp;&emsp;bool kill_entity_after_initialized = 0; //  if 1, will destroy the entity after initialization has been done based the entity's PhysicsBodyComponents and JointComponents<br>&emsp;&emsp;&emsp;&emsp;bool manual_init = 0; //  if 1, initialization occurs only when done via for example lua component and Physic2InitFromComponents()<br>&emsp;&emsp;&emsp;&emsp;bool destroy_body_if_entity_destroyed = 0; //  if 1, root body is destroyed if the entity is destroyed<br>&emsp;&emsp;&emsp;&emsp;float root_offset_x = 0; //  TODO<br>&emsp;&emsp;&emsp;&emsp;float root_offset_y = 0; //  TODO<br>&emsp;&emsp;&emsp;&emsp;float init_offset_x = 0; //  TODO<br>&emsp;&emsp;&emsp;&emsp;float init_offset_y = 0; //  TODO<br>&emsp;&emsp;&emsp;&emsp;bool mActiveState = 0; //  private variable, please don't mess around with this<br>&emsp;&emsp;&emsp;&emsp;uint32 mPixelCountOrig = 0; //  the number of pixels the body had when it was originally created<br>&emsp;&emsp;&emsp;&emsp;vec2 mLocalPosition; //  private variable, please don't mess around with this<br>&emsp;&emsp;&emsp;&emsp;b2Body* mBody;<br>&emsp;&emsp;&emsp;&emsp;bool mInitialized = 0; //  private variable, please don't mess around with this<br>&emsp;&emsp;&emsp;&emsp;uint32 mPixelCount = 0; //  if set, tracks the number of csolidcells the body has<br>&emsp;&emsp;&emsp;&emsp;bool mRefreshed = 0; //  this is sure the bodies are only parsed once<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<!-- Some Unknown Type: b2ObjectID for mBodyId -->
		<xs:attribute name="linear_damping" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float linear_damping = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="angular_damping" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float angular_damping = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="allow_sleep" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool allow_sleep = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fixed_rotation" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool fixed_rotation = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_bullet" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_bullet = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_static" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_static = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="buoyancy" type="xs:decimal" default="0.7">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float buoyancy = 0.7;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="hax_fix_going_through_ground" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool hax_fix_going_through_ground = 0; //  if 1, will lift the body upwards if it is inside ground<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="hax_fix_going_through_sand" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool hax_fix_going_through_sand = 0; //  hax_fix_going_through_ground has to be set, if set will lift the body upwards if it is inside sand<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="hax_wait_till_pixel_scenes_loaded" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool hax_wait_till_pixel_scenes_loaded = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="go_through_sand" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool go_through_sand = 0; //  if 1, will go through sand PhysicsBridge::mGoThroughSand = 1<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="auto_clean" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool auto_clean = 1; //  if 1, the simulation might destroy this body if it's hidden under sand. Problematic if you have a small piece with joint attached to something like the wheels of minecart. Set to 0 in cases like that<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="force_add_update_areas" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool force_add_update_areas = 1; //  if 1, we will mark our predicted aabb as a box2d update area.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="update_entity_transform" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool update_entity_transform = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="kill_entity_if_body_destroyed" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool kill_entity_if_body_destroyed = 1; //  if 1, will kill the entity when physics body is destroyed<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="kill_entity_after_initialized" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool kill_entity_after_initialized = 0; //  if 1, will destroy the entity after initialization has been done based the entity's PhysicsBodyComponents and JointComponents<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="manual_init" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool manual_init = 0; //  if 1, initialization occurs only when done via for example lua component and Physic2InitFromComponents()<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="destroy_body_if_entity_destroyed" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool destroy_body_if_entity_destroyed = 0; //  if 1, root body is destroyed if the entity is destroyed<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="root_offset_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float root_offset_x = 0; //  TODO<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="root_offset_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float root_offset_y = 0; //  TODO<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="init_offset_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float init_offset_x = 0; //  TODO<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="init_offset_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float init_offset_y = 0; //  TODO<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mActiveState" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mActiveState = 0; //  private variable, please don't mess around with this<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPixelCountOrig" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint32 mPixelCountOrig = 0; //  the number of pixels the body had when it was originally created<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLocalPosition.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mLocalPosition; //  private variable, please don't mess around with this<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLocalPosition.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mLocalPosition; //  private variable, please don't mess around with this<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: b2Body* for mBody -->
		<xs:attribute name="mInitialized" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mInitialized = 0; //  private variable, please don't mess around with this<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPixelCount" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint32 mPixelCount = 0; //  if set, tracks the number of csolidcells the body has<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mRefreshed" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mRefreshed = 0; //  this is sure the bodies are only parsed once<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="PhysicsBodyCollisionDamageComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PhysicsBodyCollisionDamageComponent {<br>&emsp;&emsp;&emsp;&emsp;float speed_threshold = 60; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;float damage_multiplier = 0.016667;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="speed_threshold" type="xs:decimal" default="60">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float speed_threshold = 60; // [0, 100] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_multiplier" type="xs:decimal" default="0.016667">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float damage_multiplier = 0.016667;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="PhysicsBodyComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PhysicsBodyComponent {<br>&emsp;&emsp;&emsp;&emsp;bool is_external = 0; //  if mBody is set from outside, will ignore all the things<br>&emsp;&emsp;&emsp;&emsp;bool hax_fix_going_through_ground = 0; //  if set will lift the body upwards if it is inside ground<br>&emsp;&emsp;&emsp;&emsp;bool hax_fix_going_through_sand = 0; //  hax_fix_going_through_ground has to be set, if set will lift the body upwards if it is inside sand<br>&emsp;&emsp;&emsp;&emsp;bool hax_wait_till_pixel_scenes_loaded = 0;<br>&emsp;&emsp;&emsp;&emsp;int uid = 0; // [0, 1000] if the entity has multiple physics bodies and has specific shapes for those and possible joints, you should use this. 0 is default for shapes<br>&emsp;&emsp;&emsp;&emsp;bool is_enabled = 1; //  Use this to kill the physics body of. if is_enabled is set to false, will destroy the physics body<br>&emsp;&emsp;&emsp;&emsp;float linear_damping = 0;<br>&emsp;&emsp;&emsp;&emsp;float angular_damping = 0;<br>&emsp;&emsp;&emsp;&emsp;bool allow_sleep = 1;<br>&emsp;&emsp;&emsp;&emsp;bool fixed_rotation = 0;<br>&emsp;&emsp;&emsp;&emsp;float buoyancy = 0.7;<br>&emsp;&emsp;&emsp;&emsp;float gravity_scale_if_has_no_image_shapes = 1;<br>&emsp;&emsp;&emsp;&emsp;bool is_bullet = 0;<br>&emsp;&emsp;&emsp;&emsp;bool is_static = 0;<br>&emsp;&emsp;&emsp;&emsp;bool is_kinematic = 0;<br>&emsp;&emsp;&emsp;&emsp;bool is_character = 0; //  if it is a character, then we need to few interesting things from time to time<br>&emsp;&emsp;&emsp;&emsp;bool go_through_sand = 0; //  if set, will go through sand PhysicsBridge::mGoThroughSand = 1<br>&emsp;&emsp;&emsp;&emsp;bool gridworld_box2d = 1; //  default is 1. You should only change this if you know the body isn't going to touch gridworld<br>&emsp;&emsp;&emsp;&emsp;bool auto_clean = 1; //  if set, the simulation might destroy this body if it's hidden under sand. Problematic if you have a small piece with joint attached to something like the wheels of minecart. Set to 0 in cases like that<br>&emsp;&emsp;&emsp;&emsp;bool on_death_leave_physics_body = 0; //  if set, will leave the b2body into the world, even if the entity is killed<br>&emsp;&emsp;&emsp;&emsp;bool on_death_really_leave_body = 0; //  camera bound... god damn... we need something special when we want to leave the body<br>&emsp;&emsp;&emsp;&emsp;bool update_entity_transform = 1; //  WARNING! Don't touch this unless you know what you're doing. If false, doesn't update the entitys transform to match the physics body. This is used with multi body entities, to use the correct body to update the entity, e.g. minecart<br>&emsp;&emsp;&emsp;&emsp;bool force_add_update_areas = 0; //  if 1, we will mark our predicted aabb as a box2d update area.<br>&emsp;&emsp;&emsp;&emsp;bool kills_entity = 1; //  if set, will kill the entity when physics body is destroyed<br>&emsp;&emsp;&emsp;&emsp;bool projectiles_rotate_toward_velocity = 0; //  for physics projectiles, if true will initially rotate the body based on the velocity<br>&emsp;&emsp;&emsp;&emsp;bool randomize_init_velocity = 0; //  randomizes the init velocity<br>&emsp;&emsp;&emsp;&emsp;bool mActiveState = 0; //  private variable, please don't mess around with this<br>&emsp;&emsp;&emsp;&emsp;vec2 initial_velocity; //  if you want a velocity at the start, set it here<br>&emsp;&emsp;&emsp;&emsp;b2Body* mBody;<br>&emsp;&emsp;&emsp;&emsp;b2ObjectID mBodyId = 0; //  this is mBody->GetBodyId() - not to be confused with uid shit, has to be tracked separately, since the mBody pointer is not unique<br>&emsp;&emsp;&emsp;&emsp;int mPixelCount = 0; //  if set, tracks the number of csolidcells the body has<br>&emsp;&emsp;&emsp;&emsp;b2Vec2 mLocalPosition;<br>&emsp;&emsp;&emsp;&emsp;bool mRefreshed = 0; //  this is sure the bodies are only parsed once<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="is_external" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_external = 0; //  if mBody is set from outside, will ignore all the things<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="hax_fix_going_through_ground" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool hax_fix_going_through_ground = 0; //  if set will lift the body upwards if it is inside ground<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="hax_fix_going_through_sand" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool hax_fix_going_through_sand = 0; //  hax_fix_going_through_ground has to be set, if set will lift the body upwards if it is inside sand<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="hax_wait_till_pixel_scenes_loaded" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool hax_wait_till_pixel_scenes_loaded = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="uid" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int uid = 0; // [0, 1000] if the entity has multiple physics bodies and has specific shapes for those and possible joints, you should use this. 0 is default for shapes<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_enabled" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_enabled = 1; //  Use this to kill the physics body of. if is_enabled is set to false, will destroy the physics body<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="linear_damping" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float linear_damping = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="angular_damping" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float angular_damping = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="allow_sleep" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool allow_sleep = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fixed_rotation" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool fixed_rotation = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="buoyancy" type="xs:decimal" default="0.7">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float buoyancy = 0.7;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="gravity_scale_if_has_no_image_shapes" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float gravity_scale_if_has_no_image_shapes = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_bullet" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_bullet = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_static" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_static = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_kinematic" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_kinematic = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_character" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_character = 0; //  if it is a character, then we need to few interesting things from time to time<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="go_through_sand" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool go_through_sand = 0; //  if set, will go through sand PhysicsBridge::mGoThroughSand = 1<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="gridworld_box2d" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool gridworld_box2d = 1; //  default is 1. You should only change this if you know the body isn't going to touch gridworld<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="auto_clean" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool auto_clean = 1; //  if set, the simulation might destroy this body if it's hidden under sand. Problematic if you have a small piece with joint attached to something like the wheels of minecart. Set to 0 in cases like that<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="on_death_leave_physics_body" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool on_death_leave_physics_body = 0; //  if set, will leave the b2body into the world, even if the entity is killed<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="on_death_really_leave_body" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool on_death_really_leave_body = 0; //  camera bound... god damn... we need something special when we want to leave the body<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="update_entity_transform" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool update_entity_transform = 1; //  WARNING! Don't touch this unless you know what you're doing. If false, doesn't update the entitys transform to match the physics body. This is used with multi body entities, to use the correct body to update the entity, e.g. minecart<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="force_add_update_areas" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool force_add_update_areas = 0; //  if 1, we will mark our predicted aabb as a box2d update area.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="kills_entity" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool kills_entity = 1; //  if set, will kill the entity when physics body is destroyed<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="projectiles_rotate_toward_velocity" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool projectiles_rotate_toward_velocity = 0; //  for physics projectiles, if true will initially rotate the body based on the velocity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="randomize_init_velocity" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool randomize_init_velocity = 0; //  randomizes the init velocity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mActiveState" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mActiveState = 0; //  private variable, please don't mess around with this<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="initial_velocity.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 initial_velocity; //  if you want a velocity at the start, set it here<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="initial_velocity.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 initial_velocity; //  if you want a velocity at the start, set it here<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: b2Body* for mBody -->
		<!-- Some Unknown Type: b2ObjectID for mBodyId -->
		<xs:attribute name="mPixelCount" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mPixelCount = 0; //  if set, tracks the number of csolidcells the body has<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: b2Vec2 for mLocalPosition -->
		<xs:attribute name="mRefreshed" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mRefreshed = 0; //  this is sure the bodies are only parsed once<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="PhysicsImageShapeComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PhysicsImageShapeComponent {<br>&emsp;&emsp;&emsp;&emsp;bool is_root = 0; //  if 1, PhysicsBody2Component will use this to figure out where the entity is located<br>&emsp;&emsp;&emsp;&emsp;int body_id = 0; // [0, 1000] used to figure out which bodies are attached to each other when creating joints<br>&emsp;&emsp;&emsp;&emsp;bool use_sprite = 0; //  will try to find the SpriteComponent and use that<br>&emsp;&emsp;&emsp;&emsp;bool is_circle = 0; //  tries to fit this into a circle, looks at bounding box of the pixels and sets the circle to the center of that with radius being the line from there to a straight edge<br>&emsp;&emsp;&emsp;&emsp;bool centered = 0; //  if this is true, moves offset to be in the center of the image, overwrites the offset_x, offset_y<br>&emsp;&emsp;&emsp;&emsp;float offset_x = 0; //  offset x in pixels<br>&emsp;&emsp;&emsp;&emsp;float offset_y = 0; //  offset y in pixels<br>&emsp;&emsp;&emsp;&emsp;float z = 0; //  offset in the z direction<br>&emsp;&emsp;&emsp;&emsp;std::string image_file; //  the png file from which the body is created from<br>&emsp;&emsp;&emsp;&emsp;int material = 0; //  the material from which the body is created<br>&emsp;&emsp;&emsp;&emsp;b2Body* mBody; //  used in joint creation phase<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="is_root" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_root = 0; //  if 1, PhysicsBody2Component will use this to figure out where the entity is located<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="body_id" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int body_id = 0; // [0, 1000] used to figure out which bodies are attached to each other when creating joints<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="use_sprite" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool use_sprite = 0; //  will try to find the SpriteComponent and use that<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_circle" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_circle = 0; //  tries to fit this into a circle, looks at bounding box of the pixels and sets the circle to the center of that with radius being the line from there to a straight edge<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="centered" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool centered = 0; //  if this is true, moves offset to be in the center of the image, overwrites the offset_x, offset_y<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="offset_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float offset_x = 0; //  offset x in pixels<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="offset_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float offset_y = 0; //  offset y in pixels<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="z" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float z = 0; //  offset in the z direction<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="image_file" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string image_file; //  the png file from which the body is created from<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="material" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int material = 0; //  the material from which the body is created<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: b2Body* for mBody -->
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="PhysicsJoint2Component" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PhysicsJoint2Component {<br>&emsp;&emsp;&emsp;&emsp;uint16 joint_id = 0; // [0, 1000] Use this to create a relation between PhysicsJointMutator and a joint. The PhysicsJointMutator must exist when the physics objects are initialized for the first time. This id should be unique inside one entity. Defaults to 0<br>&emsp;&emsp;&emsp;&emsp;float break_force = 1.3; //  if > 0, will break if theres a force too strong.<br>&emsp;&emsp;&emsp;&emsp;float break_distance = 1.4142; //  if > 0, will break if the anchors on the bodies get further than this.<br>&emsp;&emsp;&emsp;&emsp;bool break_on_body_modified = 0; //  if > 1, will break if an attached body is modified<br>&emsp;&emsp;&emsp;&emsp;float break_on_shear_angle_deg = 0; //  if > 0, will break if the angle between the linked bodies becomes greater than this<br>&emsp;&emsp;&emsp;&emsp;int body1_id = 0;<br>&emsp;&emsp;&emsp;&emsp;int body2_id = 0;<br>&emsp;&emsp;&emsp;&emsp;float offset_x = 0;<br>&emsp;&emsp;&emsp;&emsp;float offset_y = 0;<br>&emsp;&emsp;&emsp;&emsp;float ray_x = 0;<br>&emsp;&emsp;&emsp;&emsp;float ray_y = -10;<br>&emsp;&emsp;&emsp;&emsp;float surface_attachment_offset_x = 0;<br>&emsp;&emsp;&emsp;&emsp;float surface_attachment_offset_y = 2.5;<br>&emsp;&emsp;&emsp;&emsp;JOINT_TYPE::Enum type; //  Enum - REVOLUTE_JOINT, WELD_JOINT, REVOLUTE_JOINT_ATTACH_TO_NEARBY_SURFACE or WELD_JOINT_ATTACH_TO_NEARBY_SURFACE<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="joint_id" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint16 joint_id = 0; // [0, 1000] Use this to create a relation between PhysicsJointMutator and a joint. The PhysicsJointMutator must exist when the physics objects are initialized for the first time. This id should be unique inside one entity. Defaults to 0<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="break_force" type="xs:decimal" default="1.3">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float break_force = 1.3; //  if > 0, will break if theres a force too strong.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="break_distance" type="xs:decimal" default="1.4142">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float break_distance = 1.4142; //  if > 0, will break if the anchors on the bodies get further than this.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="break_on_body_modified" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool break_on_body_modified = 0; //  if > 1, will break if an attached body is modified<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="break_on_shear_angle_deg" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float break_on_shear_angle_deg = 0; //  if > 0, will break if the angle between the linked bodies becomes greater than this<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="body1_id" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int body1_id = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="body2_id" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int body2_id = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="offset_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float offset_x = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="offset_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float offset_y = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ray_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float ray_x = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ray_y" type="xs:decimal" default="-10">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float ray_y = -10;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="surface_attachment_offset_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float surface_attachment_offset_x = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="surface_attachment_offset_y" type="xs:decimal" default="2.5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float surface_attachment_offset_y = 2.5;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="type" type="JOINT_TYPE" default="REVOLUTE_JOINT">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>JOINT_TYPE::Enum type; //  Enum - REVOLUTE_JOINT, WELD_JOINT, REVOLUTE_JOINT_ATTACH_TO_NEARBY_SURFACE or WELD_JOINT_ATTACH_TO_NEARBY_SURFACE<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="PhysicsJoint2MutatorComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PhysicsJoint2MutatorComponent {<br>&emsp;&emsp;&emsp;&emsp;uint16 joint_id = 0; // [0, 1000] Use this to create a relation between PhysicsJointMutator and a joint created by PhysicsJoint2Component. The PhysicsJoint2Mutator must exist when the physics objects are initialized for the first time.<br>&emsp;&emsp;&emsp;&emsp;bool destroy = 0; //  if 1, the joint will break and this component will be destroyed.<br>&emsp;&emsp;&emsp;&emsp;float motor_speed = 0; //  if != 0 and this is linked to a revolute joint, the joint motor will be enabled at this speed<br>&emsp;&emsp;&emsp;&emsp;float motor_max_torque = 1; //  max torque for motor<br>&emsp;&emsp;&emsp;&emsp;uint64 mBox2DJointId = 0; //  Private, don't touch this! Stores the joint's id in the physics engine.<br>&emsp;&emsp;&emsp;&emsp;float mPreviousMotorSpeed = 0;<br>&emsp;&emsp;&emsp;&emsp;float mPreviousMotorMaxTorque = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="joint_id" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint16 joint_id = 0; // [0, 1000] Use this to create a relation between PhysicsJointMutator and a joint created by PhysicsJoint2Component. The PhysicsJoint2Mutator must exist when the physics objects are initialized for the first time.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="destroy" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool destroy = 0; //  if 1, the joint will break and this component will be destroyed.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="motor_speed" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float motor_speed = 0; //  if != 0 and this is linked to a revolute joint, the joint motor will be enabled at this speed<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="motor_max_torque" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float motor_max_torque = 1; //  max torque for motor<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mBox2DJointId" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint64 mBox2DJointId = 0; //  Private, don't touch this! Stores the joint's id in the physics engine.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPreviousMotorSpeed" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mPreviousMotorSpeed = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPreviousMotorMaxTorque" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mPreviousMotorMaxTorque = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="PhysicsJointComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PhysicsJointComponent {<br>&emsp;&emsp;&emsp;&emsp;bool nail_to_wall = 0;<br>&emsp;&emsp;&emsp;&emsp;bool grid_joint = 0; //  if 1, will do a grid joint that works correctly with a body when it is destroyed / chipped away<br>&emsp;&emsp;&emsp;&emsp;bool breakable = 0; //  if 1, will break if theres a force too strong<br>&emsp;&emsp;&emsp;&emsp;int body1_id = 0;<br>&emsp;&emsp;&emsp;&emsp;int body2_id = 0;<br>&emsp;&emsp;&emsp;&emsp;float pos_x = 0; // [0, 3.5] <br>&emsp;&emsp;&emsp;&emsp;float pos_y = 0; // [0, 3.5] <br>&emsp;&emsp;&emsp;&emsp;float delta_x = 0; // [-10, 10] For mouse joint only ... moves the mouse joint by *dt <br>&emsp;&emsp;&emsp;&emsp;float delta_y = 0; // [-10, 10] For mouse joint only ... moves the mouse joint by *dt <br>&emsp;&emsp;&emsp;&emsp;bool mMotorEnabled = 0; //  enable motor, by setting this to true<br>&emsp;&emsp;&emsp;&emsp;float mMotorSpeed = 0; // [0, 20] if enabled this gets set to speed<br>&emsp;&emsp;&emsp;&emsp;float mMaxMotorTorque = 1; //  max torque for motor<br>&emsp;&emsp;&emsp;&emsp;JOINT_TYPE::Enum type; //  Enum - JOINT_TYPE<br>&emsp;&emsp;&emsp;&emsp;b2Joint* mJoint;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="nail_to_wall" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool nail_to_wall = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="grid_joint" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool grid_joint = 0; //  if 1, will do a grid joint that works correctly with a body when it is destroyed / chipped away<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="breakable" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool breakable = 0; //  if 1, will break if theres a force too strong<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="body1_id" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int body1_id = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="body2_id" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int body2_id = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="pos_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float pos_x = 0; // [0, 3.5] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="pos_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float pos_y = 0; // [0, 3.5] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="delta_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float delta_x = 0; // [-10, 10] For mouse joint only ... moves the mouse joint by *dt <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="delta_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float delta_y = 0; // [-10, 10] For mouse joint only ... moves the mouse joint by *dt <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mMotorEnabled" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mMotorEnabled = 0; //  enable motor, by setting this to true<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mMotorSpeed" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mMotorSpeed = 0; // [0, 20] if enabled this gets set to speed<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mMaxMotorTorque" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mMaxMotorTorque = 1; //  max torque for motor<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="type" type="JOINT_TYPE" default="REVOLUTE_JOINT">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>JOINT_TYPE::Enum type; //  Enum - JOINT_TYPE<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: b2Joint* for mJoint -->
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="PhysicsKeepInWorldComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PhysicsKeepInWorldComponent {<br>&emsp;&emsp;&emsp;&emsp;bool check_whole_aabb = 0; //  All that is needed is to include one of the components with PhysicsBodyComponent or PhysicsBody2Component and it will be frozen when it hits outer edges of the world. NOTE! This will override the auto_clean variable, auto_clean will be set to false. If this is true, will check all the 4 corners of the bounding box<br>&emsp;&emsp;&emsp;&emsp;bool predict_aabb = 0; //  Will add the velocity * 1.5 to the aabb to predict where the body will end up at. This will greatly help keep the body inside simulated world.<br>&emsp;&emsp;&emsp;&emsp;bool keep_at_last_valid_pos = 0; //  Will try to keep the object at the latest valid position<br>&emsp;&emsp;&emsp;&emsp;vec2 mExPosition;<br>&emsp;&emsp;&emsp;&emsp;float mExRotation = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="check_whole_aabb" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool check_whole_aabb = 0; //  All that is needed is to include one of the components with PhysicsBodyComponent or PhysicsBody2Component and it will be frozen when it hits outer edges of the world. NOTE! This will override the auto_clean variable, auto_clean will be set to false. If this is true, will check all the 4 corners of the bounding box<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="predict_aabb" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool predict_aabb = 0; //  Will add the velocity * 1.5 to the aabb to predict where the body will end up at. This will greatly help keep the body inside simulated world.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="keep_at_last_valid_pos" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool keep_at_last_valid_pos = 0; //  Will try to keep the object at the latest valid position<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mExPosition.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mExPosition;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mExPosition.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mExPosition;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mExRotation" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mExRotation = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="PhysicsPickUpComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PhysicsPickUpComponent {<br>&emsp;&emsp;&emsp;&emsp;float pick_up_strength = 200;<br>&emsp;&emsp;&emsp;&emsp;types::xform transform;<br>&emsp;&emsp;&emsp;&emsp;vec2 original_left_joint_pos;<br>&emsp;&emsp;&emsp;&emsp;vec2 original_right_joint_pos;<br>&emsp;&emsp;&emsp;&emsp;bool isBroken = 0;<br>&emsp;&emsp;&emsp;&emsp;vec2 leftJointPos;<br>&emsp;&emsp;&emsp;&emsp;vec2 rightJointPos;<br>&emsp;&emsp;&emsp;&emsp;b2WeldJoint* leftJoint;<br>&emsp;&emsp;&emsp;&emsp;b2WeldJoint* rightJoint;<br>};<br>```]]> </xs:documentation> </xs:annotation>
			<xs:all>
				<xs:element name="transform" type="Transform" minOccurs="0"/>
			</xs:all>
		<xs:attribute name="pick_up_strength" type="xs:decimal" default="200">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float pick_up_strength = 200;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="original_left_joint_pos.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 original_left_joint_pos;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="original_left_joint_pos.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 original_left_joint_pos;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="original_right_joint_pos.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 original_right_joint_pos;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="original_right_joint_pos.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 original_right_joint_pos;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="isBroken" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool isBroken = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="leftJointPos.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 leftJointPos;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="leftJointPos.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 leftJointPos;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="rightJointPos.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 rightJointPos;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="rightJointPos.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 rightJointPos;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: b2WeldJoint* for leftJoint -->
		<!-- Some Unknown Type: b2WeldJoint* for rightJoint -->
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="PhysicsRagdollComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PhysicsRagdollComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string filename; //  file that should include just a list of other files, that have all the parts<br>&emsp;&emsp;&emsp;&emsp;std::string filenames; //  a list of body parts as png images, separate the files by ','. e.g. 'data/temp/ragdoll/leg.png, data/temp/ragdoll/head.png,...'<br>&emsp;&emsp;&emsp;&emsp;float offset_x = 0; // [0, 20] offset of where the ragdoll will be created<br>&emsp;&emsp;&emsp;&emsp;float offset_y = 0; // [0, 20] offset of where the ragdoll will be created<br>&emsp;&emsp;&emsp;&emsp;std::vector<b2Body*>* bodies;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="filename" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string filename; //  file that should include just a list of other files, that have all the parts<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="filenames" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string filenames; //  a list of body parts as png images, separate the files by ','. e.g. 'data/temp/ragdoll/leg.png, data/temp/ragdoll/head.png,...'<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="offset_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float offset_x = 0; // [0, 20] offset of where the ragdoll will be created<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="offset_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float offset_y = 0; // [0, 20] offset of where the ragdoll will be created<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: std::vector<b2Body*>* for bodies -->
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="PhysicsShapeComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PhysicsShapeComponent {<br>&emsp;&emsp;&emsp;&emsp;bool recreate = 0;<br>&emsp;&emsp;&emsp;&emsp;bool is_circle = 0;<br>&emsp;&emsp;&emsp;&emsp;bool is_box = 1;<br>&emsp;&emsp;&emsp;&emsp;bool is_capsule = 0;<br>&emsp;&emsp;&emsp;&emsp;bool is_based_on_sprite = 0; //  if set, will use sprite component to figure out a box that fits this<br>&emsp;&emsp;&emsp;&emsp;float friction = 0.75;<br>&emsp;&emsp;&emsp;&emsp;float restitution = 0.1;<br>&emsp;&emsp;&emsp;&emsp;float density = 0.75; // [0, 5] <br>&emsp;&emsp;&emsp;&emsp;float local_position_x = 0; // [-5, 5] <br>&emsp;&emsp;&emsp;&emsp;float local_position_y = 0; // [-5, 5] <br>&emsp;&emsp;&emsp;&emsp;float radius_x = 1; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;float radius_y = 1; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;float capsule_x_percent = 0.25;<br>&emsp;&emsp;&emsp;&emsp;float capsule_y_percent = 0.3;<br>&emsp;&emsp;&emsp;&emsp;int material = 0; //  the material to use for collision audio<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="recreate" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool recreate = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_circle" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_circle = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_box" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_box = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_capsule" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_capsule = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_based_on_sprite" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_based_on_sprite = 0; //  if set, will use sprite component to figure out a box that fits this<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="friction" type="xs:decimal" default="0.75">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float friction = 0.75;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="restitution" type="xs:decimal" default="0.1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float restitution = 0.1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="density" type="xs:decimal" default="0.75">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float density = 0.75; // [0, 5] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="local_position_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float local_position_x = 0; // [-5, 5] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="local_position_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float local_position_y = 0; // [-5, 5] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="radius_x" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float radius_x = 1; // [0, 10] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="radius_y" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float radius_y = 1; // [0, 10] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="capsule_x_percent" type="xs:decimal" default="0.25">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float capsule_x_percent = 0.25;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="capsule_y_percent" type="xs:decimal" default="0.3">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float capsule_y_percent = 0.3;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="material" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int material = 0; //  the material to use for collision audio<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="PhysicsThrowableComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PhysicsThrowableComponent {<br>&emsp;&emsp;&emsp;&emsp;float throw_force_coeff = 1; // [0, 2] <br>&emsp;&emsp;&emsp;&emsp;float max_throw_speed = 180; // [0, 256] <br>&emsp;&emsp;&emsp;&emsp;float min_torque = 0.5; // [0, 20] <br>&emsp;&emsp;&emsp;&emsp;float max_torque = 8; // [0, 20] <br>&emsp;&emsp;&emsp;&emsp;float tip_check_offset_min = 3; // [0, 20] <br>&emsp;&emsp;&emsp;&emsp;float tip_check_offset_max = 5; // [0, 20] <br>&emsp;&emsp;&emsp;&emsp;float tip_check_random_rotation_deg = 9; // [0, 180] <br>&emsp;&emsp;&emsp;&emsp;float attach_min_speed = 70; // [0, 180] <br>&emsp;&emsp;&emsp;&emsp;bool attach_to_surfaces_knife_style = 0;<br>&emsp;&emsp;&emsp;&emsp;int hp = 100; // [0, 200] WIP WIP<br>&emsp;&emsp;&emsp;&emsp;bool mHasJoint = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="throw_force_coeff" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float throw_force_coeff = 1; // [0, 2] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="max_throw_speed" type="xs:decimal" default="180">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float max_throw_speed = 180; // [0, 256] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="min_torque" type="xs:decimal" default="0.5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float min_torque = 0.5; // [0, 20] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="max_torque" type="xs:decimal" default="8">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float max_torque = 8; // [0, 20] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="tip_check_offset_min" type="xs:decimal" default="3">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float tip_check_offset_min = 3; // [0, 20] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="tip_check_offset_max" type="xs:decimal" default="5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float tip_check_offset_max = 5; // [0, 20] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="tip_check_random_rotation_deg" type="xs:decimal" default="9">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float tip_check_random_rotation_deg = 9; // [0, 180] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attach_min_speed" type="xs:decimal" default="70">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float attach_min_speed = 70; // [0, 180] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attach_to_surfaces_knife_style" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool attach_to_surfaces_knife_style = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="hp" type="xs:int" default="100">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int hp = 100; // [0, 200] WIP WIP<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mHasJoint" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mHasJoint = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="PixelSceneComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PixelSceneComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string pixel_scene; //  loads this pixel scene file<br>&emsp;&emsp;&emsp;&emsp;std::string pixel_scene_visual; //  this is the colors that get used for the pixels, if empty will use material colors<br>&emsp;&emsp;&emsp;&emsp;std::string pixel_scene_background; //  this is the background file that gets loaded, if empty won't do anything<br>&emsp;&emsp;&emsp;&emsp;int background_z_index = 50; //  the standard z_index of pixel scene backgrounds<br>&emsp;&emsp;&emsp;&emsp;float offset_x = 0; // [-30, 30] how much off from the entity x,y will this be. Top left corner is where it loads the pixel scene<br>&emsp;&emsp;&emsp;&emsp;float offset_y = 0; // [-30, 30] <br>&emsp;&emsp;&emsp;&emsp;bool skip_biome_checks = 0; //  biome check is on by default - it will check that pixel scene is loaded so that every corner is in the same biome<br>&emsp;&emsp;&emsp;&emsp;bool skip_edge_textures = 0; //  if on - won't do the edge textures for the pixel scene<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="pixel_scene" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string pixel_scene; //  loads this pixel scene file<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="pixel_scene_visual" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string pixel_scene_visual; //  this is the colors that get used for the pixels, if empty will use material colors<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="pixel_scene_background" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string pixel_scene_background; //  this is the background file that gets loaded, if empty won't do anything<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="background_z_index" type="xs:int" default="50">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int background_z_index = 50; //  the standard z_index of pixel scene backgrounds<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="offset_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float offset_x = 0; // [-30, 30] how much off from the entity x,y will this be. Top left corner is where it loads the pixel scene<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="offset_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float offset_y = 0; // [-30, 30] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="skip_biome_checks" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool skip_biome_checks = 0; //  biome check is on by default - it will check that pixel scene is loaded so that every corner is in the same biome<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="skip_edge_textures" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool skip_edge_textures = 0; //  if on - won't do the edge textures for the pixel scene<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="PixelSpriteComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PixelSpriteComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string image_file; //  loads pixelsprite based on this file<br>&emsp;&emsp;&emsp;&emsp;int anchor_x = 0; // [0, 3.5] the anchor and center_offset<br>&emsp;&emsp;&emsp;&emsp;int anchor_y = 0; // [0, 3.5] the anchor and center_offset<br>&emsp;&emsp;&emsp;&emsp;std::string material = "wood_loose"; //  what's the material that things are made out of, TODO - change this into MetaCustom<br>&emsp;&emsp;&emsp;&emsp;bool diggable = 1; //  if 1, this can be broken with digger<br>&emsp;&emsp;&emsp;&emsp;bool clean_overlapping_pixels = 1; //  cleans up the pixels that are ovelapping in the world<br>&emsp;&emsp;&emsp;&emsp;bool kill_when_sprite_dies = 1; //  kills the entity, if the pixel sprite is dead (empty)<br>&emsp;&emsp;&emsp;&emsp;bool create_box2d_bodies = 0; //  if true, will create new pixel sprites with box2d bodies, instead of gridworld cells<br>&emsp;&emsp;&emsp;&emsp;PixelSprite* mPixelSprite;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="image_file" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string image_file; //  loads pixelsprite based on this file<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="anchor_x" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int anchor_x = 0; // [0, 3.5] the anchor and center_offset<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="anchor_y" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int anchor_y = 0; // [0, 3.5] the anchor and center_offset<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="material" type="xs:string" default="wood_loose">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string material = "wood_loose"; //  what's the material that things are made out of, TODO - change this into MetaCustom<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="diggable" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool diggable = 1; //  if 1, this can be broken with digger<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="clean_overlapping_pixels" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool clean_overlapping_pixels = 1; //  cleans up the pixels that are ovelapping in the world<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="kill_when_sprite_dies" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool kill_when_sprite_dies = 1; //  kills the entity, if the pixel sprite is dead (empty)<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="create_box2d_bodies" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool create_box2d_bodies = 0; //  if true, will create new pixel sprites with box2d bodies, instead of gridworld cells<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: PixelSprite* for mPixelSprite -->
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="PlatformShooterPlayerComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PlatformShooterPlayerComponent {<br>&emsp;&emsp;&emsp;&emsp;float aiming_reticle_distance_from_character = 40; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;float camera_max_distance_from_character = 25; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;float alcohol_drunken_speed = 0.005; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;float blood_fungi_drunken_speed = 0.006; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;float blood_worm_drunken_speed = 0.006; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;int eating_cells_per_frame = 1; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;int eating_probability = 5; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;int eating_delay_frames = 30; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;float stoned_speed = 0.1; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;bool center_camera_on_this_entity = 1;<br>&emsp;&emsp;&emsp;&emsp;bool move_camera_with_aim = 1; //  if true, moves camera with the aim.<br>&emsp;&emsp;&emsp;&emsp;ivec2 eating_area_min;<br>&emsp;&emsp;&emsp;&emsp;ivec2 eating_area_max;<br>&emsp;&emsp;&emsp;&emsp;vec2 mSmoothedCameraPosition;<br>&emsp;&emsp;&emsp;&emsp;vec2 mSmoothedAimingVector;<br>&emsp;&emsp;&emsp;&emsp;float mCameraRecoil = 0;<br>&emsp;&emsp;&emsp;&emsp;float mCameraRecoilTarget = 0;<br>&emsp;&emsp;&emsp;&emsp;bool mCrouching = 0;<br>&emsp;&emsp;&emsp;&emsp;float mCameraDistanceLerped = 0;<br>&emsp;&emsp;&emsp;&emsp;bool mRequireTriggerPull = 0;<br>&emsp;&emsp;&emsp;&emsp;int mWarpDelay = 0;<br>&emsp;&emsp;&emsp;&emsp;int mItemTemporarilyHidden = 0;<br>&emsp;&emsp;&emsp;&emsp;vec2 mDesiredCameraPos;<br>&emsp;&emsp;&emsp;&emsp;bool mHasGamepadControlsPrev = 0;<br>&emsp;&emsp;&emsp;&emsp;bool mForceFireOnNextUpdate = 0;<br>&emsp;&emsp;&emsp;&emsp;float mFastMovementParticlesAlphaSmoothed = 0;<br>&emsp;&emsp;&emsp;&emsp;uint64 mTeleBoltFramesDuringLastSecond = 0;<br>&emsp;&emsp;&emsp;&emsp;float mCamCorrectionTeleSmoothed = 0;<br>&emsp;&emsp;&emsp;&emsp;vec2 mCamCorrectionGainSmoothed;<br>&emsp;&emsp;&emsp;&emsp;Vec2ArrayInline mCameraErrorPrev;<br>&emsp;&emsp;&emsp;&emsp;vec2 mCamErrorAveraged;<br>&emsp;&emsp;&emsp;&emsp;bool mCamMovingFastPrev = 0;<br>&emsp;&emsp;&emsp;&emsp;int mCamFrameStartedMovingFast = 0;<br>&emsp;&emsp;&emsp;&emsp;int mCamFrameLastMovingFastExplosion = 0;<br>&emsp;&emsp;&emsp;&emsp;bool mCessationDo = 0;<br>&emsp;&emsp;&emsp;&emsp;int mCessationLifetime = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="aiming_reticle_distance_from_character" type="xs:decimal" default="40">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float aiming_reticle_distance_from_character = 40; // [0, 1000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="camera_max_distance_from_character" type="xs:decimal" default="25">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float camera_max_distance_from_character = 25; // [0, 1000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="alcohol_drunken_speed" type="xs:decimal" default="0.005">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float alcohol_drunken_speed = 0.005; // [0, 1000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="blood_fungi_drunken_speed" type="xs:decimal" default="0.006">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float blood_fungi_drunken_speed = 0.006; // [0, 1000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="blood_worm_drunken_speed" type="xs:decimal" default="0.006">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float blood_worm_drunken_speed = 0.006; // [0, 1000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="eating_cells_per_frame" type="xs:int" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int eating_cells_per_frame = 1; // [0, 100] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="eating_probability" type="xs:int" default="5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int eating_probability = 5; // [0, 100] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="eating_delay_frames" type="xs:int" default="30">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int eating_delay_frames = 30; // [0, 100] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="stoned_speed" type="xs:decimal" default="0.1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float stoned_speed = 0.1; // [0, 1000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="center_camera_on_this_entity" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool center_camera_on_this_entity = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="move_camera_with_aim" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool move_camera_with_aim = 1; //  if true, moves camera with the aim.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="eating_area_min.x" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 eating_area_min;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="eating_area_min.y" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 eating_area_min;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="eating_area_max.x" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 eating_area_max;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="eating_area_max.y" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 eating_area_max;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mSmoothedCameraPosition.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mSmoothedCameraPosition;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mSmoothedCameraPosition.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mSmoothedCameraPosition;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mSmoothedAimingVector.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mSmoothedAimingVector;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mSmoothedAimingVector.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mSmoothedAimingVector;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mCameraRecoil" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mCameraRecoil = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mCameraRecoilTarget" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mCameraRecoilTarget = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mCrouching" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mCrouching = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mCameraDistanceLerped" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mCameraDistanceLerped = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mRequireTriggerPull" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mRequireTriggerPull = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mWarpDelay" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mWarpDelay = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mItemTemporarilyHidden" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mItemTemporarilyHidden = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mDesiredCameraPos.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mDesiredCameraPos;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mDesiredCameraPos.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mDesiredCameraPos;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mHasGamepadControlsPrev" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mHasGamepadControlsPrev = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mForceFireOnNextUpdate" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mForceFireOnNextUpdate = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mFastMovementParticlesAlphaSmoothed" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mFastMovementParticlesAlphaSmoothed = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mTeleBoltFramesDuringLastSecond" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint64 mTeleBoltFramesDuringLastSecond = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mCamCorrectionTeleSmoothed" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mCamCorrectionTeleSmoothed = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mCamCorrectionGainSmoothed.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mCamCorrectionGainSmoothed;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mCamCorrectionGainSmoothed.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mCamCorrectionGainSmoothed;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: Vec2ArrayInline for mCameraErrorPrev -->
		<xs:attribute name="mCamErrorAveraged.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mCamErrorAveraged;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mCamErrorAveraged.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mCamErrorAveraged;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mCamMovingFastPrev" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mCamMovingFastPrev = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mCamFrameStartedMovingFast" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mCamFrameStartedMovingFast = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mCamFrameLastMovingFastExplosion" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mCamFrameLastMovingFastExplosion = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mCessationDo" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mCessationDo = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mCessationLifetime" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mCessationLifetime = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="PlayerCollisionComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PlayerCollisionComponent {<br>&emsp;&emsp;&emsp;&emsp;int getting_crushed_threshold = 5; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;int moving_up_before_getting_crushed_threshold = 3; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;int getting_crushed_counter = 0; //  1.12.2018 - Is this still used?<br>&emsp;&emsp;&emsp;&emsp;int stuck_in_ground_counter = 0; //  used this mostly for player to figure out if it's stuck in ground<br>&emsp;&emsp;&emsp;&emsp;int DEBUG_stuck_in_static_ground = 0; //  used to report error + also to free the player in case something horrible has gone wrong<br>&emsp;&emsp;&emsp;&emsp;bool mCollidedHorizontally = 0;<br>&emsp;&emsp;&emsp;&emsp;b2Body* mPhysicsCollisionHax; //  hax<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="getting_crushed_threshold" type="xs:int" default="5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int getting_crushed_threshold = 5; // [0, 100] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="moving_up_before_getting_crushed_threshold" type="xs:int" default="3">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int moving_up_before_getting_crushed_threshold = 3; // [0, 100] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="getting_crushed_counter" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int getting_crushed_counter = 0; //  1.12.2018 - Is this still used?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="stuck_in_ground_counter" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int stuck_in_ground_counter = 0; //  used this mostly for player to figure out if it's stuck in ground<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="DEBUG_stuck_in_static_ground" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int DEBUG_stuck_in_static_ground = 0; //  used to report error + also to free the player in case something horrible has gone wrong<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mCollidedHorizontally" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mCollidedHorizontally = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: b2Body* for mPhysicsCollisionHax -->
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="PlayerStatsComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PlayerStatsComponent {<br>&emsp;&emsp;&emsp;&emsp;int lives = 1;<br>&emsp;&emsp;&emsp;&emsp;float max_hp = 4;<br>&emsp;&emsp;&emsp;&emsp;float speed = 1;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="lives" type="xs:int" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int lives = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="max_hp" type="xs:decimal" default="4">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float max_hp = 4;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="speed" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float speed = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="PositionSeedComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PositionSeedComponent {<br>&emsp;&emsp;&emsp;&emsp;float pos_x = 0; // [0, 3.5] <br>&emsp;&emsp;&emsp;&emsp;float pos_y = 0; // [0, 3.5] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="pos_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float pos_x = 0; // [0, 3.5] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="pos_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float pos_y = 0; // [0, 3.5] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="PotionComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PotionComponent {<br>&emsp;&emsp;&emsp;&emsp;float spray_velocity_coeff = 1; // [0, 2] <br>&emsp;&emsp;&emsp;&emsp;float spray_velocity_normalized_min = 0.5;<br>&emsp;&emsp;&emsp;&emsp;bool body_colored = 0;<br>&emsp;&emsp;&emsp;&emsp;bool throw_bunch = 0;<br>&emsp;&emsp;&emsp;&emsp;int throw_how_many = 5;<br>&emsp;&emsp;&emsp;&emsp;bool dont_spray_static_materials = 0; //  NOTE( Petri ): 15.8.2023 - if this is set to true, will only spray dynamic materials, that dont cause bugs (i.e. will not spray hard rock, box2d materials)<br>&emsp;&emsp;&emsp;&emsp;bool dont_spray_just_leak_gas_materials = 0; //  NOTE( Petri ): 15.8.2023 - if this is set to true, will only leak gas materials instead of 'spraying' them.<br>&emsp;&emsp;&emsp;&emsp;bool never_color = 0; //  Petri: body_colored didn't seem to work, so I added never_color. It can be set to true if you never want the potion to be colored<br>&emsp;&emsp;&emsp;&emsp;int custom_color_material = 0; //  if set, will always use the color from this material<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="spray_velocity_coeff" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float spray_velocity_coeff = 1; // [0, 2] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="spray_velocity_normalized_min" type="xs:decimal" default="0.5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float spray_velocity_normalized_min = 0.5;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="body_colored" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool body_colored = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="throw_bunch" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool throw_bunch = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="throw_how_many" type="xs:int" default="5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int throw_how_many = 5;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="dont_spray_static_materials" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool dont_spray_static_materials = 0; //  NOTE( Petri ): 15.8.2023 - if this is set to true, will only spray dynamic materials, that dont cause bugs (i.e. will not spray hard rock, box2d materials)<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="dont_spray_just_leak_gas_materials" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool dont_spray_just_leak_gas_materials = 0; //  NOTE( Petri ): 15.8.2023 - if this is set to true, will only leak gas materials instead of 'spraying' them.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="never_color" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool never_color = 0; //  Petri: body_colored didn't seem to work, so I added never_color. It can be set to true if you never want the potion to be colored<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="custom_color_material" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int custom_color_material = 0; //  if set, will always use the color from this material<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="PressurePlateComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PressurePlateComponent {<br>&emsp;&emsp;&emsp;&emsp;int check_every_x_frames = 30; //  how often do we check the world<br>&emsp;&emsp;&emsp;&emsp;int state = 0; //  0 is up, 1 is down<br>&emsp;&emsp;&emsp;&emsp;float material_percent = 0.75; //  how much material should there be in the aabbs that we go down <br>&emsp;&emsp;&emsp;&emsp;vec2 aabb_min;<br>&emsp;&emsp;&emsp;&emsp;vec2 aabb_max;<br>&emsp;&emsp;&emsp;&emsp;int mNextFrame = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="check_every_x_frames" type="xs:int" default="30">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int check_every_x_frames = 30; //  how often do we check the world<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="state" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int state = 0; //  0 is up, 1 is down<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="material_percent" type="xs:decimal" default="0.75">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float material_percent = 0.75; //  how much material should there be in the aabbs that we go down <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="aabb_min.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 aabb_min;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="aabb_min.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 aabb_min;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="aabb_max.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 aabb_max;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="aabb_max.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 aabb_max;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mNextFrame" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mNextFrame = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="ProjectileComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ProjectileComponent {<br>&emsp;&emsp;&emsp;&emsp;int lifetime = -1; //  lifetime, -1 means it's endless, otherwise it's the frame count<br>&emsp;&emsp;&emsp;&emsp;int lifetime_randomness = 0; //  final lifetime will be lifetime + random(-lifetime_randomness,lifetime_randomness)<br>&emsp;&emsp;&emsp;&emsp;bool on_lifetime_out_explode = 0; //  when lifetime runs out, should we explode?<br>&emsp;&emsp;&emsp;&emsp;bool collide_with_world = 1; //  true by default. Some projectiles you don't want to collide with the world, e.g. blackholes<br>&emsp;&emsp;&emsp;&emsp;float speed_min = 60; // [0, 60000] <br>&emsp;&emsp;&emsp;&emsp;float speed_max = 60; // [0, 60000] <br>&emsp;&emsp;&emsp;&emsp;float friction = 0; // [0, 60000] <br>&emsp;&emsp;&emsp;&emsp;float direction_random_rad = 0; // [0, 3.14151] when fired, randomizes the velocity -this, this<br>&emsp;&emsp;&emsp;&emsp;float direction_nonrandom_rad = 0; // [-3.14, 3.14] when fired, multiplies this with projectile_i and adds it to direction<br>&emsp;&emsp;&emsp;&emsp;float lob_min = 0.5; // [0, 60000] <br>&emsp;&emsp;&emsp;&emsp;float lob_max = 0.8; // [0, 60000] <br>&emsp;&emsp;&emsp;&emsp;float camera_shake_when_shot = 0; // [0, 60000] <br>&emsp;&emsp;&emsp;&emsp;float shoot_light_flash_radius = 0; // [0, 60000] <br>&emsp;&emsp;&emsp;&emsp;unsigned int shoot_light_flash_r = 255; // [0, 255] <br>&emsp;&emsp;&emsp;&emsp;unsigned int shoot_light_flash_g = 180; // [0, 255] <br>&emsp;&emsp;&emsp;&emsp;unsigned int shoot_light_flash_b = 150; // [0, 255] <br>&emsp;&emsp;&emsp;&emsp;bool create_shell_casing = 0; //  should we create shell casings?<br>&emsp;&emsp;&emsp;&emsp;std::string shell_casing_material = "brass"; //  material of the shell casing<br>&emsp;&emsp;&emsp;&emsp;std::string muzzle_flash_file; //  this entity is created along with the projectile, oriented along the projectile's path<br>&emsp;&emsp;&emsp;&emsp;int bounces_left = 0; // [0, 1e+008] <br>&emsp;&emsp;&emsp;&emsp;float bounce_energy = 0.5; //  when bouncing, velocity is multiplied by this<br>&emsp;&emsp;&emsp;&emsp;bool bounce_always = 0; //  if true, will do a fake bounce if can't do the proper bounce, but will always try to bounce<br>&emsp;&emsp;&emsp;&emsp;bool bounce_at_any_angle = 0; //  if true, will bounce at any reflection angle<br>&emsp;&emsp;&emsp;&emsp;bool attach_to_parent_trigger = 0; //  if true, will attach to the projectile entity that created this projectile via a trigger<br>&emsp;&emsp;&emsp;&emsp;std::string bounce_fx_file; //  this entity is created at the bounce position. it gets the bounce angle as rotation.<br>&emsp;&emsp;&emsp;&emsp;float angular_velocity = 0; // [-3.1415, 3.1415] this is only applied if velocity_sets_rotation == false<br>&emsp;&emsp;&emsp;&emsp;bool velocity_sets_rotation = 1; //  whether we set the rotation based on velocity, as in spear or if we update the rotation with angular_velocity<br>&emsp;&emsp;&emsp;&emsp;bool velocity_sets_scale = 0; //  if true, the sprite width is made equal to the distance traveled since last frame<br>&emsp;&emsp;&emsp;&emsp;float velocity_sets_scale_coeff = 1; //  Larger value means velocity affects the scale more<br>&emsp;&emsp;&emsp;&emsp;bool velocity_sets_y_flip = 0; //  if true, the sprite is flipped based on which side the projectile is currently traveling<br>&emsp;&emsp;&emsp;&emsp;float velocity_updates_animation = 0; //  updates the animation based on far the sprite moved<br>&emsp;&emsp;&emsp;&emsp;float ground_penetration_coeff = 0; // [0, 5] if > 0, this, along with VelocityComponent.mass affects how far we penetrate in materials<br>&emsp;&emsp;&emsp;&emsp;int ground_penetration_max_durability_to_destroy = 0; //  if 0, will not penetrate into materials with durability greater than this<br>&emsp;&emsp;&emsp;&emsp;std::string go_through_this_material; //  if set, we never collide with this material<br>&emsp;&emsp;&emsp;&emsp;bool do_moveto_update = 1; //  this should probably be true, to get normal projectile behaviour, but you might want to disable this for some physics-based projectiles, like bombs<br>&emsp;&emsp;&emsp;&emsp;int on_death_duplicate_remaining = 0; //  if greater than 0, the projectile creates two clones of itself on death. 'on_death_duplicate_remaining' on the clones is reduced by one<br>&emsp;&emsp;&emsp;&emsp;bool on_death_gfx_leave_sprite = 1; //  if true, finds all the sprites and leaves as sand cells into the grid<br>&emsp;&emsp;&emsp;&emsp;bool on_death_explode = 0; //  if true, does explosion with config_explosion<br>&emsp;&emsp;&emsp;&emsp;bool on_death_emit_particle = 0; //  if true, emits on_death_emit_particle_type on death<br>&emsp;&emsp;&emsp;&emsp;int on_death_emit_particle_count = 1; //  how many particles should we emit<br>&emsp;&emsp;&emsp;&emsp;bool die_on_liquid_collision = 0; //  if true, dies on collision with liquids<br>&emsp;&emsp;&emsp;&emsp;bool die_on_low_velocity = 0; //  if true, dies when speed goes below die_on_low_velocity_limit<br>&emsp;&emsp;&emsp;&emsp;float die_on_low_velocity_limit = 50; //  please see die_on_low_velocity<br>&emsp;&emsp;&emsp;&emsp;std::string on_death_emit_particle_type;<br>&emsp;&emsp;&emsp;&emsp;bool on_death_particle_check_concrete = 0; //  if you want it to stick as concrete, you should enable this<br>&emsp;&emsp;&emsp;&emsp;bool ground_collision_fx = 1; //  if 1, spurt some particles when colliding with mortals<br>&emsp;&emsp;&emsp;&emsp;bool explosion_dont_damage_shooter = 0; //  if true, explosion doesn't damage the entity who shot this<br>&emsp;&emsp;&emsp;&emsp;float on_death_item_pickable_radius = 0; //  if > 0, makes items closer than this radius pickable on death<br>&emsp;&emsp;&emsp;&emsp;bool penetrate_world = 0; //  if true, the projectile doesn't collide with ground, liquids, physical objects etc<br>&emsp;&emsp;&emsp;&emsp;float penetrate_world_velocity_coeff = 0.6; //  if 'penetrate_world' is true, the projectile moves with a velocity multiplied by this value when inside world<br>&emsp;&emsp;&emsp;&emsp;bool penetrate_entities = 0; //  if true, the projectile doesn't stop when it collides with entities. damages each entity only once<br>&emsp;&emsp;&emsp;&emsp;bool on_collision_die = 1; //  if true, this is killed as soon as it hits the ground<br>&emsp;&emsp;&emsp;&emsp;bool on_collision_remove_projectile = 0; //  if true, ProjectileComponent is removed from the entitiy<br>&emsp;&emsp;&emsp;&emsp;bool on_collision_spawn_entity = 1; //  if true, spawns the spawn_entity<br>&emsp;&emsp;&emsp;&emsp;std::string spawn_entity; //  this is spawned if hit something an on_collision_spawn_entity = 1<br>&emsp;&emsp;&emsp;&emsp;bool spawn_entity_is_projectile = 0; //  if true, will use ShootProjectile instead of LoadEntity()<br>&emsp;&emsp;&emsp;&emsp;float physics_impulse_coeff = 300; //  projectile applies an impulse to physics bodies it hits. Impulse = physics_impulse_coeff * velocity<br>&emsp;&emsp;&emsp;&emsp;int damage_every_x_frames = -1; //  if set != -1, will only do damage every x frames, used for fields and such, which would otherwise do damage every frame<br>&emsp;&emsp;&emsp;&emsp;bool damage_scaled_by_speed = 0; //  if 1, damage is multiplied by (projectile speed / original projectile speed) ratio<br>&emsp;&emsp;&emsp;&emsp;float damage_scale_max_speed = 0; //  if > 0 and damage_scaled_by_speed = 1, will use this instead of mInitialSpeed when calculating the damage<br>&emsp;&emsp;&emsp;&emsp;bool collide_with_entities = 1; //  if 1, looks for entities with tag, collide_with_tag and collides with them, giving them damage<br>&emsp;&emsp;&emsp;&emsp;std::string collide_with_tag = "hittable"; //  default: mortal, if you needed can be changed to something more specific<br>&emsp;&emsp;&emsp;&emsp;std::string dont_collide_with_tag; //  if set will ignore entities with this tag<br>&emsp;&emsp;&emsp;&emsp;int collide_with_shooter_frames = -1; //  remember friendly_fire 1, if -1 won't collide with shooter at all, otherwise uses the value as frame count and while it's running won't damage the shooter <br>&emsp;&emsp;&emsp;&emsp;bool friendly_fire = 0; //  if true, will damage same herd id<br>&emsp;&emsp;&emsp;&emsp;float damage = 1; //  how much Projectile damage does this do when it hits something<br>&emsp;&emsp;&emsp;&emsp;float knockback_force = 0; //  How far do entities get thrown if a knockback occurs. final_knockback = ProjectileComponent.knockback_force * VelocityComponent.mVelocity * VelocityComponent.mass / who_we_hit.mass<br>&emsp;&emsp;&emsp;&emsp;float ragdoll_force_multiplier = 0.025; //  velocity * ragdoll_force_multiplier is applied to any ragdolls that are created by entities killed by this<br>&emsp;&emsp;&emsp;&emsp;float hit_particle_force_multiplier = 0.1; //  hit particle velocity = projectile_velocity * hit_particle_force_multiplier * some randomness<br>&emsp;&emsp;&emsp;&emsp;float blood_count_multiplier = 1; //  how much blood does this projectile cause<br>&emsp;&emsp;&emsp;&emsp;std::string damage_game_effect_entities; //  a list of game_effects entities separated with ','. e.g. 'data/entities/misc/effect_electrocution.xml,data/entities/misc/effect_on_fire.xml' <br>&emsp;&emsp;&emsp;&emsp;bool never_hit_player = 0; //  If 1, does not hit player no matter what herds this and player belong to<br>&emsp;&emsp;&emsp;&emsp;bool collect_materials_to_shooter = 0; //  if 1, looks up the 'who_shot' entity and its MaterialInventoryComponent on destruction and updates it based on the cells destroyed on our explosion.<br>&emsp;&emsp;&emsp;&emsp;bool play_damage_sounds = 1;<br>&emsp;&emsp;&emsp;&emsp;int mLastFrameDamaged = -1024;<br>&emsp;&emsp;&emsp;&emsp;ConfigGunActionInfo config;<br>&emsp;&emsp;&emsp;&emsp;ConfigExplosion config_explosion; //  if we have explosion, it's the setup for it<br>&emsp;&emsp;&emsp;&emsp;ConfigDamagesByType damage_by_type; //  the amounts of different types of damage this does<br>&emsp;&emsp;&emsp;&emsp;ConfigDamageCritical damage_critical; //  config for critical hit<br>&emsp;&emsp;&emsp;&emsp;PROJECTILE_TYPE::Enum projectile_type;<br>&emsp;&emsp;&emsp;&emsp;vec2 shell_casing_offset; //  where the shell casing will be created relative to projectile, y is flipped if projectile direction is to the left.<br>&emsp;&emsp;&emsp;&emsp;RAGDOLL_FX::Enum ragdoll_fx_on_collision; //  if not NORMAL, do a special ragdoll<br>&emsp;&emsp;&emsp;&emsp;EntityID mWhoShot = 0; //  entity (creature) that shot this<br>&emsp;&emsp;&emsp;&emsp;EntityTypeID mWhoShotEntityTypeID = 0; //  used for stats<br>&emsp;&emsp;&emsp;&emsp;int mShooterHerdId = 0; //  the herdid of mWhoShot, unless friendly fire<br>&emsp;&emsp;&emsp;&emsp;int mStartingLifetime = 0;<br>&emsp;&emsp;&emsp;&emsp;EntityID mEntityThatShot = 0; //  for triggers, if shot from a trigger this should point to the projectile entity that shot this. Otherwise this should be the same as mWhoShot. NOTE! Not really tested properly so might break.<br>&emsp;&emsp;&emsp;&emsp;ProjectileTriggers mTriggers;<br>&emsp;&emsp;&emsp;&emsp;VEC_ENTITY mDamagedEntities;<br>&emsp;&emsp;&emsp;&emsp;float mInitialSpeed = -1;<br>};<br>```]]> </xs:documentation> </xs:annotation>
			<xs:all>
				<xs:element name="config" type="ConfigGunActionInfo" minOccurs="0"/>
				<xs:element name="config_explosion" type="ConfigExplosion" minOccurs="0"/>
				<xs:element name="damage_by_type" type="ConfigDamagesByType" minOccurs="0"/>
				<xs:element name="damage_critical" type="ConfigDamageCritical" minOccurs="0"/>
			</xs:all>
		<xs:attribute name="lifetime" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int lifetime = -1; //  lifetime, -1 means it's endless, otherwise it's the frame count<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lifetime_randomness" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int lifetime_randomness = 0; //  final lifetime will be lifetime + random(-lifetime_randomness,lifetime_randomness)<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="on_lifetime_out_explode" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool on_lifetime_out_explode = 0; //  when lifetime runs out, should we explode?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="collide_with_world" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool collide_with_world = 1; //  true by default. Some projectiles you don't want to collide with the world, e.g. blackholes<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="speed_min" type="xs:decimal" default="60">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float speed_min = 60; // [0, 60000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="speed_max" type="xs:decimal" default="60">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float speed_max = 60; // [0, 60000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="friction" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float friction = 0; // [0, 60000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="direction_random_rad" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float direction_random_rad = 0; // [0, 3.14151] when fired, randomizes the velocity -this, this<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="direction_nonrandom_rad" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float direction_nonrandom_rad = 0; // [-3.14, 3.14] when fired, multiplies this with projectile_i and adds it to direction<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lob_min" type="xs:decimal" default="0.5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float lob_min = 0.5; // [0, 60000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lob_max" type="xs:decimal" default="0.8">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float lob_max = 0.8; // [0, 60000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="camera_shake_when_shot" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float camera_shake_when_shot = 0; // [0, 60000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="shoot_light_flash_radius" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float shoot_light_flash_radius = 0; // [0, 60000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="shoot_light_flash_r" type="xs:unsignedInt" default="255">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>unsigned int shoot_light_flash_r = 255; // [0, 255] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="shoot_light_flash_g" type="xs:unsignedInt" default="180">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>unsigned int shoot_light_flash_g = 180; // [0, 255] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="shoot_light_flash_b" type="xs:unsignedInt" default="150">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>unsigned int shoot_light_flash_b = 150; // [0, 255] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="create_shell_casing" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool create_shell_casing = 0; //  should we create shell casings?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="shell_casing_material" type="xs:string" default="brass">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string shell_casing_material = "brass"; //  material of the shell casing<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="muzzle_flash_file" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string muzzle_flash_file; //  this entity is created along with the projectile, oriented along the projectile's path<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="bounces_left" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int bounces_left = 0; // [0, 1e+008] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="bounce_energy" type="xs:decimal" default="0.5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float bounce_energy = 0.5; //  when bouncing, velocity is multiplied by this<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="bounce_always" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool bounce_always = 0; //  if true, will do a fake bounce if can't do the proper bounce, but will always try to bounce<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="bounce_at_any_angle" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool bounce_at_any_angle = 0; //  if true, will bounce at any reflection angle<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="attach_to_parent_trigger" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool attach_to_parent_trigger = 0; //  if true, will attach to the projectile entity that created this projectile via a trigger<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="bounce_fx_file" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string bounce_fx_file; //  this entity is created at the bounce position. it gets the bounce angle as rotation.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="angular_velocity" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float angular_velocity = 0; // [-3.1415, 3.1415] this is only applied if velocity_sets_rotation == false<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="velocity_sets_rotation" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool velocity_sets_rotation = 1; //  whether we set the rotation based on velocity, as in spear or if we update the rotation with angular_velocity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="velocity_sets_scale" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool velocity_sets_scale = 0; //  if true, the sprite width is made equal to the distance traveled since last frame<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="velocity_sets_scale_coeff" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float velocity_sets_scale_coeff = 1; //  Larger value means velocity affects the scale more<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="velocity_sets_y_flip" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool velocity_sets_y_flip = 0; //  if true, the sprite is flipped based on which side the projectile is currently traveling<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="velocity_updates_animation" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float velocity_updates_animation = 0; //  updates the animation based on far the sprite moved<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ground_penetration_coeff" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float ground_penetration_coeff = 0; // [0, 5] if > 0, this, along with VelocityComponent.mass affects how far we penetrate in materials<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ground_penetration_max_durability_to_destroy" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int ground_penetration_max_durability_to_destroy = 0; //  if 0, will not penetrate into materials with durability greater than this<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="go_through_this_material" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string go_through_this_material; //  if set, we never collide with this material<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="do_moveto_update" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool do_moveto_update = 1; //  this should probably be true, to get normal projectile behaviour, but you might want to disable this for some physics-based projectiles, like bombs<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="on_death_duplicate_remaining" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int on_death_duplicate_remaining = 0; //  if greater than 0, the projectile creates two clones of itself on death. 'on_death_duplicate_remaining' on the clones is reduced by one<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="on_death_gfx_leave_sprite" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool on_death_gfx_leave_sprite = 1; //  if true, finds all the sprites and leaves as sand cells into the grid<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="on_death_explode" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool on_death_explode = 0; //  if true, does explosion with config_explosion<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="on_death_emit_particle" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool on_death_emit_particle = 0; //  if true, emits on_death_emit_particle_type on death<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="on_death_emit_particle_count" type="xs:int" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int on_death_emit_particle_count = 1; //  how many particles should we emit<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="die_on_liquid_collision" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool die_on_liquid_collision = 0; //  if true, dies on collision with liquids<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="die_on_low_velocity" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool die_on_low_velocity = 0; //  if true, dies when speed goes below die_on_low_velocity_limit<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="die_on_low_velocity_limit" type="xs:decimal" default="50">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float die_on_low_velocity_limit = 50; //  please see die_on_low_velocity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="on_death_emit_particle_type" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string on_death_emit_particle_type;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="on_death_particle_check_concrete" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool on_death_particle_check_concrete = 0; //  if you want it to stick as concrete, you should enable this<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ground_collision_fx" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool ground_collision_fx = 1; //  if 1, spurt some particles when colliding with mortals<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="explosion_dont_damage_shooter" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool explosion_dont_damage_shooter = 0; //  if true, explosion doesn't damage the entity who shot this<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="on_death_item_pickable_radius" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float on_death_item_pickable_radius = 0; //  if > 0, makes items closer than this radius pickable on death<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="penetrate_world" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool penetrate_world = 0; //  if true, the projectile doesn't collide with ground, liquids, physical objects etc<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="penetrate_world_velocity_coeff" type="xs:decimal" default="0.6">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float penetrate_world_velocity_coeff = 0.6; //  if 'penetrate_world' is true, the projectile moves with a velocity multiplied by this value when inside world<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="penetrate_entities" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool penetrate_entities = 0; //  if true, the projectile doesn't stop when it collides with entities. damages each entity only once<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="on_collision_die" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool on_collision_die = 1; //  if true, this is killed as soon as it hits the ground<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="on_collision_remove_projectile" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool on_collision_remove_projectile = 0; //  if true, ProjectileComponent is removed from the entitiy<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="on_collision_spawn_entity" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool on_collision_spawn_entity = 1; //  if true, spawns the spawn_entity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="spawn_entity" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string spawn_entity; //  this is spawned if hit something an on_collision_spawn_entity = 1<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="spawn_entity_is_projectile" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool spawn_entity_is_projectile = 0; //  if true, will use ShootProjectile instead of LoadEntity()<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="physics_impulse_coeff" type="xs:decimal" default="300">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float physics_impulse_coeff = 300; //  projectile applies an impulse to physics bodies it hits. Impulse = physics_impulse_coeff * velocity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_every_x_frames" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int damage_every_x_frames = -1; //  if set != -1, will only do damage every x frames, used for fields and such, which would otherwise do damage every frame<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_scaled_by_speed" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool damage_scaled_by_speed = 0; //  if 1, damage is multiplied by (projectile speed / original projectile speed) ratio<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_scale_max_speed" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float damage_scale_max_speed = 0; //  if > 0 and damage_scaled_by_speed = 1, will use this instead of mInitialSpeed when calculating the damage<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="collide_with_entities" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool collide_with_entities = 1; //  if 1, looks for entities with tag, collide_with_tag and collides with them, giving them damage<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="collide_with_tag" type="xs:string" default="hittable">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string collide_with_tag = "hittable"; //  default: mortal, if you needed can be changed to something more specific<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="dont_collide_with_tag" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string dont_collide_with_tag; //  if set will ignore entities with this tag<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="collide_with_shooter_frames" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int collide_with_shooter_frames = -1; //  remember friendly_fire 1, if -1 won't collide with shooter at all, otherwise uses the value as frame count and while it's running won't damage the shooter <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="friendly_fire" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool friendly_fire = 0; //  if true, will damage same herd id<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float damage = 1; //  how much Projectile damage does this do when it hits something<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="knockback_force" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float knockback_force = 0; //  How far do entities get thrown if a knockback occurs. final_knockback = ProjectileComponent.knockback_force * VelocityComponent.mVelocity * VelocityComponent.mass / who_we_hit.mass<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ragdoll_force_multiplier" type="xs:decimal" default="0.025">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float ragdoll_force_multiplier = 0.025; //  velocity * ragdoll_force_multiplier is applied to any ragdolls that are created by entities killed by this<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="hit_particle_force_multiplier" type="xs:decimal" default="0.1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float hit_particle_force_multiplier = 0.1; //  hit particle velocity = projectile_velocity * hit_particle_force_multiplier * some randomness<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="blood_count_multiplier" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float blood_count_multiplier = 1; //  how much blood does this projectile cause<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_game_effect_entities" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string damage_game_effect_entities; //  a list of game_effects entities separated with ','. e.g. 'data/entities/misc/effect_electrocution.xml,data/entities/misc/effect_on_fire.xml' <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="never_hit_player" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool never_hit_player = 0; //  If 1, does not hit player no matter what herds this and player belong to<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="collect_materials_to_shooter" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool collect_materials_to_shooter = 0; //  if 1, looks up the 'who_shot' entity and its MaterialInventoryComponent on destruction and updates it based on the cells destroyed on our explosion.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="play_damage_sounds" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool play_damage_sounds = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLastFrameDamaged" type="xs:int" default="-1024">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mLastFrameDamaged = -1024;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="projectile_type" type="PROJECTILE_TYPE" default="PROJECTILE">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>PROJECTILE_TYPE::Enum projectile_type;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="shell_casing_offset.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 shell_casing_offset; //  where the shell casing will be created relative to projectile, y is flipped if projectile direction is to the left.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="shell_casing_offset.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 shell_casing_offset; //  where the shell casing will be created relative to projectile, y is flipped if projectile direction is to the left.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ragdoll_fx_on_collision" type="RAGDOLL_FX" default="NORMAL">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>RAGDOLL_FX::Enum ragdoll_fx_on_collision; //  if not NORMAL, do a special ragdoll<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: EntityID for mWhoShot -->
		<!-- Some Unknown Type: EntityTypeID for mWhoShotEntityTypeID -->
		<xs:attribute name="mShooterHerdId" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mShooterHerdId = 0; //  the herdid of mWhoShot, unless friendly fire<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mStartingLifetime" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mStartingLifetime = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: EntityID for mEntityThatShot -->
		<!-- Some Unknown Type: ProjectileTriggers for mTriggers -->
		<!-- Some Unknown Type: VEC_ENTITY for mDamagedEntities -->
		<xs:attribute name="mInitialSpeed" type="xs:decimal" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mInitialSpeed = -1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="RotateTowardsComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class RotateTowardsComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string entity_with_tag = "player_unit"; //  will rotate this entity towards the closest entity with tag<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="entity_with_tag" type="xs:string" default="player_unit">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string entity_with_tag = "player_unit"; //  will rotate this entity towards the closest entity with tag<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="SetLightAlphaFromVelocityComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class SetLightAlphaFromVelocityComponent {<br>&emsp;&emsp;&emsp;&emsp;float max_velocity = 50; // [1, 150] <br>&emsp;&emsp;&emsp;&emsp;vec2 mPrevPosition;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="max_velocity" type="xs:decimal" default="50">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float max_velocity = 50; // [1, 150] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevPosition.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mPrevPosition;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevPosition.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mPrevPosition;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="SetStartVelocityComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class SetStartVelocityComponent {<br>&emsp;&emsp;&emsp;&emsp;vec2 velocity; //  This is added together with random velocity<br>&emsp;&emsp;&emsp;&emsp;ValueRange randomize_angle; //  Random angle min max range in radians, clockwise. 0.0 points directly rightward.<br>&emsp;&emsp;&emsp;&emsp;ValueRange randomize_speed; //  Random speed min max range<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="velocity.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 velocity; //  This is added together with random velocity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="velocity.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 velocity; //  This is added together with random velocity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="randomize_angle.min" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ValueRange randomize_angle; //  Random angle min max range in radians, clockwise. 0.0 points directly rightward.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="randomize_angle.max" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ValueRange randomize_angle; //  Random angle min max range in radians, clockwise. 0.0 points directly rightward.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="randomize_speed.min" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ValueRange randomize_speed; //  Random speed min max range<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="randomize_speed.max" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ValueRange randomize_speed; //  Random speed min max range<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="ShotEffectComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ShotEffectComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string extra_modifier; //  name of modifier function executed per projectile from 'gun_extra_modifiers.lua'<br>&emsp;&emsp;&emsp;&emsp;GAME_EFFECT::Enum condition_effect; //  Shooting entity needs to have this 'GAME_EFFECT' for effects to apply. If both 'condition_effect' and 'condition_status' are set, they are combined with AND logic<br>&emsp;&emsp;&emsp;&emsp;StatusEffectType condition_status = 0; //  Shooting entity needs to have this 'STATUS_EFFECT' for effects to apply<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="extra_modifier" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string extra_modifier; //  name of modifier function executed per projectile from 'gun_extra_modifiers.lua'<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="condition_effect" type="GAME_EFFECT" default="NONE">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>GAME_EFFECT::Enum condition_effect; //  Shooting entity needs to have this 'GAME_EFFECT' for effects to apply. If both 'condition_effect' and 'condition_status' are set, they are combined with AND logic<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="condition_status" type="GAME_EFFECT" default="NONE">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>StatusEffectType condition_status = 0; //  Shooting entity needs to have this 'STATUS_EFFECT' for effects to apply<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="SimplePhysicsComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class SimplePhysicsComponent {<br>&emsp;&emsp;&emsp;&emsp;bool can_go_up = 1; //  if set, will not try to move this upwards<br>&emsp;&emsp;&emsp;&emsp;vec2 mOldPosition; //  used for box2d simple physics<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="can_go_up" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool can_go_up = 1; //  if set, will not try to move this upwards<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mOldPosition.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mOldPosition; //  used for box2d simple physics<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mOldPosition.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mOldPosition; //  used for box2d simple physics<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="SineWaveComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class SineWaveComponent {<br>&emsp;&emsp;&emsp;&emsp;float sinewave_freq = 1; //  sinewave_m * sinf( sinewave_freq * lifetime++)<br>&emsp;&emsp;&emsp;&emsp;float sinewave_m = 0.6; //  sinewave_m * sinf( sinewave_freq * lifetime++)<br>&emsp;&emsp;&emsp;&emsp;int lifetime = -1; //  -1 seems to fix some problems with this... sinewave_m * sinf( sinewave_freq * lifetime++)<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="sinewave_freq" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float sinewave_freq = 1; //  sinewave_m * sinf( sinewave_freq * lifetime++)<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="sinewave_m" type="xs:decimal" default="0.6">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float sinewave_m = 0.6; //  sinewave_m * sinf( sinewave_freq * lifetime++)<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lifetime" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int lifetime = -1; //  -1 seems to fix some problems with this... sinewave_m * sinf( sinewave_freq * lifetime++)<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="SpriteAnimatorComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class SpriteAnimatorComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string target_sprite_comp_name = "character";<br>&emsp;&emsp;&emsp;&emsp;bool rotate_to_surface_normal = 0;<br>&emsp;&emsp;&emsp;&emsp;STACK_ANIMATIONSTATE mStates;<br>&emsp;&emsp;&emsp;&emsp;ComponentTags mCachedTargetSpriteTag;<br>&emsp;&emsp;&emsp;&emsp;std::string mSendOnFinishedMessageName;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="target_sprite_comp_name" type="xs:string" default="character">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string target_sprite_comp_name = "character";<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="rotate_to_surface_normal" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool rotate_to_surface_normal = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: STACK_ANIMATIONSTATE for mStates -->
		<!-- Some Unknown Type: ComponentTags for mCachedTargetSpriteTag -->
		<xs:attribute name="mSendOnFinishedMessageName" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string mSendOnFinishedMessageName;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="SpriteComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class SpriteComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string image_file = "data/temp/temp_gun.png";<br>&emsp;&emsp;&emsp;&emsp;bool ui_is_parent = 0; //  Adds this to the GG.GetUISprite() as a child, instead of the mSpriteContainer<br>&emsp;&emsp;&emsp;&emsp;bool is_text_sprite = 0; //  if you want to load a text sprite, set this to true and image_file to a font file<br>&emsp;&emsp;&emsp;&emsp;float offset_x = 0; // [-24, 24] <br>&emsp;&emsp;&emsp;&emsp;float offset_y = 0; // [-24, 24] <br>&emsp;&emsp;&emsp;&emsp;float alpha = 1;<br>&emsp;&emsp;&emsp;&emsp;bool visible = 1;<br>&emsp;&emsp;&emsp;&emsp;bool emissive = 0;<br>&emsp;&emsp;&emsp;&emsp;bool additive = 0;<br>&emsp;&emsp;&emsp;&emsp;bool fog_of_war_hole = 0; //  if 1, the alpha channel of this texture punctures a hole in the fog of war<br>&emsp;&emsp;&emsp;&emsp;bool smooth_filtering = 0;<br>&emsp;&emsp;&emsp;&emsp;std::string rect_animation;<br>&emsp;&emsp;&emsp;&emsp;std::string next_rect_animation;<br>&emsp;&emsp;&emsp;&emsp;std::string text;<br>&emsp;&emsp;&emsp;&emsp;float z_index = 1; // [-256, 256] 0 = world grid, -1 = enemies, -1.5 = items in world, player = 0.6<br>&emsp;&emsp;&emsp;&emsp;bool update_transform = 1;<br>&emsp;&emsp;&emsp;&emsp;bool update_transform_rotation = 1;<br>&emsp;&emsp;&emsp;&emsp;bool kill_entity_after_finished = 0;<br>&emsp;&emsp;&emsp;&emsp;bool has_special_scale = 0; //  if this is set, sets special_scale_x and _y to scale<br>&emsp;&emsp;&emsp;&emsp;float special_scale_x = 1; //  this overrides the scale of the entity, if has_special_scale<br>&emsp;&emsp;&emsp;&emsp;float special_scale_y = 1; //  this overrides the scale of the entity, if has_special_scale<br>&emsp;&emsp;&emsp;&emsp;bool never_ragdollify_on_death = 0;<br>&emsp;&emsp;&emsp;&emsp;vec2 transform_offset;<br>&emsp;&emsp;&emsp;&emsp;vec2 offset_animator_offset; //  used by SpriteOffsetAnimator<br>&emsp;&emsp;&emsp;&emsp;as::Sprite* mSprite;<br>&emsp;&emsp;&emsp;&emsp;SpriteRenderList* mRenderList;<br>&emsp;&emsp;&emsp;&emsp;int32 mRenderListHandle = -1;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="image_file" type="xs:string" default="data/temp/temp_gun.png">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string image_file = "data/temp/temp_gun.png";<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ui_is_parent" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool ui_is_parent = 0; //  Adds this to the GG.GetUISprite() as a child, instead of the mSpriteContainer<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_text_sprite" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_text_sprite = 0; //  if you want to load a text sprite, set this to true and image_file to a font file<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="offset_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float offset_x = 0; // [-24, 24] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="offset_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float offset_y = 0; // [-24, 24] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="alpha" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float alpha = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="visible" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool visible = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="emissive" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool emissive = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="additive" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool additive = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fog_of_war_hole" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool fog_of_war_hole = 0; //  if 1, the alpha channel of this texture punctures a hole in the fog of war<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="smooth_filtering" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool smooth_filtering = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="rect_animation" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string rect_animation;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="next_rect_animation" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string next_rect_animation;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="text" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string text;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="z_index" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float z_index = 1; // [-256, 256] 0 = world grid, -1 = enemies, -1.5 = items in world, player = 0.6<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="update_transform" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool update_transform = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="update_transform_rotation" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool update_transform_rotation = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="kill_entity_after_finished" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool kill_entity_after_finished = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="has_special_scale" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool has_special_scale = 0; //  if this is set, sets special_scale_x and _y to scale<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="special_scale_x" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float special_scale_x = 1; //  this overrides the scale of the entity, if has_special_scale<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="special_scale_y" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float special_scale_y = 1; //  this overrides the scale of the entity, if has_special_scale<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="never_ragdollify_on_death" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool never_ragdollify_on_death = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="transform_offset.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 transform_offset;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="transform_offset.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 transform_offset;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="offset_animator_offset.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 offset_animator_offset; //  used by SpriteOffsetAnimator<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="offset_animator_offset.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 offset_animator_offset; //  used by SpriteOffsetAnimator<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: as::Sprite* for mSprite -->
		<!-- Some Unknown Type: SpriteRenderList* for mRenderList -->
		<xs:attribute name="mRenderListHandle" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int32 mRenderListHandle = -1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="SpriteOffsetAnimatorComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class SpriteOffsetAnimatorComponent {<br>&emsp;&emsp;&emsp;&emsp;float x_amount = 0; // [0, 5] <br>&emsp;&emsp;&emsp;&emsp;float x_speed = 0; // [0, 5] <br>&emsp;&emsp;&emsp;&emsp;float y_amount = 2; // [0, 5] <br>&emsp;&emsp;&emsp;&emsp;float y_speed = 2; // [0, 5] <br>&emsp;&emsp;&emsp;&emsp;int sprite_id = 0; // [0, 8] <br>&emsp;&emsp;&emsp;&emsp;float x_phase = 16; // [0, 32] <br>&emsp;&emsp;&emsp;&emsp;float x_phase_offset = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="x_amount" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float x_amount = 0; // [0, 5] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="x_speed" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float x_speed = 0; // [0, 5] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="y_amount" type="xs:decimal" default="2">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float y_amount = 2; // [0, 5] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="y_speed" type="xs:decimal" default="2">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float y_speed = 2; // [0, 5] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="sprite_id" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int sprite_id = 0; // [0, 8] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="x_phase" type="xs:decimal" default="16">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float x_phase = 16; // [0, 32] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="x_phase_offset" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float x_phase_offset = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="SpriteParticleEmitterComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class SpriteParticleEmitterComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string sprite_file; //  filepath to the sprite(s), supports the $[0-3] syntax<br>&emsp;&emsp;&emsp;&emsp;bool sprite_centered = 0; //  sets the offset to the center of the image<br>&emsp;&emsp;&emsp;&emsp;bool sprite_random_rotation = 0; //  rotates the sprite randomly in 90 degree angles<br>&emsp;&emsp;&emsp;&emsp;bool render_back = 0; //  if true, will set this particle to be behind entities (won't emit light)<br>&emsp;&emsp;&emsp;&emsp;float delay = 0; //  delay in seconds...<br>&emsp;&emsp;&emsp;&emsp;float lifetime = 0; //  lifetime in seconds...<br>&emsp;&emsp;&emsp;&emsp;bool additive = 0; //  if 1, the sprites will be rendered using additive blending<br>&emsp;&emsp;&emsp;&emsp;bool emissive = 0; //  if 1, the sprites will be rendered onto the emissive render target<br>&emsp;&emsp;&emsp;&emsp;float velocity_slowdown = 0; //  what percent of the velocity is slowed by *dt<br>&emsp;&emsp;&emsp;&emsp;float rotation = 0; //  original rotation in rads<br>&emsp;&emsp;&emsp;&emsp;float angular_velocity = 0; //  how much rotation there is in a second<br>&emsp;&emsp;&emsp;&emsp;bool use_velocity_as_rotation = 0; //  do we rotate the sprite based on the velocity<br>&emsp;&emsp;&emsp;&emsp;bool use_rotation_from_velocity_component = 0; //  if set, will set the initial rotation based on the velocity component's velocity<br>&emsp;&emsp;&emsp;&emsp;bool use_rotation_from_entity = 0; //  if set, will 'inherit' rotation from the entity<br>&emsp;&emsp;&emsp;&emsp;float entity_velocity_multiplier = 0; //  0 = doesn't use the velocity from spawning entity at all, 1 = uses all<br>&emsp;&emsp;&emsp;&emsp;float z_index = 0; //  Depth of created particles<br>&emsp;&emsp;&emsp;&emsp;bool randomize_position_inside_hitbox = 0; //  if set, will randomize position inside the hitbox aabb<br>&emsp;&emsp;&emsp;&emsp;bool velocity_always_away_from_center = 0; //  if set, will make the velocity's rotation always away from center of randomized aabb<br>&emsp;&emsp;&emsp;&emsp;bool camera_bound = 1; //  if true, will be culled if not near the camera<br>&emsp;&emsp;&emsp;&emsp;float camera_distance = 75; //  if the distance from camera (edges) is higher than this, this will be culled<br>&emsp;&emsp;&emsp;&emsp;bool is_emitting = 1; //  disable this from emitting...<br>&emsp;&emsp;&emsp;&emsp;int count_min = 0; //  how many particles do we spawn at one time<br>&emsp;&emsp;&emsp;&emsp;int count_max = 1; //  how many particles do we spawn at one time<br>&emsp;&emsp;&emsp;&emsp;int emission_interval_min_frames = 5; // [0, 200] how often do we emit particles<br>&emsp;&emsp;&emsp;&emsp;int emission_interval_max_frames = 10; // [0, 200] how often do we emit particles<br>&emsp;&emsp;&emsp;&emsp;std::string entity_file; //  if set, this entity is loaded to the emission position by the emitter when it emits<br>&emsp;&emsp;&emsp;&emsp;types::fcolor color; //  original color<br>&emsp;&emsp;&emsp;&emsp;types::fcolor color_change; //  how much the color changes in a second<br>&emsp;&emsp;&emsp;&emsp;vec2 velocity; //  original velocity<br>&emsp;&emsp;&emsp;&emsp;vec2 gravity; //  gravity<br>&emsp;&emsp;&emsp;&emsp;vec2 scale; //  original scale<br>&emsp;&emsp;&emsp;&emsp;vec2 scale_velocity; //  scale velocity per second<br>&emsp;&emsp;&emsp;&emsp;ValueRange randomize_lifetime; //  this is added to the lifetime<br>&emsp;&emsp;&emsp;&emsp;types::aabb randomize_position; //  random offset for pos<br>&emsp;&emsp;&emsp;&emsp;types::aabb randomize_velocity; //  add this randomized velocity inside this o the velocity<br>&emsp;&emsp;&emsp;&emsp;types::aabb randomize_scale; //  add this randomized vector2 to scale<br>&emsp;&emsp;&emsp;&emsp;ValueRange randomize_rotation; //  this is added to the rotation <br>&emsp;&emsp;&emsp;&emsp;ValueRange randomize_angular_velocity; //  this is added to angular_velocity<br>&emsp;&emsp;&emsp;&emsp;ValueRange randomize_alpha; //  this is added to the alpha<br>&emsp;&emsp;&emsp;&emsp;ValueRange randomize_animation_speed_coeff; //  if set, animation speed is multiplied by a random value inside this range<br>&emsp;&emsp;&emsp;&emsp;vec2 expand_randomize_position; //  will add dt*this to randomize_position_aabb every frame<br>&emsp;&emsp;&emsp;&emsp;int mNextEmitFrame = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="sprite_file" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string sprite_file; //  filepath to the sprite(s), supports the $[0-3] syntax<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="sprite_centered" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool sprite_centered = 0; //  sets the offset to the center of the image<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="sprite_random_rotation" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool sprite_random_rotation = 0; //  rotates the sprite randomly in 90 degree angles<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="render_back" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool render_back = 0; //  if true, will set this particle to be behind entities (won't emit light)<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="delay" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float delay = 0; //  delay in seconds...<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lifetime" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float lifetime = 0; //  lifetime in seconds...<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="additive" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool additive = 0; //  if 1, the sprites will be rendered using additive blending<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="emissive" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool emissive = 0; //  if 1, the sprites will be rendered onto the emissive render target<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="velocity_slowdown" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float velocity_slowdown = 0; //  what percent of the velocity is slowed by *dt<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="rotation" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float rotation = 0; //  original rotation in rads<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="angular_velocity" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float angular_velocity = 0; //  how much rotation there is in a second<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="use_velocity_as_rotation" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool use_velocity_as_rotation = 0; //  do we rotate the sprite based on the velocity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="use_rotation_from_velocity_component" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool use_rotation_from_velocity_component = 0; //  if set, will set the initial rotation based on the velocity component's velocity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="use_rotation_from_entity" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool use_rotation_from_entity = 0; //  if set, will 'inherit' rotation from the entity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="entity_velocity_multiplier" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float entity_velocity_multiplier = 0; //  0 = doesn't use the velocity from spawning entity at all, 1 = uses all<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="z_index" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float z_index = 0; //  Depth of created particles<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="randomize_position_inside_hitbox" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool randomize_position_inside_hitbox = 0; //  if set, will randomize position inside the hitbox aabb<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="velocity_always_away_from_center" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool velocity_always_away_from_center = 0; //  if set, will make the velocity's rotation always away from center of randomized aabb<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="camera_bound" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool camera_bound = 1; //  if true, will be culled if not near the camera<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="camera_distance" type="xs:decimal" default="75">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float camera_distance = 75; //  if the distance from camera (edges) is higher than this, this will be culled<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_emitting" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_emitting = 1; //  disable this from emitting...<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="count_min" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int count_min = 0; //  how many particles do we spawn at one time<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="count_max" type="xs:int" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int count_max = 1; //  how many particles do we spawn at one time<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="emission_interval_min_frames" type="xs:int" default="5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int emission_interval_min_frames = 5; // [0, 200] how often do we emit particles<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="emission_interval_max_frames" type="xs:int" default="10">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int emission_interval_max_frames = 10; // [0, 200] how often do we emit particles<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="entity_file" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string entity_file; //  if set, this entity is loaded to the emission position by the emitter when it emits<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="color.r" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>types::fcolor color; //  original color<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="color.g" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>types::fcolor color; //  original color<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="color.b" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>types::fcolor color; //  original color<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="color.a" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>types::fcolor color; //  original color<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="color_change.r" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>types::fcolor color_change; //  how much the color changes in a second<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="color_change.g" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>types::fcolor color_change; //  how much the color changes in a second<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="color_change.b" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>types::fcolor color_change; //  how much the color changes in a second<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="color_change.a" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>types::fcolor color_change; //  how much the color changes in a second<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="velocity.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 velocity; //  original velocity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="velocity.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 velocity; //  original velocity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="gravity.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 gravity; //  gravity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="gravity.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 gravity; //  gravity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="scale.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 scale; //  original scale<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="scale.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 scale; //  original scale<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="scale_velocity.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 scale_velocity; //  scale velocity per second<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="scale_velocity.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 scale_velocity; //  scale velocity per second<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="randomize_lifetime.min" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ValueRange randomize_lifetime; //  this is added to the lifetime<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="randomize_lifetime.max" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ValueRange randomize_lifetime; //  this is added to the lifetime<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="randomize_position.min_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>types::aabb randomize_position; //  random offset for pos<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="randomize_position.min_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>types::aabb randomize_position; //  random offset for pos<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="randomize_position.max_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>types::aabb randomize_position; //  random offset for pos<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="randomize_position.max_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>types::aabb randomize_position; //  random offset for pos<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="randomize_velocity.min_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>types::aabb randomize_velocity; //  add this randomized velocity inside this o the velocity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="randomize_velocity.min_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>types::aabb randomize_velocity; //  add this randomized velocity inside this o the velocity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="randomize_velocity.max_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>types::aabb randomize_velocity; //  add this randomized velocity inside this o the velocity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="randomize_velocity.max_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>types::aabb randomize_velocity; //  add this randomized velocity inside this o the velocity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="randomize_scale.min_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>types::aabb randomize_scale; //  add this randomized vector2 to scale<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="randomize_scale.min_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>types::aabb randomize_scale; //  add this randomized vector2 to scale<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="randomize_scale.max_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>types::aabb randomize_scale; //  add this randomized vector2 to scale<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="randomize_scale.max_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>types::aabb randomize_scale; //  add this randomized vector2 to scale<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="randomize_rotation.min" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ValueRange randomize_rotation; //  this is added to the rotation <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="randomize_rotation.max" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ValueRange randomize_rotation; //  this is added to the rotation <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="randomize_angular_velocity.min" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ValueRange randomize_angular_velocity; //  this is added to angular_velocity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="randomize_angular_velocity.max" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ValueRange randomize_angular_velocity; //  this is added to angular_velocity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="randomize_alpha.min" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ValueRange randomize_alpha; //  this is added to the alpha<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="randomize_alpha.max" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ValueRange randomize_alpha; //  this is added to the alpha<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="randomize_animation_speed_coeff.min" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ValueRange randomize_animation_speed_coeff; //  if set, animation speed is multiplied by a random value inside this range<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="randomize_animation_speed_coeff.max" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ValueRange randomize_animation_speed_coeff; //  if set, animation speed is multiplied by a random value inside this range<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="expand_randomize_position.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 expand_randomize_position; //  will add dt*this to randomize_position_aabb every frame<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="expand_randomize_position.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 expand_randomize_position; //  will add dt*this to randomize_position_aabb every frame<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mNextEmitFrame" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mNextEmitFrame = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="SpriteStainsComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class SpriteStainsComponent {<br>&emsp;&emsp;&emsp;&emsp;int sprite_id = 0; // [0, 10] which sprite (in the order in which they appear in the entity) are we going to stain?<br>&emsp;&emsp;&emsp;&emsp;bool fade_stains_towards_srite_top = 1; //  if 1, shades get less opaque near the top of the sprite<br>&emsp;&emsp;&emsp;&emsp;LensValue<int> stain_shaken_drop_chance_multiplier; //  how quickly stains are dropped relative to normal drop speed<br>&emsp;&emsp;&emsp;&emsp;SpriteStains* mData;<br>&emsp;&emsp;&emsp;&emsp;VirtualTextureHandle mTextureHandle;<br>&emsp;&emsp;&emsp;&emsp;SpriteStainsState mState;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="sprite_id" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int sprite_id = 0; // [0, 10] which sprite (in the order in which they appear in the entity) are we going to stain?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fade_stains_towards_srite_top" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool fade_stains_towards_srite_top = 1; //  if 1, shades get less opaque near the top of the sprite<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="stain_shaken_drop_chance_multiplier" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>LensValue<int> stain_shaken_drop_chance_multiplier; //  how quickly stains are dropped relative to normal drop speed<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: SpriteStains* for mData -->
		<!-- Some Unknown Type: VirtualTextureHandle for mTextureHandle -->
		<!-- Some Unknown Type: SpriteStainsState for mState -->
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="StatusEffectDataComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class StatusEffectDataComponent {<br>&emsp;&emsp;&emsp;&emsp;VECTOR_FLOAT stain_effects;<br>&emsp;&emsp;&emsp;&emsp;VECTOR_INT32 stain_effect_cooldowns;<br>&emsp;&emsp;&emsp;&emsp;VECTOR_FLOAT effects_previous;<br>&emsp;&emsp;&emsp;&emsp;VECTOR_FLOAT ingestion_effects;<br>&emsp;&emsp;&emsp;&emsp;VEC_OF_MATERIALS ingestion_effect_causes;<br>&emsp;&emsp;&emsp;&emsp;VECTOR_INT32 ingestion_effect_causes_many;<br>&emsp;&emsp;&emsp;&emsp;int mLastAttackingPlayerFrame = -99999;<br>&emsp;&emsp;&emsp;&emsp;VECTOR_FLOAT mStainEffectsSmoothedForUI;<br>&emsp;&emsp;&emsp;&emsp;bool mHasChildIconsCached = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<!-- Some Unknown Type: VECTOR_FLOAT for stain_effects -->
		<!-- Some Unknown Type: VECTOR_INT32 for stain_effect_cooldowns -->
		<!-- Some Unknown Type: VECTOR_FLOAT for effects_previous -->
		<!-- Some Unknown Type: VECTOR_FLOAT for ingestion_effects -->
		<xs:attribute name="ingestion_effect_causes" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>VEC_OF_MATERIALS ingestion_effect_causes;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: VECTOR_INT32 for ingestion_effect_causes_many -->
		<xs:attribute name="mLastAttackingPlayerFrame" type="xs:int" default="-99999">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mLastAttackingPlayerFrame = -99999;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: VECTOR_FLOAT for mStainEffectsSmoothedForUI -->
		<xs:attribute name="mHasChildIconsCached" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mHasChildIconsCached = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="StreamingKeepAliveComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class StreamingKeepAliveComponent {<br>&emsp;&emsp;&emsp;&emsp;float TEMP_TEMPY = 0; // [0, 3.5] <br>&emsp;&emsp;&emsp;&emsp;float TEMP_TEMP_TEMP = 0; // [0, 3.5] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="TEMP_TEMPY" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float TEMP_TEMPY = 0; // [0, 3.5] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="TEMP_TEMP_TEMP" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float TEMP_TEMP_TEMP = 0; // [0, 3.5] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="TelekinesisComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class TelekinesisComponent {<br>&emsp;&emsp;&emsp;&emsp;uint32 min_size = 7; //  Minimum size of physics body that can be grabbed, in cells/pixels<br>&emsp;&emsp;&emsp;&emsp;uint32 max_size = 1500; //  Maximum size of physics body that can be grabbed, in cells/pixels<br>&emsp;&emsp;&emsp;&emsp;float radius = 250; // [0, 300] Maximum object search distance<br>&emsp;&emsp;&emsp;&emsp;float throw_speed = 25; // [0, 300] Affects object speed when it is thrown<br>&emsp;&emsp;&emsp;&emsp;float target_distance = 6; // [0, 30] Affects how far objects float from owner when held. Object size will also affect the floating distance.<br>&emsp;&emsp;&emsp;&emsp;bool kick_to_use = 1; //  If 1, telekinesis interaction will occur when kick input is detected in root entity's ControlsComponent<br>&emsp;&emsp;&emsp;&emsp;int32 mState = 0;<br>&emsp;&emsp;&emsp;&emsp;uint64 mBodyID = 0;<br>&emsp;&emsp;&emsp;&emsp;float mStartBodyMaxExtent = 0;<br>&emsp;&emsp;&emsp;&emsp;float mStartAimAngle = 0;<br>&emsp;&emsp;&emsp;&emsp;float mStartBodyAngle = 0;<br>&emsp;&emsp;&emsp;&emsp;float mStartBodyDistance = 0;<br>&emsp;&emsp;&emsp;&emsp;float mStartTime = 0;<br>&emsp;&emsp;&emsp;&emsp;float mMinBodyDistance = 3.40282e+038;<br>&emsp;&emsp;&emsp;&emsp;bool mInteract = 0; //  If set to true, telekinesis interaction will occur. Will automatically turn to false at the end of component update.<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="min_size" type="xs:unsignedInt" default="7">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint32 min_size = 7; //  Minimum size of physics body that can be grabbed, in cells/pixels<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="max_size" type="xs:unsignedInt" default="1500">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint32 max_size = 1500; //  Maximum size of physics body that can be grabbed, in cells/pixels<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="radius" type="xs:decimal" default="250">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float radius = 250; // [0, 300] Maximum object search distance<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="throw_speed" type="xs:decimal" default="25">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float throw_speed = 25; // [0, 300] Affects object speed when it is thrown<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="target_distance" type="xs:decimal" default="6">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float target_distance = 6; // [0, 30] Affects how far objects float from owner when held. Object size will also affect the floating distance.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="kick_to_use" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool kick_to_use = 1; //  If 1, telekinesis interaction will occur when kick input is detected in root entity's ControlsComponent<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mState" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int32 mState = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mBodyID" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint64 mBodyID = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mStartBodyMaxExtent" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mStartBodyMaxExtent = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mStartAimAngle" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mStartAimAngle = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mStartBodyAngle" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mStartBodyAngle = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mStartBodyDistance" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mStartBodyDistance = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mStartTime" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mStartTime = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mMinBodyDistance" type="xs:decimal" default="340282000000000014192072600942972764160">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mMinBodyDistance = 3.40282e+038;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mInteract" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mInteract = 0; //  If set to true, telekinesis interaction will occur. Will automatically turn to false at the end of component update.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="TeleportComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class TeleportComponent {<br>&emsp;&emsp;&emsp;&emsp;bool target_x_is_absolute_position = 0; //  If set, target position x is in world coordinates, otherwise it's an offset<br>&emsp;&emsp;&emsp;&emsp;bool target_y_is_absolute_position = 0; //  If set, target position y is in world coordinates, otherwise it's an offset<br>&emsp;&emsp;&emsp;&emsp;std::string source_particle_fx_file = "data/entities/particles/teleportation_source.xml"; //  This entity is loaded at the source position when teleportation occurs<br>&emsp;&emsp;&emsp;&emsp;std::string target_particle_fx_file = "data/entities/particles/teleportation_target.xml"; //  This entity is loaded at the target position when teleportation occurs<br>&emsp;&emsp;&emsp;&emsp;bool load_collapse_entity = 1; //  if we don't want things to collapse after the teleport<br>&emsp;&emsp;&emsp;&emsp;vec2 target; //  Where should we teleport<br>&emsp;&emsp;&emsp;&emsp;int safety_counter = 0; //  used to keep track that we're not stuck in waiting for a pixel scene to load, that is not going to be loaded<br>&emsp;&emsp;&emsp;&emsp;TeleportComponentState::Enum state;<br>&emsp;&emsp;&emsp;&emsp;ENTITY_VEC teleported_entities;<br>&emsp;&emsp;&emsp;&emsp;types::aabb source_location_camera_aabb;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="target_x_is_absolute_position" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool target_x_is_absolute_position = 0; //  If set, target position x is in world coordinates, otherwise it's an offset<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="target_y_is_absolute_position" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool target_y_is_absolute_position = 0; //  If set, target position y is in world coordinates, otherwise it's an offset<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="source_particle_fx_file" type="xs:string" default="data/entities/particles/teleportation_source.xml">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string source_particle_fx_file = "data/entities/particles/teleportation_source.xml"; //  This entity is loaded at the source position when teleportation occurs<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="target_particle_fx_file" type="xs:string" default="data/entities/particles/teleportation_target.xml">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string target_particle_fx_file = "data/entities/particles/teleportation_target.xml"; //  This entity is loaded at the target position when teleportation occurs<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="load_collapse_entity" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool load_collapse_entity = 1; //  if we don't want things to collapse after the teleport<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="target.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 target; //  Where should we teleport<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="target.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 target; //  Where should we teleport<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="safety_counter" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int safety_counter = 0; //  used to keep track that we're not stuck in waiting for a pixel scene to load, that is not going to be loaded<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="state" type="TeleportComponentState" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>TeleportComponentState::Enum state;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: ENTITY_VEC for teleported_entities -->
		<xs:attribute name="source_location_camera_aabb.min_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>types::aabb source_location_camera_aabb;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="source_location_camera_aabb.min_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>types::aabb source_location_camera_aabb;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="source_location_camera_aabb.max_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>types::aabb source_location_camera_aabb;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="source_location_camera_aabb.max_y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>types::aabb source_location_camera_aabb;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="TeleportProjectileComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class TeleportProjectileComponent {<br>&emsp;&emsp;&emsp;&emsp;float min_distance_from_wall = 16; // [0, 16] <br>&emsp;&emsp;&emsp;&emsp;int actionable_lifetime = 3; // [0, 20] <br>&emsp;&emsp;&emsp;&emsp;bool reset_shooter_y_vel = 1; //  If 1, will set shooter y velocity to 0 on teleport<br>&emsp;&emsp;&emsp;&emsp;EntityID mWhoShot = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="min_distance_from_wall" type="xs:decimal" default="16">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float min_distance_from_wall = 16; // [0, 16] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="actionable_lifetime" type="xs:int" default="3">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int actionable_lifetime = 3; // [0, 20] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="reset_shooter_y_vel" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool reset_shooter_y_vel = 1; //  If 1, will set shooter y velocity to 0 on teleport<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: EntityID for mWhoShot -->
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="TextLogComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class TextLogComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string key;<br>&emsp;&emsp;&emsp;&emsp;std::string image_filename;<br>&emsp;&emsp;&emsp;&emsp;std::string mCachedName;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="key" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string key;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="image_filename" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string image_filename;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mCachedName" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string mCachedName;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="TorchComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class TorchComponent {<br>&emsp;&emsp;&emsp;&emsp;int probability_of_ignition_attempt = 15; // [0, 100] how likely are we to ignite colliding cells<br>&emsp;&emsp;&emsp;&emsp;float suffocation_check_offset_y = -2; // [-10, 10] check offset in world coordinates from our position<br>&emsp;&emsp;&emsp;&emsp;int frames_suffocated_to_extinguish = 5; // [0, 30] how many frames the torch needs to be suffocated before it stops emitting fire<br>&emsp;&emsp;&emsp;&emsp;bool extinguishable = 1; //  if 1, the torch needs to be re-ignited in case it is turned off<br>&emsp;&emsp;&emsp;&emsp;float fire_audio_weight = 0; // [0, 2] how loud is the sound of our fire? 0 = no sound<br>&emsp;&emsp;&emsp;&emsp;float mFlickerOffset = 0;<br>&emsp;&emsp;&emsp;&emsp;int mFramesSuffocated = 0;<br>&emsp;&emsp;&emsp;&emsp;bool mIsOn = 1;<br>&emsp;&emsp;&emsp;&emsp;bool mFireIsBurningPrev = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="probability_of_ignition_attempt" type="xs:int" default="15">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int probability_of_ignition_attempt = 15; // [0, 100] how likely are we to ignite colliding cells<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="suffocation_check_offset_y" type="xs:decimal" default="-2">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float suffocation_check_offset_y = -2; // [-10, 10] check offset in world coordinates from our position<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="frames_suffocated_to_extinguish" type="xs:int" default="5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int frames_suffocated_to_extinguish = 5; // [0, 30] how many frames the torch needs to be suffocated before it stops emitting fire<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="extinguishable" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool extinguishable = 1; //  if 1, the torch needs to be re-ignited in case it is turned off<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fire_audio_weight" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float fire_audio_weight = 0; // [0, 2] how loud is the sound of our fire? 0 = no sound<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mFlickerOffset" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mFlickerOffset = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mFramesSuffocated" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mFramesSuffocated = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mIsOn" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mIsOn = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mFireIsBurningPrev" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mFireIsBurningPrev = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="UIIconComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class UIIconComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string icon_sprite_file;<br>&emsp;&emsp;&emsp;&emsp;std::string name;<br>&emsp;&emsp;&emsp;&emsp;std::string description;<br>&emsp;&emsp;&emsp;&emsp;bool display_above_head = 0;<br>&emsp;&emsp;&emsp;&emsp;bool display_in_hud = 1;<br>&emsp;&emsp;&emsp;&emsp;bool is_perk = 1;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="icon_sprite_file" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string icon_sprite_file;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="name" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string name;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="description" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string description;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="display_above_head" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool display_above_head = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="display_in_hud" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool display_in_hud = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_perk" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_perk = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="UIInfoComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class UIInfoComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string name;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="name" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string name;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="VariableStorageComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class VariableStorageComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string name;<br>&emsp;&emsp;&emsp;&emsp;std::string value_string;<br>&emsp;&emsp;&emsp;&emsp;int value_int = 0;<br>&emsp;&emsp;&emsp;&emsp;bool value_bool = 0;<br>&emsp;&emsp;&emsp;&emsp;float value_float = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="name" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string name;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="value_string" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string value_string;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="value_int" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int value_int = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="value_bool" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool value_bool = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="value_float" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float value_float = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="VelocityComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class VelocityComponent {<br>&emsp;&emsp;&emsp;&emsp;float gravity_x = 0;<br>&emsp;&emsp;&emsp;&emsp;float gravity_y = 400;<br>&emsp;&emsp;&emsp;&emsp;float mass = 0.05; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;float air_friction = 0.55;<br>&emsp;&emsp;&emsp;&emsp;float terminal_velocity = 1000;<br>&emsp;&emsp;&emsp;&emsp;bool apply_terminal_velocity = 1;<br>&emsp;&emsp;&emsp;&emsp;bool updates_velocity = 1;<br>&emsp;&emsp;&emsp;&emsp;bool displace_liquid = 1;<br>&emsp;&emsp;&emsp;&emsp;bool affect_physics_bodies = 0; //  if true, will move the physics body by the difference of mVelocity to the previous frame<br>&emsp;&emsp;&emsp;&emsp;bool limit_to_max_velocity = 1; //  if true will limit the velocity to 61440. You can turn this off, but it's not recommended, since there are some nasty bugs that can happen with extremely high velocities.<br>&emsp;&emsp;&emsp;&emsp;int liquid_death_threshold = 0; //  if > 0, entity will die if liquid hit count is greater than this.<br>&emsp;&emsp;&emsp;&emsp;float liquid_drag = 1; //  1 = slows down in liquid, 0 = doesn't slow down at all<br>&emsp;&emsp;&emsp;&emsp;vec2 mVelocity;<br>&emsp;&emsp;&emsp;&emsp;vec2 mPrevVelocity; //  used to update physics bodies<br>&emsp;&emsp;&emsp;&emsp;int mLatestLiquidHitCount = 0;<br>&emsp;&emsp;&emsp;&emsp;int mAverageLiquidHitCount = 0;<br>&emsp;&emsp;&emsp;&emsp;ivec2 mPrevPosition;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="gravity_x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float gravity_x = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="gravity_y" type="xs:decimal" default="400">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float gravity_y = 400;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mass" type="xs:decimal" default="0.05">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mass = 0.05; // [0, 10] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="air_friction" type="xs:decimal" default="0.55">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float air_friction = 0.55;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="terminal_velocity" type="xs:decimal" default="1000">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float terminal_velocity = 1000;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="apply_terminal_velocity" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool apply_terminal_velocity = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="updates_velocity" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool updates_velocity = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="displace_liquid" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool displace_liquid = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="affect_physics_bodies" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool affect_physics_bodies = 0; //  if true, will move the physics body by the difference of mVelocity to the previous frame<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="limit_to_max_velocity" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool limit_to_max_velocity = 1; //  if true will limit the velocity to 61440. You can turn this off, but it's not recommended, since there are some nasty bugs that can happen with extremely high velocities.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="liquid_death_threshold" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int liquid_death_threshold = 0; //  if > 0, entity will die if liquid hit count is greater than this.<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="liquid_drag" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float liquid_drag = 1; //  1 = slows down in liquid, 0 = doesn't slow down at all<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mVelocity.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mVelocity;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mVelocity.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mVelocity;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevVelocity.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mPrevVelocity; //  used to update physics bodies<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevVelocity.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mPrevVelocity; //  used to update physics bodies<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mLatestLiquidHitCount" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mLatestLiquidHitCount = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mAverageLiquidHitCount" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mAverageLiquidHitCount = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevPosition.x" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 mPrevPosition;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevPosition.y" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>ivec2 mPrevPosition;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="VerletPhysicsComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class VerletPhysicsComponent {<br>&emsp;&emsp;&emsp;&emsp;int num_points = 2;<br>&emsp;&emsp;&emsp;&emsp;int num_links = 2;<br>&emsp;&emsp;&emsp;&emsp;int width = 1;<br>&emsp;&emsp;&emsp;&emsp;float resting_distance = 2; // [0, 16] <br>&emsp;&emsp;&emsp;&emsp;float mass_min = 0.8; // [0.03, 2] <br>&emsp;&emsp;&emsp;&emsp;float mass_max = 1; // [0.03, 2] <br>&emsp;&emsp;&emsp;&emsp;float stiffness = 1;<br>&emsp;&emsp;&emsp;&emsp;float velocity_dampening = 0.99; // [0.2, 1] <br>&emsp;&emsp;&emsp;&emsp;float liquid_damping = 0.7; //  how much we dampen when in liquid<br>&emsp;&emsp;&emsp;&emsp;float gets_entity_velocity_coeff = 0; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;bool collide_with_cells = 1;<br>&emsp;&emsp;&emsp;&emsp;bool simulate_gravity = 1;<br>&emsp;&emsp;&emsp;&emsp;bool simulate_wind = 1;<br>&emsp;&emsp;&emsp;&emsp;float wind_change_speed = 1;<br>&emsp;&emsp;&emsp;&emsp;bool constrain_stretching = 0;<br>&emsp;&emsp;&emsp;&emsp;bool pixelate_sprite_transforms = 1;<br>&emsp;&emsp;&emsp;&emsp;bool scale_sprite_x = 1;<br>&emsp;&emsp;&emsp;&emsp;bool follow_entity_transform = 1;<br>&emsp;&emsp;&emsp;&emsp;float animation_amount = 2;<br>&emsp;&emsp;&emsp;&emsp;float animation_speed = 5;<br>&emsp;&emsp;&emsp;&emsp;float animation_energy = 0.6;<br>&emsp;&emsp;&emsp;&emsp;float cloth_sprite_z_index = 1;<br>&emsp;&emsp;&emsp;&emsp;int stain_cells_probability = 0; //  0 = never, 1 = most likely, 10 = less likely - and so on<br>&emsp;&emsp;&emsp;&emsp;bool m_is_culled_previous = 0; //  Developer note: this needs to be serialized in case we serialize SpriteComponent.is_visible<br>&emsp;&emsp;&emsp;&emsp;VERLET_TYPE::Enum type;<br>&emsp;&emsp;&emsp;&emsp;vec2 animation_target_offset;<br>&emsp;&emsp;&emsp;&emsp;uint32 cloth_color_edge = 4288376730;<br>&emsp;&emsp;&emsp;&emsp;uint32 cloth_color = 4286534774;<br>&emsp;&emsp;&emsp;&emsp;vec2 m_position_previous;<br>&emsp;&emsp;&emsp;&emsp;UintArrayInline colors;<br>&emsp;&emsp;&emsp;&emsp;UintArrayInline materials;<br>&emsp;&emsp;&emsp;&emsp;FloatArrayInline masses;<br>&emsp;&emsp;&emsp;&emsp;Vec2ArrayInline positions;<br>&emsp;&emsp;&emsp;&emsp;Vec2ArrayInline positions_prev;<br>&emsp;&emsp;&emsp;&emsp;Vec2ArrayInline velocities;<br>&emsp;&emsp;&emsp;&emsp;FloatArrayInline dampenings;<br>&emsp;&emsp;&emsp;&emsp;FloatArrayInline freedoms;<br>&emsp;&emsp;&emsp;&emsp;VerletLinkArrayInline links;<br>&emsp;&emsp;&emsp;&emsp;VerletSprite* sprite;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="num_points" type="xs:int" default="2">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int num_points = 2;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="num_links" type="xs:int" default="2">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int num_links = 2;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="width" type="xs:int" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int width = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="resting_distance" type="xs:decimal" default="2">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float resting_distance = 2; // [0, 16] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mass_min" type="xs:decimal" default="0.8">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mass_min = 0.8; // [0.03, 2] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mass_max" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mass_max = 1; // [0.03, 2] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="stiffness" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float stiffness = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="velocity_dampening" type="xs:decimal" default="0.99">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float velocity_dampening = 0.99; // [0.2, 1] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="liquid_damping" type="xs:decimal" default="0.7">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float liquid_damping = 0.7; //  how much we dampen when in liquid<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="gets_entity_velocity_coeff" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float gets_entity_velocity_coeff = 0; // [0, 10] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="collide_with_cells" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool collide_with_cells = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="simulate_gravity" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool simulate_gravity = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="simulate_wind" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool simulate_wind = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="wind_change_speed" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float wind_change_speed = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="constrain_stretching" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool constrain_stretching = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="pixelate_sprite_transforms" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool pixelate_sprite_transforms = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="scale_sprite_x" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool scale_sprite_x = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="follow_entity_transform" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool follow_entity_transform = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="animation_amount" type="xs:decimal" default="2">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float animation_amount = 2;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="animation_speed" type="xs:decimal" default="5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float animation_speed = 5;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="animation_energy" type="xs:decimal" default="0.6">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float animation_energy = 0.6;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="cloth_sprite_z_index" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float cloth_sprite_z_index = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="stain_cells_probability" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int stain_cells_probability = 0; //  0 = never, 1 = most likely, 10 = less likely - and so on<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="m_is_culled_previous" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool m_is_culled_previous = 0; //  Developer note: this needs to be serialized in case we serialize SpriteComponent.is_visible<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="type" type="VERLET_TYPE" default="CHAIN">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>VERLET_TYPE::Enum type;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="animation_target_offset.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 animation_target_offset;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="animation_target_offset.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 animation_target_offset;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="cloth_color_edge" type="xs:unsignedInt" default="4288376730">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint32 cloth_color_edge = 4288376730;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="cloth_color" type="xs:unsignedInt" default="4286534774">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint32 cloth_color = 4286534774;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="m_position_previous.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 m_position_previous;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="m_position_previous.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 m_position_previous;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: UintArrayInline for colors -->
		<!-- Some Unknown Type: UintArrayInline for materials -->
		<!-- Some Unknown Type: FloatArrayInline for masses -->
		<!-- Some Unknown Type: Vec2ArrayInline for positions -->
		<!-- Some Unknown Type: Vec2ArrayInline for positions_prev -->
		<!-- Some Unknown Type: Vec2ArrayInline for velocities -->
		<!-- Some Unknown Type: FloatArrayInline for dampenings -->
		<!-- Some Unknown Type: FloatArrayInline for freedoms -->
		<!-- Some Unknown Type: VerletLinkArrayInline for links -->
		<!-- Some Unknown Type: VerletSprite* for sprite -->
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="VerletWeaponComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class VerletWeaponComponent {<br>&emsp;&emsp;&emsp;&emsp;float damage_radius = 5; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;float physics_force_radius = 3; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;float damage_min_step = 0.01; // [0, 3.5] <br>&emsp;&emsp;&emsp;&emsp;float damage_max = 1; // [0, 3.5] <br>&emsp;&emsp;&emsp;&emsp;float damage_coeff = 1; // [0, 3.5] <br>&emsp;&emsp;&emsp;&emsp;float impulse_coeff = 1; // [0, 3.5] <br>&emsp;&emsp;&emsp;&emsp;int fade_duration_frames = 10; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;float physics_impulse_coeff = 1; // [0, 3.5] <br>&emsp;&emsp;&emsp;&emsp;int mPlayerCooldownEnd = -1;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="damage_radius" type="xs:decimal" default="5">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float damage_radius = 5; // [0, 10] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="physics_force_radius" type="xs:decimal" default="3">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float physics_force_radius = 3; // [0, 10] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_min_step" type="xs:decimal" default="0.01">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float damage_min_step = 0.01; // [0, 3.5] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_max" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float damage_max = 1; // [0, 3.5] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_coeff" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float damage_coeff = 1; // [0, 3.5] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="impulse_coeff" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float impulse_coeff = 1; // [0, 3.5] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fade_duration_frames" type="xs:int" default="10">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int fade_duration_frames = 10; // [0, 100] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="physics_impulse_coeff" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float physics_impulse_coeff = 1; // [0, 3.5] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPlayerCooldownEnd" type="xs:int" default="-1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mPlayerCooldownEnd = -1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="VerletWorldJointComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class VerletWorldJointComponent {<br>&emsp;&emsp;&emsp;&emsp;int verlet_point_index = 0; // [0, 32] Index of the verlet point we attach<br>&emsp;&emsp;&emsp;&emsp;vec2 world_position; //  Where we attach the verlet point<br>&emsp;&emsp;&emsp;&emsp;bool mUpdated = 0;<br>&emsp;&emsp;&emsp;&emsp;grid::ICell* mCell;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="verlet_point_index" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int verlet_point_index = 0; // [0, 32] Index of the verlet point we attach<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="world_position.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 world_position; //  Where we attach the verlet point<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="world_position.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 world_position; //  Where we attach the verlet point<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mUpdated" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mUpdated = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: grid::ICell* for mCell -->
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="WalletComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class WalletComponent {<br>&emsp;&emsp;&emsp;&emsp;int64 money = 0; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;int64 money_spent = 0; //  tracks how much money the player has spent<br>&emsp;&emsp;&emsp;&emsp;int64 mMoneyPrevFrame = 0; //  HAX to give player towards infinite moneys<br>&emsp;&emsp;&emsp;&emsp;bool mHasReachedInf = 0; //  once it hits this value... keep it there<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="money" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int64 money = 0; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="money_spent" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int64 money_spent = 0; //  tracks how much money the player has spent<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mMoneyPrevFrame" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int64 mMoneyPrevFrame = 0; //  HAX to give player towards infinite moneys<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mHasReachedInf" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mHasReachedInf = 0; //  once it hits this value... keep it there<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="WalletValuableComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class WalletValuableComponent {<br>&emsp;&emsp;&emsp;&emsp;int money_value = 10; // [0, 100] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="money_value" type="xs:int" default="10">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int money_value = 10; // [0, 100] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="WorldStateComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class WorldStateComponent {<br>&emsp;&emsp;&emsp;&emsp;bool is_initialized = 0;<br>&emsp;&emsp;&emsp;&emsp;float time = 0;<br>&emsp;&emsp;&emsp;&emsp;float time_total = 0; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;float time_dt = 1; // [0, 1000] to make the time go really fast or slow?<br>&emsp;&emsp;&emsp;&emsp;int day_count = 0; // [0, 3.5] <br>&emsp;&emsp;&emsp;&emsp;float rain = 0; //  should be called clouds, controls amount of cloud cover in the sky<br>&emsp;&emsp;&emsp;&emsp;float rain_target = 0; //  should be called clouds_target, controls amount of cloud cover in the sky<br>&emsp;&emsp;&emsp;&emsp;float fog = 0;<br>&emsp;&emsp;&emsp;&emsp;float fog_target = 0;<br>&emsp;&emsp;&emsp;&emsp;bool intro_weather = 0; //  if set, will set the weather to be nice all the time<br>&emsp;&emsp;&emsp;&emsp;float wind = 0;<br>&emsp;&emsp;&emsp;&emsp;float wind_speed = 2; // [-50, 50] <br>&emsp;&emsp;&emsp;&emsp;float wind_speed_sin_t = 10;<br>&emsp;&emsp;&emsp;&emsp;float wind_speed_sin = 3; // [-50, 50] <br>&emsp;&emsp;&emsp;&emsp;float clouds_01_target = 0; // [-27, 100] <br>&emsp;&emsp;&emsp;&emsp;float clouds_02_target = 0; // [-100, 185] <br>&emsp;&emsp;&emsp;&emsp;float gradient_sky_alpha_target = 0;<br>&emsp;&emsp;&emsp;&emsp;float sky_sunset_alpha_target = 1;<br>&emsp;&emsp;&emsp;&emsp;int lightning_count = 0; // [0, 100] this gets decreased to 0, this is the frame count of how many times do we do our awesome lightning effect<br>&emsp;&emsp;&emsp;&emsp;uint32 next_portal_id = 1;<br>&emsp;&emsp;&emsp;&emsp;std::string session_stat_file; //  if empty, we'll create one. This tracks the play time, death, kills... etch<br>&emsp;&emsp;&emsp;&emsp;int player_polymorph_count = 0; //  how many times player has been polymorphed<br>&emsp;&emsp;&emsp;&emsp;int player_polymorph_random_count = 0; //  how many times player has been random polymorphed<br>&emsp;&emsp;&emsp;&emsp;int player_did_infinite_spell_count = 0; //  how many times player has done a secret trick<br>&emsp;&emsp;&emsp;&emsp;int player_did_damage_over_1milj = 0; //  how many times player has player done damage of over 1000000<br>&emsp;&emsp;&emsp;&emsp;int player_living_with_minus_hp = 0; //  how many times player has been detected with minus health<br>&emsp;&emsp;&emsp;&emsp;float global_genome_relations_modifier = 0; //  Genome_GetHerdRelation adds this value to the results. 100 = good relations, 0 is bad <br>&emsp;&emsp;&emsp;&emsp;bool mods_have_been_active_during_this_run = 0;<br>&emsp;&emsp;&emsp;&emsp;bool twitch_has_been_active_during_this_run = 0;<br>&emsp;&emsp;&emsp;&emsp;uint32 next_cut_through_world_id = 0;<br>&emsp;&emsp;&emsp;&emsp;bool perk_infinite_spells = 0; //  if true, almost all spells will have unlimited uses. (black holes, matter eater, heals excluded<br>&emsp;&emsp;&emsp;&emsp;bool perk_trick_kills_blood_money = 0; //  if true, trick kills will produce blood money (heals player)<br>&emsp;&emsp;&emsp;&emsp;int perk_hp_drop_chance = 0; //  if > 0, then there's chance that killing an enemy will drop bloodmoney_50<br>&emsp;&emsp;&emsp;&emsp;bool perk_gold_is_forever = 0; //  drop_money.lua - checks if this is true and removes Lifetime_Component from gold nuggets<br>&emsp;&emsp;&emsp;&emsp;bool perk_rats_player_friendly = 0; //  if 1, rats don't attack player herd and the other way round. this is a persistent change<br>&emsp;&emsp;&emsp;&emsp;bool EVERYTHING_TO_GOLD = 0; //  if true everything will be gold + used to track if the wallet should go to infinite<br>&emsp;&emsp;&emsp;&emsp;std::string material_everything_to_gold = "gold";<br>&emsp;&emsp;&emsp;&emsp;std::string material_everything_to_gold_static = "gold_static";<br>&emsp;&emsp;&emsp;&emsp;bool INFINITE_GOLD_HAPPENING = 0; //  the secret ending with infinite gold<br>&emsp;&emsp;&emsp;&emsp;bool ENDING_HAPPINESS_HAPPENING = 0; //  if true, will do the animations for happiness ending<br>&emsp;&emsp;&emsp;&emsp;int ENDING_HAPPINESS_FRAMES = 0; //  to keep track of the animation<br>&emsp;&emsp;&emsp;&emsp;bool ENDING_HAPPINESS = 0; //  this is set if ending happiness has happened<br>&emsp;&emsp;&emsp;&emsp;float mFlashAlpha = 0; //  to keep track of the animation<br>&emsp;&emsp;&emsp;&emsp;int DEBUG_LOADED_FROM_AUTOSAVE = 0; //  how many times have loaded from autosaves<br>&emsp;&emsp;&emsp;&emsp;int DEBUG_LOADED_FROM_OLD_VERSION = 0; //  how many times have we loaded from an old version of the game<br>&emsp;&emsp;&emsp;&emsp;vec2 player_spawn_location;<br>&emsp;&emsp;&emsp;&emsp;MAP_STRING_STRING lua_globals;<br>&emsp;&emsp;&emsp;&emsp;VEC_PENDINGPORTAL pending_portals;<br>&emsp;&emsp;&emsp;&emsp;VECTOR_INT32 apparitions_per_level;<br>&emsp;&emsp;&emsp;&emsp;VEC_NPCPARTY npc_parties;<br>&emsp;&emsp;&emsp;&emsp;VECTOR_INT32 orbs_found_thisrun;<br>&emsp;&emsp;&emsp;&emsp;VECTOR_STRING flags;<br>&emsp;&emsp;&emsp;&emsp;VECTOR_STRING changed_materials; //  pairs of materials changed via ConvertMaterialEverywhere(). stored so these can be restored when loading a save<br>&emsp;&emsp;&emsp;&emsp;VEC_CUTTHROUGHWORLD cuts_through_world;<br>&emsp;&emsp;&emsp;&emsp;LensValue<int> gore_multiplier;<br>&emsp;&emsp;&emsp;&emsp;LensValue<int> trick_kill_gold_multiplier;<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> damage_flash_multiplier;<br>&emsp;&emsp;&emsp;&emsp;LensValue<bool> open_fog_of_war_everywhere; //  same as the trailer mode, open fog of war everywhere<br>&emsp;&emsp;&emsp;&emsp;LensValue<bool> consume_actions; //  same as the trailer mode, spells with limited uses are not consumed if this is false<br>&emsp;&emsp;&emsp;&emsp;float rain_target_extra = 0;<br>&emsp;&emsp;&emsp;&emsp;float fog_target_extra = 0;<br>&emsp;&emsp;&emsp;&emsp;bool perk_rats_player_friendly_prev = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="is_initialized" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_initialized = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="time" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float time = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="time_total" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float time_total = 0; // [0, 1000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="time_dt" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float time_dt = 1; // [0, 1000] to make the time go really fast or slow?<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="day_count" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int day_count = 0; // [0, 3.5] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="rain" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float rain = 0; //  should be called clouds, controls amount of cloud cover in the sky<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="rain_target" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float rain_target = 0; //  should be called clouds_target, controls amount of cloud cover in the sky<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fog" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float fog = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fog_target" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float fog_target = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="intro_weather" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool intro_weather = 0; //  if set, will set the weather to be nice all the time<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="wind" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float wind = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="wind_speed" type="xs:decimal" default="2">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float wind_speed = 2; // [-50, 50] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="wind_speed_sin_t" type="xs:decimal" default="10">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float wind_speed_sin_t = 10;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="wind_speed_sin" type="xs:decimal" default="3">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float wind_speed_sin = 3; // [-50, 50] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="clouds_01_target" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float clouds_01_target = 0; // [-27, 100] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="clouds_02_target" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float clouds_02_target = 0; // [-100, 185] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="gradient_sky_alpha_target" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float gradient_sky_alpha_target = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="sky_sunset_alpha_target" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float sky_sunset_alpha_target = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lightning_count" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int lightning_count = 0; // [0, 100] this gets decreased to 0, this is the frame count of how many times do we do our awesome lightning effect<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="next_portal_id" type="xs:unsignedInt" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint32 next_portal_id = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="session_stat_file" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string session_stat_file; //  if empty, we'll create one. This tracks the play time, death, kills... etch<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="player_polymorph_count" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int player_polymorph_count = 0; //  how many times player has been polymorphed<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="player_polymorph_random_count" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int player_polymorph_random_count = 0; //  how many times player has been random polymorphed<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="player_did_infinite_spell_count" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int player_did_infinite_spell_count = 0; //  how many times player has done a secret trick<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="player_did_damage_over_1milj" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int player_did_damage_over_1milj = 0; //  how many times player has player done damage of over 1000000<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="player_living_with_minus_hp" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int player_living_with_minus_hp = 0; //  how many times player has been detected with minus health<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="global_genome_relations_modifier" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float global_genome_relations_modifier = 0; //  Genome_GetHerdRelation adds this value to the results. 100 = good relations, 0 is bad <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mods_have_been_active_during_this_run" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mods_have_been_active_during_this_run = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="twitch_has_been_active_during_this_run" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool twitch_has_been_active_during_this_run = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="next_cut_through_world_id" type="xs:unsignedInt" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>uint32 next_cut_through_world_id = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="perk_infinite_spells" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool perk_infinite_spells = 0; //  if true, almost all spells will have unlimited uses. (black holes, matter eater, heals excluded<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="perk_trick_kills_blood_money" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool perk_trick_kills_blood_money = 0; //  if true, trick kills will produce blood money (heals player)<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="perk_hp_drop_chance" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int perk_hp_drop_chance = 0; //  if > 0, then there's chance that killing an enemy will drop bloodmoney_50<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="perk_gold_is_forever" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool perk_gold_is_forever = 0; //  drop_money.lua - checks if this is true and removes Lifetime_Component from gold nuggets<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="perk_rats_player_friendly" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool perk_rats_player_friendly = 0; //  if 1, rats don't attack player herd and the other way round. this is a persistent change<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="EVERYTHING_TO_GOLD" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool EVERYTHING_TO_GOLD = 0; //  if true everything will be gold + used to track if the wallet should go to infinite<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="material_everything_to_gold" type="xs:string" default="gold">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string material_everything_to_gold = "gold";<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="material_everything_to_gold_static" type="xs:string" default="gold_static">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string material_everything_to_gold_static = "gold_static";<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="INFINITE_GOLD_HAPPENING" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool INFINITE_GOLD_HAPPENING = 0; //  the secret ending with infinite gold<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ENDING_HAPPINESS_HAPPENING" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool ENDING_HAPPINESS_HAPPENING = 0; //  if true, will do the animations for happiness ending<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ENDING_HAPPINESS_FRAMES" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int ENDING_HAPPINESS_FRAMES = 0; //  to keep track of the animation<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ENDING_HAPPINESS" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool ENDING_HAPPINESS = 0; //  this is set if ending happiness has happened<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mFlashAlpha" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mFlashAlpha = 0; //  to keep track of the animation<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="DEBUG_LOADED_FROM_AUTOSAVE" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int DEBUG_LOADED_FROM_AUTOSAVE = 0; //  how many times have loaded from autosaves<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="DEBUG_LOADED_FROM_OLD_VERSION" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int DEBUG_LOADED_FROM_OLD_VERSION = 0; //  how many times have we loaded from an old version of the game<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="player_spawn_location.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 player_spawn_location;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="player_spawn_location.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 player_spawn_location;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: MAP_STRING_STRING for lua_globals -->
		<!-- Some Unknown Type: VEC_PENDINGPORTAL for pending_portals -->
		<!-- Some Unknown Type: VECTOR_INT32 for apparitions_per_level -->
		<!-- Some Unknown Type: VEC_NPCPARTY for npc_parties -->
		<!-- Some Unknown Type: VECTOR_INT32 for orbs_found_thisrun -->
		<!-- Some Unknown Type: VECTOR_STRING for flags -->
		<!-- Some Unknown Type: VECTOR_STRING for changed_materials -->
		<!-- Some Unknown Type: VEC_CUTTHROUGHWORLD for cuts_through_world -->
		<xs:attribute name="gore_multiplier" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>LensValue<int> gore_multiplier;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="trick_kill_gold_multiplier" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>LensValue<int> trick_kill_gold_multiplier;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="damage_flash_multiplier" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>LensValue<float> damage_flash_multiplier;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="open_fog_of_war_everywhere" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>LensValue<bool> open_fog_of_war_everywhere; //  same as the trailer mode, open fog of war everywhere<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="consume_actions" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>LensValue<bool> consume_actions; //  same as the trailer mode, spells with limited uses are not consumed if this is false<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="rain_target_extra" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float rain_target_extra = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fog_target_extra" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float fog_target_extra = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="perk_rats_player_friendly_prev" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool perk_rats_player_friendly_prev = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="WormAIComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class WormAIComponent {<br>&emsp;&emsp;&emsp;&emsp;float speed = 1; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float speed_hunt = 3; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float direction_adjust_speed = 1; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float direction_adjust_speed_hunt = 1; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float random_target_box_radius = 512; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;int new_hunt_target_check_every = 30; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;int new_random_target_check_every = 120; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float hunt_box_radius = 512; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;int cocoon_food_required = 30; //  how much food do we need to consume before we can cocoon<br>&emsp;&emsp;&emsp;&emsp;std::string cocoon_entity; //  if empty, won't cocoon, if set it'll spawn this after it's eaten enough<br>&emsp;&emsp;&emsp;&emsp;float give_up_area_radius = 50; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;int give_up_time_frames = 300; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;bool debug_follow_mouse = 0;<br>&emsp;&emsp;&emsp;&emsp;vec2 mRandomTarget;<br>&emsp;&emsp;&emsp;&emsp;int mTargetEntityId = 0;<br>&emsp;&emsp;&emsp;&emsp;int mNextTargetCheckFrame = 0;<br>&emsp;&emsp;&emsp;&emsp;int mNextHuntTargetCheckFrame = 0;<br>&emsp;&emsp;&emsp;&emsp;int mGiveUpStarted = 0;<br>&emsp;&emsp;&emsp;&emsp;int mGiveUpAreaMinX = 0;<br>&emsp;&emsp;&emsp;&emsp;int mGiveUpAreaMinY = 0;<br>&emsp;&emsp;&emsp;&emsp;int mGiveUpAreaMaxX = 0;<br>&emsp;&emsp;&emsp;&emsp;int mGiveUpAreaMaxY = 0;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="speed" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float speed = 1; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="speed_hunt" type="xs:decimal" default="3">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float speed_hunt = 3; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="direction_adjust_speed" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float direction_adjust_speed = 1; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="direction_adjust_speed_hunt" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float direction_adjust_speed_hunt = 1; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="random_target_box_radius" type="xs:decimal" default="512">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float random_target_box_radius = 512; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="new_hunt_target_check_every" type="xs:int" default="30">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int new_hunt_target_check_every = 30; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="new_random_target_check_every" type="xs:int" default="120">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int new_random_target_check_every = 120; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="hunt_box_radius" type="xs:decimal" default="512">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float hunt_box_radius = 512; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="cocoon_food_required" type="xs:int" default="30">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int cocoon_food_required = 30; //  how much food do we need to consume before we can cocoon<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="cocoon_entity" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string cocoon_entity; //  if empty, won't cocoon, if set it'll spawn this after it's eaten enough<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="give_up_area_radius" type="xs:decimal" default="50">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float give_up_area_radius = 50; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="give_up_time_frames" type="xs:int" default="300">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int give_up_time_frames = 300; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="debug_follow_mouse" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool debug_follow_mouse = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mRandomTarget.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mRandomTarget;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mRandomTarget.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mRandomTarget;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mTargetEntityId" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mTargetEntityId = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mNextTargetCheckFrame" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mNextTargetCheckFrame = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mNextHuntTargetCheckFrame" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mNextHuntTargetCheckFrame = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mGiveUpStarted" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mGiveUpStarted = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mGiveUpAreaMinX" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mGiveUpAreaMinX = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mGiveUpAreaMinY" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mGiveUpAreaMinY = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mGiveUpAreaMaxX" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mGiveUpAreaMaxX = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mGiveUpAreaMaxY" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mGiveUpAreaMaxY = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="WormAttractorComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class WormAttractorComponent {<br>&emsp;&emsp;&emsp;&emsp;int direction = 1; // [-1, 1] 1 = attracts worms, -1 detracts worms<br>&emsp;&emsp;&emsp;&emsp;float radius = 50; // [0, 100] radius of detracting worms<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="direction" type="xs:int" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int direction = 1; // [-1, 1] 1 = attracts worms, -1 detracts worms<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="radius" type="xs:decimal" default="50">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float radius = 50; // [0, 100] radius of detracting worms<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="WormComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class WormComponent {<br>&emsp;&emsp;&emsp;&emsp;float speed = 1; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float acceleration = 3; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float gravity = 3; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float tail_gravity = 30; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float part_distance = 10; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;int ground_check_offset = 0; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float hitbox_radius = 1; // [0, 1e+006] <br>&emsp;&emsp;&emsp;&emsp;float bite_damage = 1; // [0, 10] how much damage does this do when it hits an entity<br>&emsp;&emsp;&emsp;&emsp;float target_kill_radius = 1; // [0, 1e+006] <br>&emsp;&emsp;&emsp;&emsp;float target_kill_ragdoll_force = 1; // [0, 1e+006] <br>&emsp;&emsp;&emsp;&emsp;float jump_cam_shake = 4; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float jump_cam_shake_distance = 256; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float eat_anim_wait_mult = 0.05; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;std::string ragdoll_filename;<br>&emsp;&emsp;&emsp;&emsp;bool is_water_worm = 0; //  if true, tries to stay in liquids<br>&emsp;&emsp;&emsp;&emsp;float max_speed = 25; //  max speed, used when attracted to a point<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> ground_decceleration;<br>&emsp;&emsp;&emsp;&emsp;vec2 mTargetVec;<br>&emsp;&emsp;&emsp;&emsp;float mGravVelocity = 0;<br>&emsp;&emsp;&emsp;&emsp;float mSpeed = 0;<br>&emsp;&emsp;&emsp;&emsp;vec2 mTargetPosition;<br>&emsp;&emsp;&emsp;&emsp;float mTargetSpeed = 0;<br>&emsp;&emsp;&emsp;&emsp;bool mOnGroundPrev = 0;<br>&emsp;&emsp;&emsp;&emsp;int mMaterialIdPrev = 0;<br>&emsp;&emsp;&emsp;&emsp;int mFrameNextDamage = 0;<br>&emsp;&emsp;&emsp;&emsp;float mDirectionAdjustSpeed = 1;<br>&emsp;&emsp;&emsp;&emsp;WormPartPositions mPrevPositions;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="speed" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float speed = 1; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="acceleration" type="xs:decimal" default="3">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float acceleration = 3; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="gravity" type="xs:decimal" default="3">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float gravity = 3; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="tail_gravity" type="xs:decimal" default="30">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float tail_gravity = 30; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="part_distance" type="xs:decimal" default="10">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float part_distance = 10; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ground_check_offset" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int ground_check_offset = 0; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="hitbox_radius" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float hitbox_radius = 1; // [0, 1e+006] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="bite_damage" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float bite_damage = 1; // [0, 10] how much damage does this do when it hits an entity<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="target_kill_radius" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float target_kill_radius = 1; // [0, 1e+006] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="target_kill_ragdoll_force" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float target_kill_ragdoll_force = 1; // [0, 1e+006] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="jump_cam_shake" type="xs:decimal" default="4">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float jump_cam_shake = 4; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="jump_cam_shake_distance" type="xs:decimal" default="256">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float jump_cam_shake_distance = 256; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="eat_anim_wait_mult" type="xs:decimal" default="0.05">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float eat_anim_wait_mult = 0.05; // [0, 10000] <br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ragdoll_filename" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>std::string ragdoll_filename;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_water_worm" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool is_water_worm = 0; //  if true, tries to stay in liquids<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="max_speed" type="xs:decimal" default="25">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float max_speed = 25; //  max speed, used when attracted to a point<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ground_decceleration" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>LensValue<float> ground_decceleration;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mTargetVec.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mTargetVec;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mTargetVec.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mTargetVec;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mGravVelocity" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mGravVelocity = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mSpeed" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mSpeed = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mTargetPosition.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mTargetPosition;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mTargetPosition.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mTargetPosition;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mTargetSpeed" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mTargetSpeed = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mOnGroundPrev" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>bool mOnGroundPrev = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mMaterialIdPrev" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mMaterialIdPrev = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mFrameNextDamage" type="xs:int" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>int mFrameNextDamage = 0;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mDirectionAdjustSpeed" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>float mDirectionAdjustSpeed = 1;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- Some Unknown Type: WormPartPositions for mPrevPositions -->
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	<xs:complexType name="WormPlayerComponent" mixed="true">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class WormPlayerComponent {<br>&emsp;&emsp;&emsp;&emsp;vec2 mPrevPosition;<br>&emsp;&emsp;&emsp;&emsp;vec2 mDirection; //  if mDirection == 0,0 nothings works<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:attribute name="mPrevPosition.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mPrevPosition;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mPrevPosition.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mPrevPosition;<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mDirection.x" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mDirection; //  if mDirection == 0,0 nothings works<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mDirection.y" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation><![CDATA[```cpp<br>vec2 mDirection; //  if mDirection == 0,0 nothings works<br>```]]></xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="CommonComponentAttributes"/>
	</xs:complexType>
	

	<!-- Material Graphics Edge Images Type -->
	<xs:complexType name="MaterialGraphicsEdgeImages">
		<xs:choice>
			<xs:element name="Image" maxOccurs="unbounded">
				<xs:complexType mixed="true">
					<xs:attribute name="do_only_horizontal_stripe" type="NoitaBool" />
					<xs:attribute name="do_only_vertical_stripe" type="NoitaBool" />
					<xs:attribute name="allow_random_rotation" type="NoitaBool" />
					<xs:attribute name="filename" type="xs:string" />
					<xs:attribute name="min_angle" type="xs:integer" />
					<xs:attribute name="max_angle" type="xs:integer" />
				</xs:complexType>
			</xs:element>
		</xs:choice>
	</xs:complexType>
	<!-- Material Graphics Edge Type -->
	<xs:complexType name="MaterialGraphicsEdge" mixed="true">
		<xs:sequence>
			<xs:element name="EdgeGraphics">
				<xs:complexType mixed="true">
					<xs:sequence>
						<xs:element name="Images" type="MaterialGraphicsEdgeImages" />
					</xs:sequence>
					<!-- wang -->
					<xs:attribute name="color" type="xs:string" />
					<xs:attribute name="overwrite" type="NoitaBool" />
					<xs:attribute name="percent" type="xs:decimal" />
					<xs:attribute name="require_same_material" type="NoitaBool" />
					<xs:attribute name="require_same_material_type" type="NoitaBool" />
					<!-- enum? -->
					<xs:attribute name="type" type="xs:string" />
					<xs:attribute name="z" type="xs:integer" />
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!-- Material Graphics Type -->
	<xs:complexType name="MaterialGraphics" mixed="true">
		<xs:choice>
			<xs:element name="Edge" type="MaterialGraphicsEdge" minOccurs="0" />
		</xs:choice>
		<!-- wang? -->
		<xs:attribute name="color" type="xs:string" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- enum? -->
		<xs:attribute name="fire_colors_index" type="xs:integer" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_grass" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_grass_hashed" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="normal_mapped" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- argb enum? -->
		<xs:attribute name="pixel_all_around" type="xs:string" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="pixel_bottom" type="xs:string" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="pixel_bottom_left" type="xs:string" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="pixel_bottom_right" type="xs:string" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="pixel_left" type="xs:string" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="pixel_lonely" type="xs:string" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="pixel_right" type="xs:string" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="pixel_top" type="xs:string" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="pixel_top_left" type="xs:string" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="pixel_top_right" type="xs:string" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- huh> -->
		<xs:attribute name="randomize_colors" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="texture_file" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation>path</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- Material Status Effect Type -->
	<xs:complexType name="MaterialStatusEffects">
		<xs:choice minOccurs="1" maxOccurs="unbounded">
			<xs:element name="Ingestion">
				<xs:complexType>
					<xs:choice>
						<xs:element name="StatusEffect" minOccurs="1" maxOccurs="unbounded">
							<xs:complexType>
								<xs:attribute name="type" type="xs:string" />
								<xs:attribute name="amount" type="xs:decimal" />
							</xs:complexType>
						</xs:element>
					</xs:choice>
				</xs:complexType>
			</xs:element>
			<xs:element name="Stains">
				<xs:complexType>
					<xs:choice>
						<xs:element name="StatusEffect" minOccurs="1" maxOccurs="unbounded">
							<xs:complexType>
								<xs:attribute name="type" type="xs:string" />
							</xs:complexType>
						</xs:element>
					</xs:choice>
				</xs:complexType>
			</xs:element>
		</xs:choice>
	</xs:complexType>
	<!-- Material Particle Effect Type -->
	<xs:complexType name="MaterialParticleEffect" mixed="true">
		<xs:attribute name="vel.y" type="xs:decimal" />
		<xs:attribute name="vel_random.min_x" type="xs:decimal" />
		<xs:attribute name="vel_random.max_x" type="xs:decimal" />
		<xs:attribute name="vel_random.min_y" type="xs:decimal" />
		<xs:attribute name="vel_random.max_y" type="xs:decimal" />
		<xs:attribute name="lifetime.min" type="xs:decimal" />
		<xs:attribute name="lifetime.max" type="xs:decimal" />
		<xs:attribute name="gravity.x" type="xs:decimal" />
		<xs:attribute name="gravity.y" type="xs:decimal" />
		<xs:attribute name="render_on_grid" type="NoitaBool" />
		<xs:attribute name="particle_single_width" type="NoitaBool" />
		<xs:attribute name="draw_as_long" type="NoitaBool" />
		<xs:attribute name="airflow_force" type="xs:decimal" />
		<xs:attribute name="airflow_scale" type="xs:decimal" />
		<xs:attribute name="friction" type="xs:decimal" />
		<xs:attribute name="probability" type="xs:decimal" />
		<xs:attribute name="count.min" type="xs:nonNegativeInteger" />
		<xs:attribute name="count.max" type="xs:nonNegativeInteger" />
		<!-- ? -->
		<xs:attribute name="m_material_id" type="xs:integer" />
	</xs:complexType>
	<!-- Material Type -->
	<xs:complexType name="Material" mixed="true">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="Graphics" type="MaterialGraphics" minOccurs="0" maxOccurs="1" />
			<xs:element name="StatusEffects" type="MaterialStatusEffects" minOccurs="0" maxOccurs="1" />
			<xs:element name="ParticleEffect" type="MaterialParticleEffect" minOccurs="0" maxOccurs="1" />
			<xs:element name="ExplosionConfig" type="ConfigExplosion" minOccurs="0" maxOccurs="1" />
		</xs:choice>
		<xs:attribute name="always_ignites_damagemodel" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="audio_is_soft" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- default unknown -->
		<xs:attribute name="supports_collapsible_structures" type="NoitaBool">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- default unknown -->
		<xs:attribute name="collapsible" type="NoitaBool">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="status_effects" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- needs enums -->
		<xs:attribute name="audio_materialaudio_type" type="xs:string" default="NONE">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- needs enums -->
		<xs:attribute name="audio_materialbreakaudio_type" type="xs:string" default="NONE">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- is it enum or string? -->
		<xs:attribute name="audio_physics_material_event" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- is it enum or string? -->
		<xs:attribute name="audio_physics_material_solid" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- is it enum or string? -->
		<xs:attribute name="audio_physics_material_wall" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="audio_size_multiplier" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="autoignition_temperature" type="xs:nonNegativeInteger" default="100">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="burnable" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="cell_holes_in_texture" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- needs enums -->
		<xs:attribute name="cell_type" type="xs:string" default="liquid">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- is it even a thing? -->
		<xs:attribute name="cold_freezes_chance_rev" type="xs:nonNegativeInteger" default="100">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="cold_freezes_to_dont_do_reverse_reaction" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="cold_freezes_to_material" type="xs:string" default="air">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="convert_to_box2d_material" type="xs:string" default="air">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="crackability" type="xs:nonNegativeInteger" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="danger_fire" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="danger_poison" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="danger_radioactive" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="danger_water" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- maybe enum? -->
		<xs:attribute name="density" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- maybe enum? -->
		<xs:attribute name="durability" type="xs:nonNegativeInteger" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="electrical_conductivity" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fire_hp" type="xs:nonNegativeInteger" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- is it even a thing? -->
		<xs:attribute name="gas_downwards_speed" type="xs:nonNegativeInteger" default="90">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- is it even a thing? -->
		<xs:attribute name="gas_horizontal_speed" type="xs:nonNegativeInteger" default="100">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- is it even a thing? -->
		<xs:attribute name="gas_speed" type="xs:nonNegativeInteger" default="50">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- is it even a thing? -->
		<xs:attribute name="gas_upwards_speed" type="xs:nonNegativeInteger" default="100">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="generates_flames" type="xs:nonNegativeInteger" default="30">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="generates_smoke" type="xs:nonNegativeInteger" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="gfx_glow" type="xs:nonNegativeInteger" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- ARGB type? -->
		<xs:attribute name="gfx_glow_color" type="xs:string" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="hp" type="xs:nonNegativeInteger" default="100">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ignore_self_reaction_warning" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="is_just_particle_fx" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lifetime" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="liquid_damping" type="xs:decimal" default="0.8">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="liquid_flow_speed" type="xs:decimal" default="0.9">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="liquid_gravity" type="xs:decimal" default="0.5">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="liquid_sand" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- default unknown -->
		<xs:attribute name="liquid_solid" type="NoitaBool">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="liquid_sand_never_box2d" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="liquid_slime" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="liquid_sprite_stain_ignited_drop_chance" type="xs:nonNegativeInteger" default="10">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="liquid_sprite_stain_shaken_drop_chance" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="liquid_sprite_stains_check_offset" type="xs:integer" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="liquid_sprite_stains_status_threshold" type="xs:decimal" default="0.01">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- wtf is this -->
		<xs:attribute name="liquid_stains" type="xs:integer" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- wang? -->
		<xs:attribute name="liquid_stains_custom_color" type="xs:string" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="liquid_stains_self" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="liquid_static" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="liquid_sticks_to_ceiling" type="xs:nonNegativeInteger" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="liquid_viscosity" type="xs:decimal" default="50">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="name" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="on_fire" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="on_fire_convert_to_material" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="on_fire_flame_material" type="xs:string" default="fire">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="on_fire_smoke_material" type="xs:string" default="smoke">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- enum? -->
		<xs:attribute name="platform_type" type="xs:integer" default="-1">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="requires_oxygen" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="show_in_creative_mode" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="slippery" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="solid_break_to_type" type="xs:string" default="air">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="solid_collide_with_self" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="solid_friction" type="xs:decimal" default="0.3">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="solid_go_through_sand" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="solid_gravity_scale" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="solid_on_break_explode" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="solid_on_collision_convert" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="solid_on_collision_explode" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="solid_on_collision_material" type="xs:string" default="air">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- ? -->
		<xs:attribute name="solid_on_collision_splash_power" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="solid_on_sleep_convert" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="solid_restitution" type="xs:decimal" default="0.2">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- enum? -->
		<xs:attribute name="solid_static_type" type="xs:integer" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="stainable" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="stickyness" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="tags" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="temperature_of_fire" type="xs:nonNegativeInteger" default="10">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ui_name" type="xs:string" default="[material name field]">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="vegetation_full_lifetime_growth" type="xs:nonNegativeInteger" default="10000">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- idk -->
		<xs:attribute name="vegetation_random_flip_x_scale" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="vegetation_sprite" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation>path</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- wang enum? -->
		<xs:attribute name="wang_color" type="xs:string" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="wang_curvature" type="xs:decimal" default="0.5">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="wang_noise_percent" type="xs:decimal" default="1">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- enum? -->
		<xs:attribute name="wang_noise_type" type="xs:integer" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="warmth_melts_chance_rev" type="xs:nonNegativeInteger" default="100">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="warmth_melts_to_material" type="xs:string" default="air">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- Material Reactions -->
	<xs:complexType name="MaterialReactions">
		<xs:choice>
			<xs:element name="ExplosionConfig" type="ConfigExplosion" minOccurs="0" />
		</xs:choice>
		<xs:attribute name="audio_fx_volume_1" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="blob_radius1" type="xs:integer" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="blob_radius2" type="xs:integer" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="blob_restrict_to_input_material1" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="blob_restrict_to_input_material2" type="NoitaBool" default="1">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- ? -->
		<xs:attribute name="convert_all" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="cosmetic_particle" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="destroy_horizontally_lonely_pixels" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- enum? -->
		<xs:attribute name="direction" type="xs:string" default="none">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="entity" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation>path</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fast_reaction" type="NoitaBool" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="input_cell1" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="input_cell2" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="input_cell3" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="output_cell1" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="output_cell2" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="output_cell3" type="xs:string" default="">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="probability" type="xs:decimal" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="req_lifetime" type="xs:integer" default="0">
			<xs:annotation>
				<xs:documentation> ""</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- Materials -->
	<xs:element name="Materials">
		<xs:complexType mixed="true">
			<xs:choice maxOccurs="unbounded" minOccurs="0">
				<xs:element name="CellData" type="Material" minOccurs="0" maxOccurs="unbounded" />
				<xs:element name="CellDataChild" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType mixed="true">
						<xs:complexContent>
							<xs:extension base="Material">
								<xs:attribute name="_parent" type="xs:string" use="required" />
								<xs:attribute name="_inherit_reactions" type="NoitaBool" />
							</xs:extension>
						</xs:complexContent>
					</xs:complexType>
				</xs:element>
				<xs:element name="Reaction" type="MaterialReactions" minOccurs="0" maxOccurs="unbounded" />
				<xs:element name="ReqReaction" type="MaterialReactions" minOccurs="0" maxOccurs="unbounded" />
			</xs:choice>
		</xs:complexType>
		<xs:unique name="UniqueMaterialName">
			<xs:selector xpath="CellData | CellDataChild" />
			<xs:field xpath="@name" />
		</xs:unique>
		<xs:unique name="UniqueMaterialWang">
			<xs:selector xpath="CellData | CellDataChild" />
			<xs:field xpath="@wang_color" />
		</xs:unique>
	</xs:element>
</xs:schema>