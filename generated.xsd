<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
	<xs:simpleType name="NoitaBool">
		<xs:restriction base="xs:string">
			<xs:enumeration value="0" />
			<xs:enumeration value="1" />
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="Transform">
		<xs:attribute name="position.x" type="xs:decimal" default="0" >
			<xs:annotation>
					<xs:documentation>`EntityLoad` doesn't respect this on entities, mostly used for relative offsets in `InheritTransformComponent`</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="position.y" type="xs:decimal" default="0" >
			<xs:annotation>
					<xs:documentation>`EntityLoad` doesn't respect this on entities, mostly used for relative offsets in `InheritTransformComponent`</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="scale.x" type="xs:decimal" default="1" >
			<xs:annotation>
					<xs:documentation>A stretching factor, most components don't work with this</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="scale.y" type="xs:decimal" default="1" >
			<xs:annotation>
					<xs:documentation>A stretching factor, most components don't work with this</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="rotation" type="xs:decimal" default="0" >
			<xs:annotation>
					<xs:documentation>Measured in degrees</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="EntityBase">
		<xs:sequence minOccurs="0">
			<xs:choice maxOccurs="unbounded" minOccurs="0">
				<xs:element ref="Entity" />
				<xs:element ref="Base" />
				<xs:element name="Transform" type="Transform" />
				<xs:element ref="AIAttackComponent" />
					<xs:element ref="AIComponent" />
					<xs:element ref="AbilityComponent" />
					<xs:element ref="AdvancedFishAIComponent" />
					<xs:element ref="AltarComponent" />
					<xs:element ref="AnimalAIComponent" />
					<xs:element ref="ArcComponent" />
					<xs:element ref="AreaDamageComponent" />
					<xs:element ref="AttachToEntityComponent" />
					<xs:element ref="AudioComponent" />
					<xs:element ref="AudioListenerComponent" />
					<xs:element ref="AudioLoopComponent" />
					<xs:element ref="BiomeTrackerComponent" />
					<xs:element ref="BlackHoleComponent" />
					<xs:element ref="BookComponent" />
					<xs:element ref="BossDragonComponent" />
					<xs:element ref="BossHealthBarComponent" />
					<xs:element ref="CameraBoundComponent" />
					<xs:element ref="CardinalMovementComponent" />
					<xs:element ref="CellEaterComponent" />
					<xs:element ref="CharacterCollisionComponent" />
					<xs:element ref="CharacterDataComponent" />
					<xs:element ref="CharacterPlatformingComponent" />
					<xs:element ref="CharacterStatsComponent" />
					<xs:element ref="CollisionTriggerComponent" />
					<xs:element ref="ConsumableTeleportComponent" />
					<xs:element ref="ControllerGoombaAIComponent" />
					<xs:element ref="ControlsComponent" />
					<xs:element ref="CrawlerAnimalComponent" />
					<xs:element ref="CutThroughWorldDoneHereComponent" />
					<xs:element ref="DamageModelComponent" />
					<xs:element ref="DamageNearbyEntitiesComponent" />
					<xs:element ref="DebugFollowMouseComponent" />
					<xs:element ref="DebugLogMessagesComponent" />
					<xs:element ref="DebugSpatialVisualizerComponent" />
					<xs:element ref="DieIfSpeedBelowComponent" />
					<xs:element ref="DroneLauncherComponent" />
					<xs:element ref="DrugEffectComponent" />
					<xs:element ref="DrugEffectModifierComponent" />
					<xs:element ref="ElectricChargeComponent" />
					<xs:element ref="ElectricityComponent" />
					<xs:element ref="ElectricityReceiverComponent" />
					<xs:element ref="ElectricitySourceComponent" />
					<xs:element ref="EndingMcGuffinComponent" />
					<xs:element ref="EnergyShieldComponent" />
					<xs:element ref="ExplodeOnDamageComponent" />
					<xs:element ref="ExplosionComponent" />
					<xs:element ref="FishAIComponent" />
					<xs:element ref="FlyingComponent" />
					<xs:element ref="FogOfWarRadiusComponent" />
					<xs:element ref="FogOfWarRemoverComponent" />
					<xs:element ref="GameAreaEffectComponent" />
					<xs:element ref="GameEffectComponent" />
					<xs:element ref="GameLogComponent" />
					<xs:element ref="GameStatsComponent" />
					<xs:element ref="GasBubbleComponent" />
					<xs:element ref="GenomeDataComponent" />
					<xs:element ref="GhostComponent" />
					<xs:element ref="GodInfoComponent" />
					<xs:element ref="GunComponent" />
					<xs:element ref="HealthBarComponent" />
					<xs:element ref="HitEffectComponent" />
					<xs:element ref="HitboxComponent" />
					<xs:element ref="HomingComponent" />
					<xs:element ref="HotspotComponent" />
					<xs:element ref="IKLimbAttackerComponent" />
					<xs:element ref="IKLimbComponent" />
					<xs:element ref="IKLimbWalkerComponent" />
					<xs:element ref="IKLimbsAnimatorComponent" />
					<xs:element ref="IngestionComponent" />
					<xs:element ref="InheritTransformComponent" />
					<xs:element ref="InteractableComponent" />
					<xs:element ref="Inventory2Component" />
					<xs:element ref="InventoryComponent" />
					<xs:element ref="InventoryGuiComponent" />
					<xs:element ref="ItemAIKnowledgeComponent" />
					<xs:element ref="ItemActionComponent" />
					<xs:element ref="ItemAlchemyComponent" />
					<xs:element ref="ItemChestComponent" />
					<xs:element ref="ItemComponent" />
					<xs:element ref="ItemCostComponent" />
					<xs:element ref="ItemPickUpperComponent" />
					<xs:element ref="ItemRechargeNearGroundComponent" />
					<xs:element ref="ItemStashComponent" />
					<xs:element ref="KickComponent" />
					<xs:element ref="LaserEmitterComponent" />
					<xs:element ref="LevitationComponent" />
					<xs:element ref="LifetimeComponent" />
					<xs:element ref="LightComponent" />
					<xs:element ref="LightningComponent" />
					<xs:element ref="LimbBossComponent" />
					<xs:element ref="LiquidDisplacerComponent" />
					<xs:element ref="LoadEntitiesComponent" />
					<xs:element ref="LocationMarkerComponent" />
					<xs:element ref="LooseGroundComponent" />
					<xs:element ref="LuaComponent" />
					<xs:element ref="MagicConvertMaterialComponent" />
					<xs:element ref="MagicXRayComponent" />
					<xs:element ref="ManaReloaderComponent" />
					<xs:element ref="MaterialAreaCheckerComponent" />
					<xs:element ref="MaterialInventoryComponent" />
					<xs:element ref="MaterialSeaSpawnerComponent" />
					<xs:element ref="MaterialSuckerComponent" />
					<xs:element ref="MoveToSurfaceOnCreateComponent" />
					<xs:element ref="MusicEnergyAffectorComponent" />
					<xs:element ref="NinjaRopeComponent" />
					<xs:element ref="NullDamageComponent" />
					<xs:element ref="OrbComponent" />
					<xs:element ref="ParticleEmitterComponent" />
					<xs:element ref="PathFindingComponent" />
					<xs:element ref="PathFindingGridMarkerComponent" />
					<xs:element ref="PhysicsAIComponent" />
					<xs:element ref="PhysicsBody2Component" />
					<xs:element ref="PhysicsBodyCollisionDamageComponent" />
					<xs:element ref="PhysicsBodyComponent" />
					<xs:element ref="PhysicsImageShapeComponent" />
					<xs:element ref="PhysicsJoint2Component" />
					<xs:element ref="PhysicsJoint2MutatorComponent" />
					<xs:element ref="PhysicsJointComponent" />
					<xs:element ref="PhysicsKeepInWorldComponent" />
					<xs:element ref="PhysicsPickUpComponent" />
					<xs:element ref="PhysicsRagdollComponent" />
					<xs:element ref="PhysicsShapeComponent" />
					<xs:element ref="PhysicsThrowableComponent" />
					<xs:element ref="PixelSceneComponent" />
					<xs:element ref="PixelSpriteComponent" />
					<xs:element ref="PlatformShooterPlayerComponent" />
					<xs:element ref="PlayerCollisionComponent" />
					<xs:element ref="PlayerStatsComponent" />
					<xs:element ref="PositionSeedComponent" />
					<xs:element ref="PotionComponent" />
					<xs:element ref="PressurePlateComponent" />
					<xs:element ref="ProjectileComponent" />
					<xs:element ref="RotateTowardsComponent" />
					<xs:element ref="SetLightAlphaFromVelocityComponent" />
					<xs:element ref="SetStartVelocityComponent" />
					<xs:element ref="ShotEffectComponent" />
					<xs:element ref="SimplePhysicsComponent" />
					<xs:element ref="SineWaveComponent" />
					<xs:element ref="SpriteAnimatorComponent" />
					<xs:element ref="SpriteComponent" />
					<xs:element ref="SpriteOffsetAnimatorComponent" />
					<xs:element ref="SpriteParticleEmitterComponent" />
					<xs:element ref="SpriteStainsComponent" />
					<xs:element ref="StatusEffectDataComponent" />
					<xs:element ref="StreamingKeepAliveComponent" />
					<xs:element ref="TelekinesisComponent" />
					<xs:element ref="TeleportComponent" />
					<xs:element ref="TeleportProjectileComponent" />
					<xs:element ref="TextLogComponent" />
					<xs:element ref="TorchComponent" />
					<xs:element ref="UIIconComponent" />
					<xs:element ref="UIInfoComponent" />
					<xs:element ref="VariableStorageComponent" />
					<xs:element ref="VelocityComponent" />
					<xs:element ref="VerletPhysicsComponent" />
					<xs:element ref="VerletWeaponComponent" />
					<xs:element ref="VerletWorldJointComponent" />
					<xs:element ref="WalletComponent" />
					<xs:element ref="WalletValuableComponent" />
					<xs:element ref="WorldStateComponent" />
					<xs:element ref="WormAIComponent" />
					<xs:element ref="WormAttractorComponent" />
					<xs:element ref="WormComponent" />
					<xs:element ref="WormPlayerComponent" />
			</xs:choice>
		</xs:sequence>
		<xs:attribute name="name" type="xs:string"></xs:attribute>
		<xs:attribute name="tags" type="xs:string"></xs:attribute>
	</xs:complexType>
	<xs:element name="Entity" type="EntityBase">
		<xs:annotation>
			<xs:documentation>Represents an entity that can be loaded into the world</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="Base">
		<xs:annotation>
			<xs:documentation>Base file</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="EntityBase">
					<xs:attribute name="file" type="xs:string" />
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="AIAttackComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class AIAttackComponent {<br>&emsp;&emsp;&emsp;&emsp;int use_probability = 100; // [0, 100] The probability for using this attack if it's otherwise possible<br>&emsp;&emsp;&emsp;&emsp;float min_distance = 10; // [0, 10000] The minimum distance from enemy at which we can perform this attack.<br>&emsp;&emsp;&emsp;&emsp;float max_distance = 160; // [0, 10000] The maximum distance from enemy at which we can perform this attack.<br>&emsp;&emsp;&emsp;&emsp;float angular_range_deg = 90; // [0, 90] When looking for threats/prey this is our field of view around the X axis. 90 means we scan the whole 180 degrees around the X axis, to the left and right.<br>&emsp;&emsp;&emsp;&emsp;int state_duration_frames = 45; // [0, 1000] How long do we stay in the attack state, before other states are allowed?<br>&emsp;&emsp;&emsp;&emsp;int frames_between = 180; // [0, 1000] The minimum number of frames we wait between these attacks<br>&emsp;&emsp;&emsp;&emsp;int frames_between_global = 30; // [0, 1000] The minimum number of frames we wait after this attack before doing any other ranged attack<br>&emsp;&emsp;&emsp;&emsp;std::string animation_name = "attack_ranged"; // [0, 1] The animation to play when performing this attack<br>&emsp;&emsp;&emsp;&emsp;bool attack_landing_ranged_enabled = 0; // [0, 1] If 1, we try to land before doing the attack, if there's ground near nearby under us<br>&emsp;&emsp;&emsp;&emsp;int attack_ranged_action_frame = 2; // [0, 1000] The frame of the 'attack_ranged' animation during which the ranged attack actually occurs<br>&emsp;&emsp;&emsp;&emsp;float attack_ranged_offset_x = 0; // [-1000, 1000] 'attack_ranged_entity_file' is created here when performing a ranged attack<br>&emsp;&emsp;&emsp;&emsp;float attack_ranged_offset_y = 0; // [-1000, 1000] 'attack_ranged_entity_file' is created here when performing a ranged attack<br>&emsp;&emsp;&emsp;&emsp;float attack_ranged_root_offset_x = 0; // [-1000, 1000] <br>&emsp;&emsp;&emsp;&emsp;float attack_ranged_root_offset_y = 0; // [-1000, 1000] <br>&emsp;&emsp;&emsp;&emsp;bool attack_ranged_use_message = 0; // [0, 1] If 1, we do ranged attacks by sending a Message_UseItem<br>&emsp;&emsp;&emsp;&emsp;bool attack_ranged_predict = 0; // [0, 1] If 1, we attempt to predict target movement and shoot accordingly<br>&emsp;&emsp;&emsp;&emsp;std::string attack_ranged_entity_file = "data/entities/projectiles/spear.xml"; // [0, 1] File to projectile entity that is created when performing a ranged attack<br>&emsp;&emsp;&emsp;&emsp;int attack_ranged_entity_count_min = 1; // [0, 1000] Minimum number of projectiles shot when performing a ranged attack<br>&emsp;&emsp;&emsp;&emsp;int attack_ranged_entity_count_max = 1; // [0, 1000] Maximum number of projectiles shot when performing a ranged attack<br>&emsp;&emsp;&emsp;&emsp;bool attack_ranged_use_laser_sight = 0; // [0, 1] If 1, we draw a laser sight to our target. Requires entity to have a sprite with tag 'laser_sight'<br>&emsp;&emsp;&emsp;&emsp;bool attack_ranged_aim_rotation_enabled = 0; // [0, 1] If 1, we use a laser sight<br>&emsp;&emsp;&emsp;&emsp;float attack_ranged_aim_rotation_speed = 3; // [0, 1] How fast can we rotate our aim to track targets<br>&emsp;&emsp;&emsp;&emsp;float attack_ranged_aim_rotation_shooting_ok_angle_deg = 10; // [0, 1] If our aim is closer than this to the target we shoot<br>&emsp;&emsp;&emsp;&emsp;float mRangedAttackCurrentAimAngle = 0; // [0, 1] which direction does our gun currently point at, physically saying?<br>&emsp;&emsp;&emsp;&emsp;int mNextFrameUsable = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="use_probability" type="xs:int" default="100">
				<xs:annotation>
					<xs:documentation>`100` - `[0, 100]`</xs:documentation>
					<xs:documentation>The probability for using this attack if it's otherwise possible</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="min_distance" type="xs:decimal" default="10">
				<xs:annotation>
					<xs:documentation>`10` - `[0, 10000]`</xs:documentation>
					<xs:documentation>The minimum distance from enemy at which we can perform this attack.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="max_distance" type="xs:decimal" default="160">
				<xs:annotation>
					<xs:documentation>`160` - `[0, 10000]`</xs:documentation>
					<xs:documentation>The maximum distance from enemy at which we can perform this attack.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="angular_range_deg" type="xs:decimal" default="90">
				<xs:annotation>
					<xs:documentation>`90` - `[0, 90]`</xs:documentation>
					<xs:documentation>When looking for threats/prey this is our field of view around the X axis. 90 means we scan the whole 180 degrees around the X axis, to the left and right.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="state_duration_frames" type="xs:int" default="45">
				<xs:annotation>
					<xs:documentation>`45` - `[0, 1000]`</xs:documentation>
					<xs:documentation>How long do we stay in the attack state, before other states are allowed?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="frames_between" type="xs:int" default="180">
				<xs:annotation>
					<xs:documentation>`180` - `[0, 1000]`</xs:documentation>
					<xs:documentation>The minimum number of frames we wait between these attacks</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="frames_between_global" type="xs:int" default="30">
				<xs:annotation>
					<xs:documentation>`30` - `[0, 1000]`</xs:documentation>
					<xs:documentation>The minimum number of frames we wait after this attack before doing any other ranged attack</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="animation_name" type="xs:string" default="attack_ranged">
				<xs:annotation>
					<xs:documentation>`attack_ranged` - `[0, 1]`</xs:documentation>
					<xs:documentation>The animation to play when performing this attack</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_landing_ranged_enabled" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>If 1, we try to land before doing the attack, if there's ground near nearby under us</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_ranged_action_frame" type="xs:int" default="2">
				<xs:annotation>
					<xs:documentation>`2` - `[0, 1000]`</xs:documentation>
					<xs:documentation>The frame of the 'attack_ranged' animation during which the ranged attack actually occurs</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_ranged_offset_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-1000, 1000]`</xs:documentation>
					<xs:documentation>'attack_ranged_entity_file' is created here when performing a ranged attack</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_ranged_offset_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-1000, 1000]`</xs:documentation>
					<xs:documentation>'attack_ranged_entity_file' is created here when performing a ranged attack</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_ranged_root_offset_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-1000, 1000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_ranged_root_offset_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-1000, 1000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_ranged_use_message" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>If 1, we do ranged attacks by sending a Message_UseItem</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_ranged_predict" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>If 1, we attempt to predict target movement and shoot accordingly</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_ranged_entity_file" type="xs:string" default="data/entities/projectiles/spear.xml">
				<xs:annotation>
					<xs:documentation>`data/entities/projectiles/spear.xml` - `[0, 1]`</xs:documentation>
					<xs:documentation>File to projectile entity that is created when performing a ranged attack</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_ranged_entity_count_min" type="xs:int" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1000]`</xs:documentation>
					<xs:documentation>Minimum number of projectiles shot when performing a ranged attack</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_ranged_entity_count_max" type="xs:int" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1000]`</xs:documentation>
					<xs:documentation>Maximum number of projectiles shot when performing a ranged attack</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_ranged_use_laser_sight" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>If 1, we draw a laser sight to our target. Requires entity to have a sprite with tag 'laser_sight'</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_ranged_aim_rotation_enabled" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>If 1, we use a laser sight</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_ranged_aim_rotation_speed" type="xs:decimal" default="3">
				<xs:annotation>
					<xs:documentation>`3` - `[0, 1]`</xs:documentation>
					<xs:documentation>How fast can we rotate our aim to track targets</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_ranged_aim_rotation_shooting_ok_angle_deg" type="xs:decimal" default="10">
				<xs:annotation>
					<xs:documentation>`10` - `[0, 1]`</xs:documentation>
					<xs:documentation>If our aim is closer than this to the target we shoot</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mRangedAttackCurrentAimAngle" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>which direction does our gun currently point at, physically saying?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mNextFrameUsable" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="AIComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class AIComponent {<br>&emsp;&emsp;&emsp;&emsp;float TEMP_TEMP_TEMP = 0; // [0, 3.5] <br>&emsp;&emsp;&emsp;&emsp;AIData* data;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="TEMP_TEMP_TEMP" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 3.5]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: AIData* for data -->
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="AbilityComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class AbilityComponent {<br>&emsp;&emsp;&emsp;&emsp;int cooldown_frames = 0; // [0, 60000] <br>&emsp;&emsp;&emsp;&emsp;std::string entity_file; //  the projectile entity file<br>&emsp;&emsp;&emsp;&emsp;std::string sprite_file;<br>&emsp;&emsp;&emsp;&emsp;int entity_count = 1; // [0, 60000] <br>&emsp;&emsp;&emsp;&emsp;bool never_reload = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int reload_time_frames = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float mana = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float mana_max = 100; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float mana_charge_speed = 10; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool rotate_in_hand = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float rotate_in_hand_amount = 1; // [0, 1] [0-1], how much does the item rotate related to the actual aiming angle<br>&emsp;&emsp;&emsp;&emsp;float rotate_hand_amount = 0.7; // [0, 1] [0-1], how much does hand sprite rotate related to the actual aiming angle<br>&emsp;&emsp;&emsp;&emsp;bool fast_projectile = 0; // [0, 1] if 1, then the velocity of the bullet is increased quite a bit. Lightning requires this<br>&emsp;&emsp;&emsp;&emsp;float swim_propel_amount = 0; // [-1000, 1000] <br>&emsp;&emsp;&emsp;&emsp;int max_charged_actions = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int charge_wait_frames = 10; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float item_recoil_recovery_speed = 15; // [0, 1] How quickly does the item return to resting state after getting recoil<br>&emsp;&emsp;&emsp;&emsp;float item_recoil_max = 1; // [0, 1] Maximum distance moved by recoil<br>&emsp;&emsp;&emsp;&emsp;float item_recoil_offset_coeff = 1; // [0, 1] Item distance moved by recoil = mItemRecoil * item_recoil_offset_coeff<br>&emsp;&emsp;&emsp;&emsp;float item_recoil_rotation_coeff = 5; // [0, 1] Item rotation by recoil = mItemRecoil * item_recoil_rotation_coeff<br>&emsp;&emsp;&emsp;&emsp;std::string base_item_file = "data/entities/base_item.xml"; // [0, 1] when dropping / throwing the item, this is the base_item that we add the ability component to<br>&emsp;&emsp;&emsp;&emsp;bool use_entity_file_as_projectile_info_proxy = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool click_to_use = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int stat_times_player_has_shot = 0; // [0, 1] used to track how many times player has shot this 'ability'<br>&emsp;&emsp;&emsp;&emsp;int stat_times_player_has_edited = 0; // [0, 1] used to track how many times this has been edited<br>&emsp;&emsp;&emsp;&emsp;bool shooting_reduces_amount_in_inventory = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool throw_as_item = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool simulate_throw_as_item = 0; // [0, 1] If 1, the item will be work as normal ability, but throwing animation is played by the user<br>&emsp;&emsp;&emsp;&emsp;int max_amount_in_inventory = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int amount_in_inventory = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool drop_as_item_on_death = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;std::string ui_name = "[NOT_SET]"; // [0, 1] way to name the weapons<br>&emsp;&emsp;&emsp;&emsp;bool use_gun_script = 0; // [0, 1] If 1, the default ability behaviour is replaced with one that uses the lua gun system.<br>&emsp;&emsp;&emsp;&emsp;bool is_petris_gun = 0; // [0, 1] if 1, TODO( PETRI)<br>&emsp;&emsp;&emsp;&emsp;int gun_level = 1; // [1, 10] the level of the wand, set in gun_procedural.lua<br>&emsp;&emsp;&emsp;&emsp;std::string add_these_child_actions; //  e.g. 'bullet,bullet,damage' ... actions are parsed into a string. These are added as actual entities when the item is initialized<br>&emsp;&emsp;&emsp;&emsp;int current_slot_durability = -1; // [0, 1] After this many slots the last slot of the gun is removed. -1 means not initialized/infinite.<br>&emsp;&emsp;&emsp;&emsp;std_string slot_consumption_function = _get_gun_slot_durability_default; // [0, 1] Name of the lua function in 'gun.lua' that is called to calculate durability of the last slot in the gun<br>&emsp;&emsp;&emsp;&emsp;int mNextFrameUsable = 0; // [0, 1] hax, don't touch!<br>&emsp;&emsp;&emsp;&emsp;int mCastDelayStartFrame = 0; // [0, 1] hax, don't touch!<br>&emsp;&emsp;&emsp;&emsp;int mReloadFramesLeft = 0; // [0, 1] hax, don't touch!<br>&emsp;&emsp;&emsp;&emsp;int mReloadNextFrameUsable = 0; // [0, 1] hax, don't touch!<br>&emsp;&emsp;&emsp;&emsp;int mChargeCount = 0; // [0, 1] hax, don't touch!<br>&emsp;&emsp;&emsp;&emsp;bool mIsInitialized = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;ConfigGun gun_config; //  Constants for gun script<br>&emsp;&emsp;&emsp;&emsp;ConfigGunActionInfo gunaction_config; //  Constants for gun script<br>&emsp;&emsp;&emsp;&emsp;int mAmmoLeft = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mNextChargeFrame = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float mItemRecoil = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="cooldown_frames" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 60000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="entity_file" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>the projectile entity file</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="sprite_file" type="xs:string" default="" />
			<xs:attribute name="entity_count" type="xs:int" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 60000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="never_reload" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="reload_time_frames" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mana" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mana_max" type="xs:decimal" default="100">
				<xs:annotation>
					<xs:documentation>`100` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mana_charge_speed" type="xs:decimal" default="10">
				<xs:annotation>
					<xs:documentation>`10` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="rotate_in_hand" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="rotate_in_hand_amount" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>[0-1], how much does the item rotate related to the actual aiming angle</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="rotate_hand_amount" type="xs:decimal" default="0.7">
				<xs:annotation>
					<xs:documentation>`0.7` - `[0, 1]`</xs:documentation>
					<xs:documentation>[0-1], how much does hand sprite rotate related to the actual aiming angle</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="fast_projectile" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, then the velocity of the bullet is increased quite a bit. Lightning requires this</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="swim_propel_amount" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-1000, 1000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="max_charged_actions" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="charge_wait_frames" type="xs:int" default="10">
				<xs:annotation>
					<xs:documentation>`10` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="item_recoil_recovery_speed" type="xs:decimal" default="15">
				<xs:annotation>
					<xs:documentation>`15` - `[0, 1]`</xs:documentation>
					<xs:documentation>How quickly does the item return to resting state after getting recoil</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="item_recoil_max" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>Maximum distance moved by recoil</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="item_recoil_offset_coeff" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>Item distance moved by recoil = mItemRecoil * item_recoil_offset_coeff</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="item_recoil_rotation_coeff" type="xs:decimal" default="5">
				<xs:annotation>
					<xs:documentation>`5` - `[0, 1]`</xs:documentation>
					<xs:documentation>Item rotation by recoil = mItemRecoil * item_recoil_rotation_coeff</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="base_item_file" type="xs:string" default="data/entities/base_item.xml">
				<xs:annotation>
					<xs:documentation>`data/entities/base_item.xml` - `[0, 1]`</xs:documentation>
					<xs:documentation>when dropping / throwing the item, this is the base_item that we add the ability component to</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="use_entity_file_as_projectile_info_proxy" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="click_to_use" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="stat_times_player_has_shot" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>used to track how many times player has shot this 'ability'</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="stat_times_player_has_edited" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>used to track how many times this has been edited</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="shooting_reduces_amount_in_inventory" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="throw_as_item" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="simulate_throw_as_item" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>If 1, the item will be work as normal ability, but throwing animation is played by the user</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="max_amount_in_inventory" type="xs:int" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="amount_in_inventory" type="xs:int" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="drop_as_item_on_death" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ui_name" type="xs:string" default="[NOT_SET]">
				<xs:annotation>
					<xs:documentation>`[NOT_SET]` - `[0, 1]`</xs:documentation>
					<xs:documentation>way to name the weapons</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="use_gun_script" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>If 1, the default ability behaviour is replaced with one that uses the lua gun system.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_petris_gun" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, TODO( PETRI)</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="gun_level" type="xs:int" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[1, 10]`</xs:documentation>
					<xs:documentation>the level of the wand, set in gun_procedural.lua</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="add_these_child_actions" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>e.g. 'bullet,bullet,damage' ... actions are parsed into a string. These are added as actual entities when the item is initialized</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="current_slot_durability" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
					<xs:documentation>After this many slots the last slot of the gun is removed. -1 means not initialized/infinite.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: std_string for slot_consumption_function -->
			<xs:attribute name="mNextFrameUsable" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>hax, don't touch!</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mCastDelayStartFrame" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>hax, don't touch!</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mReloadFramesLeft" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>hax, don't touch!</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mReloadNextFrameUsable" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>hax, don't touch!</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mChargeCount" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>hax, don't touch!</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mIsInitialized" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: ConfigGun for gun_config -->
				<!-- Some Unknown Type: ConfigGunActionInfo for gunaction_config -->
			<xs:attribute name="mAmmoLeft" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mNextChargeFrame" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mItemRecoil" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="AdvancedFishAIComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class AdvancedFishAIComponent {<br>&emsp;&emsp;&emsp;&emsp;float move_check_range_min = 16; // [0, 2] <br>&emsp;&emsp;&emsp;&emsp;float move_check_range_max = 64; // [0, 2] <br>&emsp;&emsp;&emsp;&emsp;bool flock = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool avoid_predators = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mHasTargetDirection = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;vec2 mTargetPos;<br>&emsp;&emsp;&emsp;&emsp;vec2 mTargetVec;<br>&emsp;&emsp;&emsp;&emsp;vec2 mLastFramesMovementAreaMin;<br>&emsp;&emsp;&emsp;&emsp;vec2 mLastFramesMovementAreaMax;<br>&emsp;&emsp;&emsp;&emsp;uint32 mNumFailedTargetSearches = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mNextFrameCheckAreWeStuck = -1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mNextFrameCheckFlockWants = -1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mNextFramePredatorAvoidance = -1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float mScared = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mWantsToBeInFlock = 1; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="move_check_range_min" type="xs:decimal" default="16">
				<xs:annotation>
					<xs:documentation>`16` - `[0, 2]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="move_check_range_max" type="xs:decimal" default="64">
				<xs:annotation>
					<xs:documentation>`64` - `[0, 2]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="flock" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="avoid_predators" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mHasTargetDirection" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mTargetPos.x" type="xs:decimal" default="0" />
			<xs:attribute name="mTargetPos.y" type="xs:decimal" default="0" />
			<xs:attribute name="mTargetVec.x" type="xs:decimal" default="0" />
			<xs:attribute name="mTargetVec.y" type="xs:decimal" default="0" />
			<xs:attribute name="mLastFramesMovementAreaMin.x" type="xs:decimal" default="0" />
			<xs:attribute name="mLastFramesMovementAreaMin.y" type="xs:decimal" default="0" />
			<xs:attribute name="mLastFramesMovementAreaMax.x" type="xs:decimal" default="0" />
			<xs:attribute name="mLastFramesMovementAreaMax.y" type="xs:decimal" default="0" />
			<xs:attribute name="mNumFailedTargetSearches" type="xs:unsignedInt" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mNextFrameCheckAreWeStuck" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mNextFrameCheckFlockWants" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mNextFramePredatorAvoidance" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mScared" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mWantsToBeInFlock" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="AltarComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class AltarComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string recognized_entity_tags;<br>&emsp;&emsp;&emsp;&emsp;int uses_remaining = 3; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int good_fx_material = 0; // [0, 1] String name of material for particles emitted on successful sacrifice<br>&emsp;&emsp;&emsp;&emsp;int neutral_fx_material = 0; // [0, 1] String name of material for particles emitted on successful sacrifice<br>&emsp;&emsp;&emsp;&emsp;int evil_fx_material = 0; // [0, 1] String name of material for particles emitted on successful sacrifice<br>&emsp;&emsp;&emsp;&emsp;EntityTags m_recognized_entity_tags;<br>&emsp;&emsp;&emsp;&emsp;uint32 m_recognized_entity_tags_count = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;EntityTags m_current_entity_tags;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="recognized_entity_tags" type="xs:string" default="" />
			<xs:attribute name="uses_remaining" type="xs:int" default="3">
				<xs:annotation>
					<xs:documentation>`3` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="good_fx_material" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>String name of material for particles emitted on successful sacrifice</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="neutral_fx_material" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>String name of material for particles emitted on successful sacrifice</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="evil_fx_material" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>String name of material for particles emitted on successful sacrifice</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: EntityTags for m_recognized_entity_tags -->
			<xs:attribute name="m_recognized_entity_tags_count" type="xs:unsignedInt" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: EntityTags for m_current_entity_tags -->
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="AnimalAIComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class AnimalAIComponent {<br>&emsp;&emsp;&emsp;&emsp;int ai_state = 0; // [0, 20] Current state of ai, defines what the animal is doing<br>&emsp;&emsp;&emsp;&emsp;int ai_state_timer = 0; // [0, 1000] If not 0, then we wait till this frame to pop current state from our state stack<br>&emsp;&emsp;&emsp;&emsp;bool keep_state_alive_when_enabled = 0; // [0, 1] if 1, will ensure state timer keeps current state alive for a while when Component is Enabled<br>&emsp;&emsp;&emsp;&emsp;std::string preferred_job; //  We always do this job, unless interrupted (i.e. by taking fire damage)<br>&emsp;&emsp;&emsp;&emsp;int escape_if_damaged_probability = 30; // [0, 1] the chance of escaping if someone damages us. only works if 'can_fly = 0 '<br>&emsp;&emsp;&emsp;&emsp;int attack_if_damaged_probability = 100; // [0, 1] the chance of counter-attacking if someone damages us, and we didn't escape<br>&emsp;&emsp;&emsp;&emsp;int eye_offset_x = 0; // [-100, 100] We cast rays from our position + eye_offset to check if we can see something<br>&emsp;&emsp;&emsp;&emsp;int eye_offset_y = 0; // [-100, 100] We cast rays from our position + eye_offset to check if we can see something<br>&emsp;&emsp;&emsp;&emsp;bool attack_only_if_attacked = 0; // [0, 1] If 1, we never attack anyone unless attacked before by someone<br>&emsp;&emsp;&emsp;&emsp;bool dont_counter_attack_own_herd = 0; // [0, 1] If 1, we don't attack members of our herd even if they accidentally attack us<br>&emsp;&emsp;&emsp;&emsp;float creature_detection_range_x = 50; // [0, 2000] When looking for threats/prey this is the max distance from us on the X axis we scan<br>&emsp;&emsp;&emsp;&emsp;float creature_detection_range_y = 20; // [0, 2000] When looking for threats/prey this is the max distance from us on the Y axis we scan<br>&emsp;&emsp;&emsp;&emsp;float creature_detection_angular_range_deg = 90; // [0, 90] When looking for threats/prey this is our field of view around the X axis. 90 means we scan the whole 180 degrees around the X axis, to the left and right<br>&emsp;&emsp;&emsp;&emsp;int creature_detection_check_every_x_frames = 120; // [0, 5000] Checks for threats/prey take place at least this many frames apart from each other<br>&emsp;&emsp;&emsp;&emsp;float max_distance_to_cam_to_start_hunting = 300; // [0, 2000] JobDefault idles before we've been once at least this close to the camera<br>&emsp;&emsp;&emsp;&emsp;int pathfinding_max_depth_no_target = 50; // [0, 5000] The maximum depth (in nodes) path search use when we have not found prey yet<br>&emsp;&emsp;&emsp;&emsp;int pathfinding_max_depth_has_target = 120; // [0, 5000] The maximum depth (in nodes) path search use when we have found prey<br>&emsp;&emsp;&emsp;&emsp;float aggressiveness_min = 80; // [0, 100] what's the initial random aggressiveness of this creature<br>&emsp;&emsp;&emsp;&emsp;float aggressiveness_max = 100; // [0, 100] what's the initial random aggressiveness of this creature<br>&emsp;&emsp;&emsp;&emsp;bool tries_to_ranged_attack_friends = 0; // [0, 1] if 1, the AI tries to attack whoever it considers a friend based on herd_ids, CHARMED and BERSERK status etc. useful e.g. for healers.<br>&emsp;&emsp;&emsp;&emsp;bool attack_melee_enabled = 1; // [0, 1] If 1, and melee attack has been configured, we can perform melee attacks<br>&emsp;&emsp;&emsp;&emsp;bool attack_dash_enabled = 0; // [0, 1] If 1, and dash attack has been configured, we can perform dash attacks (a long-distance melee attack where we dash towards the enemy)<br>&emsp;&emsp;&emsp;&emsp;bool attack_landing_ranged_enabled = 0; // [0, 1] If 1, and ranged attack has been configured, we can perform ranged attacks<br>&emsp;&emsp;&emsp;&emsp;bool attack_ranged_enabled = 0; // [0, 1] If 1, and ranged attack has been configured, we can perform ranged attacks<br>&emsp;&emsp;&emsp;&emsp;float attack_knockback_multiplier = 100; // [-100, 100] If not 0, melee and dash attacks cause knockback to target<br>&emsp;&emsp;&emsp;&emsp;bool is_static_turret = 0; // [0, 1] If 1, we can only attack in one fixed direction<br>&emsp;&emsp;&emsp;&emsp;int attack_melee_max_distance = 20; // [0, 400] Maximum distance at which we can perform a melee attack<br>&emsp;&emsp;&emsp;&emsp;int attack_melee_action_frame = 2; // [0, 1000] The animation frame during which the melee attack damage is inflicted and visual effects are created<br>&emsp;&emsp;&emsp;&emsp;int attack_melee_frames_between = 10; // [0, 1000] The minimum number of frames we wait between melee attacks<br>&emsp;&emsp;&emsp;&emsp;float attack_melee_damage_min = 0.4; // [0, 100] Melee attack damage inclusive minimum amount. The damage is randomized between melee attack_damage_min and attack_melee_damage_max<br>&emsp;&emsp;&emsp;&emsp;float attack_melee_damage_max = 0.6; // [0, 100] Melee attack damage inclusive maximum amount. The damage is randomized between melee attack_damage_min and attack_melee_damage_max<br>&emsp;&emsp;&emsp;&emsp;float attack_melee_impulse_vector_x = 0; // [-100, 100] The x component of the impulse that is applied to damaged entities<br>&emsp;&emsp;&emsp;&emsp;float attack_melee_impulse_vector_y = 0; // [-100, 100] The y component of the impulse that is applied to damaged entities<br>&emsp;&emsp;&emsp;&emsp;float attack_melee_impulse_multiplier = 0; // [-100, 100] A multiplier applied to attack_melee_impulse<br>&emsp;&emsp;&emsp;&emsp;float attack_melee_offset_x = 0; // [-1000, 1000] Melee attack particle effects are created here<br>&emsp;&emsp;&emsp;&emsp;float attack_melee_offset_y = 0; // [-1000, 1000] Melee attack particle effects are created here<br>&emsp;&emsp;&emsp;&emsp;bool attack_melee_finish_enabled = 0; // [0, 1] If 1, we perform a finishing move when our attack would kill the target using the 'attack_finish' animation<br>&emsp;&emsp;&emsp;&emsp;int attack_melee_finish_action_frame = 2; // [0, 1000] The animation frame during which the melee attack finishing move damage is inflicted and visual effects are created<br>&emsp;&emsp;&emsp;&emsp;float attack_dash_distance = 50; // [0, 10000] The maximum distance from enemy at which we can perform a dash attack. If a normal melee attack is possible we always do that instead<br>&emsp;&emsp;&emsp;&emsp;int attack_dash_frames_between = 120; // [0, 1200] The minimum number of frames we wait between dash attacks<br>&emsp;&emsp;&emsp;&emsp;float attack_dash_damage = 0.25; // [0, 20] The amount of damage inflicted by the dash attack<br>&emsp;&emsp;&emsp;&emsp;float attack_dash_speed = 200; // [0, 5000] The speed at which we dash<br>&emsp;&emsp;&emsp;&emsp;float attack_dash_lob = 0.9; // [0, 6] The smaller this value is the more curved our dash attack trajectory is<br>&emsp;&emsp;&emsp;&emsp;float attack_ranged_min_distance = 10; // [0, 10000] The minimum distance from enemy at which we can perform a ranged attack.<br>&emsp;&emsp;&emsp;&emsp;float attack_ranged_max_distance = 160; // [0, 10000] The maximum distance from enemy at which we can perform a ranged attack.<br>&emsp;&emsp;&emsp;&emsp;int attack_ranged_action_frame = 2; // [0, 1000] The frame of the 'attack_ranged' animation during which the ranged attack actually occurs<br>&emsp;&emsp;&emsp;&emsp;float attack_ranged_offset_x = 0; // [-1000, 1000] 'attack_ranged_entity_file' is created here when performing a ranged attack<br>&emsp;&emsp;&emsp;&emsp;float attack_ranged_offset_y = 0; // [-1000, 1000] 'attack_ranged_entity_file' is created here when performing a ranged attack<br>&emsp;&emsp;&emsp;&emsp;bool attack_ranged_use_message = 0; // [0, 1] If 1, we do ranged attacks by sending a Message_UseItem<br>&emsp;&emsp;&emsp;&emsp;bool attack_ranged_predict = 0; // [0, 1] If 1, we attempt to predict target movement and shoot accordingly<br>&emsp;&emsp;&emsp;&emsp;std::string attack_ranged_entity_file = "data/entities/projectiles/spear.xml"; // [0, 1] File to projectile entity that is created when performing a ranged attack<br>&emsp;&emsp;&emsp;&emsp;int attack_ranged_entity_count_min = 1; // [0, 1000] Minimum number of projectiles shot when performing a ranged attack<br>&emsp;&emsp;&emsp;&emsp;int attack_ranged_entity_count_max = 1; // [0, 1000] Maximum number of projectiles shot when performing a ranged attack<br>&emsp;&emsp;&emsp;&emsp;bool attack_ranged_use_laser_sight = 0; // [0, 1] If 1, we draw a laser sight to our target. Requires entity to have a sprite with tag 'laser_sight'<br>&emsp;&emsp;&emsp;&emsp;bool attack_ranged_laser_sight_beam_kind = 0; // [0, 1] 0 = red, 1 = blue <br>&emsp;&emsp;&emsp;&emsp;bool attack_ranged_aim_rotation_enabled = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float attack_ranged_aim_rotation_speed = 3; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float attack_ranged_aim_rotation_shooting_ok_angle_deg = 10; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int attack_ranged_state_duration_frames = 45; // [0, 1000] How long do we stay in the attack state, before other states are allowed?<br>&emsp;&emsp;&emsp;&emsp;bool hide_from_prey = 0; // [0, 1] If 1, we attempt to hide from our target after a succesful attack<br>&emsp;&emsp;&emsp;&emsp;float hide_from_prey_target_distance = 200; // [0, 10000] The minimum distance from our target where we should move when hiding<br>&emsp;&emsp;&emsp;&emsp;int hide_from_prey_time = 300; // [0, 1] The number of frames we spend hiding and staying hiding<br>&emsp;&emsp;&emsp;&emsp;bool food_eating_create_particles = 1; // [0, 1] If 1, we replace eaten cells with particles made of this material<br>&emsp;&emsp;&emsp;&emsp;int eating_area_radius_x = 3; // [-100, 100] 1/2 width of the area from which we eat food<br>&emsp;&emsp;&emsp;&emsp;int eating_area_radius_y = 8; // [-100, 100] 1/2 height of the area from which we eat food<br>&emsp;&emsp;&emsp;&emsp;int mouth_offset_x = 0; // [-100, 100] The center of the area from which we eat food<br>&emsp;&emsp;&emsp;&emsp;int mouth_offset_y = 0; // [-100, 100] The center of the area from which we eat food<br>&emsp;&emsp;&emsp;&emsp;bool defecates_and_pees = 0; // [0, 1] If 1, we occasionally take a leak or a dump<br>&emsp;&emsp;&emsp;&emsp;int butt_offset_x = 0; // [-100, 100] Bodily wastes are created here<br>&emsp;&emsp;&emsp;&emsp;int butt_offset_y = 0; // [-100, 100] Bodily wastes are created here<br>&emsp;&emsp;&emsp;&emsp;float pee_velocity_x = 0; // [-1000, 1000] The velocity at which our piss gets shot<br>&emsp;&emsp;&emsp;&emsp;float pee_velocity_y = 0; // [-1000, 1000] The velocity at which our piss gets shot<br>&emsp;&emsp;&emsp;&emsp;bool needs_food = 1; // [0, 1] If 1, we stop to eat if we encounter 'food_material' cells<br>&emsp;&emsp;&emsp;&emsp;bool sense_creatures = 1; // [0, 1] If 1, we occasionally search our surroundings for prey and threats<br>&emsp;&emsp;&emsp;&emsp;bool sense_creatures_through_walls = 0; // [0, 1] If 1, will see creatures even if the wall raycast fails<br>&emsp;&emsp;&emsp;&emsp;bool can_fly = 1; // [0, 1] If 1, we can fly. Please set 'PathFindingComponent.can_fly' to 1 as well if this is 1<br>&emsp;&emsp;&emsp;&emsp;bool can_walk = 1; // [0, 1] If 1, we can walk. Please set 'PathFindingComponent.can_walk' to 1 as well if this is 1<br>&emsp;&emsp;&emsp;&emsp;int path_distance_to_target_node_to_turn_around = 0; // [0, 1000] If we're further than this from target path finding node on the X-axis we turn to face it<br>&emsp;&emsp;&emsp;&emsp;float path_cleanup_explosion_radius = 6; // [0, 1000] If we get stuck on ground we create an explosion this big to clear our surroundings a bit<br>&emsp;&emsp;&emsp;&emsp;float max_distance_to_move_from_home = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;ConfigExplosion attack_melee_finish_config_explosion; //  If we have explosion, it's the setup for it<br>&emsp;&emsp;&emsp;&emsp;LensValue<int> attack_ranged_frames_between; //  The minimum number of frames we wait between ranged attacks<br>&emsp;&emsp;&emsp;&emsp;int food_material = 0; // [0, 1] The cell material we eat if encountering said material and 'needs_food' is 1<br>&emsp;&emsp;&emsp;&emsp;int food_particle_effect_material = 0; // [0, 1] We create particles made of this material when eating if 'food_eating_create_particles' is 1<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> mAggression; //  the greater this value the more likely we're to attack creatures from other herds<br>&emsp;&emsp;&emsp;&emsp;AI_STATE_STACK mAiStateStack; //  a stack of actions and times they take, we can push new actions to the front and pop them from there<br>&emsp;&emsp;&emsp;&emsp;int mAiStateLastSwitchFrame = 0; // [0, 1] when was the last time we switched a state<br>&emsp;&emsp;&emsp;&emsp;int mAiStatePrev = 0; // [0, 1] previous AI state<br>&emsp;&emsp;&emsp;&emsp;int mCreatureDetectionNextCheck = 0; // [0, 1] threat/prey check, next time we check for threat/prey<br>&emsp;&emsp;&emsp;&emsp;EntityID mGreatestThreat = 0; // [0, 1] the entity we consider to be our greatest threat<br>&emsp;&emsp;&emsp;&emsp;EntityID mGreatestPrey = 0; // [0, 1] the entity we consider to be our most important prey<br>&emsp;&emsp;&emsp;&emsp;int mSelectedMultiAttack = -1; // [0, 1] which AIAttackComponent attack are we using?<br>&emsp;&emsp;&emsp;&emsp;bool mHasFoundPrey = 0; // [0, 1] 1, if we have ever found prey<br>&emsp;&emsp;&emsp;&emsp;bool mHasBeenAttackedByPlayer = 0; // [0, 1] 1, if we have been ever attacked<br>&emsp;&emsp;&emsp;&emsp;bool mHasStartedAttacking = 0; // [0, 1] 1, if we have ever started attacking anyone<br>&emsp;&emsp;&emsp;&emsp;int mNearbyFoodCount = 0; // [0, 1] amount of 'food_material' near us<br>&emsp;&emsp;&emsp;&emsp;int mEatNextFrame = 0; // [0, 1] next frame we can eat<br>&emsp;&emsp;&emsp;&emsp;int mEatTime = 0; // [0, 1] time we've been constantly eating<br>&emsp;&emsp;&emsp;&emsp;int mFrameNextGiveUp = 0; // [0, 1] next frame we consider ourselves to be stuck<br>&emsp;&emsp;&emsp;&emsp;vec2 mLastFramesMovementAreaMin; //  AABB min of the area where we've been since the last time we got stuck<br>&emsp;&emsp;&emsp;&emsp;vec2 mLastFramesMovementAreaMax; //  AABB max of the area where we've been since the last time we got stuck<br>&emsp;&emsp;&emsp;&emsp;int mFoodMaterialId = -1; // [0, 1] cached id of 'food_material'<br>&emsp;&emsp;&emsp;&emsp;int mFoodParticleEffectMaterialId = -1; // [0, 1] cached id of 'food_particle_effect_material'<br>&emsp;&emsp;&emsp;&emsp;float mNextJumpLob = 1; // [0, 1] we use this for next jump<br>&emsp;&emsp;&emsp;&emsp;vec2 mNextJumpTarget; //  we use this for next jump<br>&emsp;&emsp;&emsp;&emsp;bool mNextJumpHasVelocity = 0; // [0, 1] we use this for next jump<br>&emsp;&emsp;&emsp;&emsp;int mLastFrameJumped = -1; // [0, 1] previous frame we launched into a jump<br>&emsp;&emsp;&emsp;&emsp;int mFramesWithoutTarget = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mLastFrameCanDamageOwnHerd = -1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;vec2 mHomePosition; //  where our home is located<br>&emsp;&emsp;&emsp;&emsp;int mLastFrameAttackWasDone = 0; // [0, 1] when was the last time we did an attack (not necessarily did damage to anyone though)<br>&emsp;&emsp;&emsp;&emsp;int mNextFrameCanCallFriend = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mNextFrameRespondFriend = -1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mHasNoticedPlayer = 0; // [0, 1] if 1, we have noticed player or player projectile<br>&emsp;&emsp;&emsp;&emsp;float mRangedAttackCurrentAimAngle = 0; // [0, 1] which direction does our gun currently point at, physically saying?<br>&emsp;&emsp;&emsp;&emsp;int mRangedAttackNextFrame = 0; // [0, 1] next frame we can perform a ranged attack<br>&emsp;&emsp;&emsp;&emsp;int mMeleeAttackNextFrame = 0; // [0, 1] next frame we can perform a melee attack<br>&emsp;&emsp;&emsp;&emsp;float mNextMeleeAttackDamage = 0; // [0, 1] the amount of damage our next melee attack will cause. used by finishing move logic<br>&emsp;&emsp;&emsp;&emsp;bool mMeleeAttacking = 0; // [0, 1] 1, if we're doing a melee attack<br>&emsp;&emsp;&emsp;&emsp;int mMeleeAttackDashNextFrame = 0; // [0, 1] the next frame we can perform a melee attack<br>&emsp;&emsp;&emsp;&emsp;RtsUnitGoal mCurrentJob; //  info about our current job. sorta legacy and could be simplified because the RTS logic is not used anywhere but doesn't have much overhead either.<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="ai_state" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 20]`</xs:documentation>
					<xs:documentation>Current state of ai, defines what the animal is doing</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ai_state_timer" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1000]`</xs:documentation>
					<xs:documentation>If not 0, then we wait till this frame to pop current state from our state stack</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="keep_state_alive_when_enabled" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, will ensure state timer keeps current state alive for a while when Component is Enabled</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="preferred_job" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>We always do this job, unless interrupted (i.e. by taking fire damage)</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="escape_if_damaged_probability" type="xs:int" default="30">
				<xs:annotation>
					<xs:documentation>`30` - `[0, 1]`</xs:documentation>
					<xs:documentation>the chance of escaping if someone damages us. only works if 'can_fly = 0 '</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_if_damaged_probability" type="xs:int" default="100">
				<xs:annotation>
					<xs:documentation>`100` - `[0, 1]`</xs:documentation>
					<xs:documentation>the chance of counter-attacking if someone damages us, and we didn't escape</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="eye_offset_x" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-100, 100]`</xs:documentation>
					<xs:documentation>We cast rays from our position + eye_offset to check if we can see something</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="eye_offset_y" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-100, 100]`</xs:documentation>
					<xs:documentation>We cast rays from our position + eye_offset to check if we can see something</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_only_if_attacked" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>If 1, we never attack anyone unless attacked before by someone</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="dont_counter_attack_own_herd" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>If 1, we don't attack members of our herd even if they accidentally attack us</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="creature_detection_range_x" type="xs:decimal" default="50">
				<xs:annotation>
					<xs:documentation>`50` - `[0, 2000]`</xs:documentation>
					<xs:documentation>When looking for threats/prey this is the max distance from us on the X axis we scan</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="creature_detection_range_y" type="xs:decimal" default="20">
				<xs:annotation>
					<xs:documentation>`20` - `[0, 2000]`</xs:documentation>
					<xs:documentation>When looking for threats/prey this is the max distance from us on the Y axis we scan</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="creature_detection_angular_range_deg" type="xs:decimal" default="90">
				<xs:annotation>
					<xs:documentation>`90` - `[0, 90]`</xs:documentation>
					<xs:documentation>When looking for threats/prey this is our field of view around the X axis. 90 means we scan the whole 180 degrees around the X axis, to the left and right</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="creature_detection_check_every_x_frames" type="xs:int" default="120">
				<xs:annotation>
					<xs:documentation>`120` - `[0, 5000]`</xs:documentation>
					<xs:documentation>Checks for threats/prey take place at least this many frames apart from each other</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="max_distance_to_cam_to_start_hunting" type="xs:decimal" default="300">
				<xs:annotation>
					<xs:documentation>`300` - `[0, 2000]`</xs:documentation>
					<xs:documentation>JobDefault idles before we've been once at least this close to the camera</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="pathfinding_max_depth_no_target" type="xs:int" default="50">
				<xs:annotation>
					<xs:documentation>`50` - `[0, 5000]`</xs:documentation>
					<xs:documentation>The maximum depth (in nodes) path search use when we have not found prey yet</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="pathfinding_max_depth_has_target" type="xs:int" default="120">
				<xs:annotation>
					<xs:documentation>`120` - `[0, 5000]`</xs:documentation>
					<xs:documentation>The maximum depth (in nodes) path search use when we have found prey</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="aggressiveness_min" type="xs:decimal" default="80">
				<xs:annotation>
					<xs:documentation>`80` - `[0, 100]`</xs:documentation>
					<xs:documentation>what's the initial random aggressiveness of this creature</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="aggressiveness_max" type="xs:decimal" default="100">
				<xs:annotation>
					<xs:documentation>`100` - `[0, 100]`</xs:documentation>
					<xs:documentation>what's the initial random aggressiveness of this creature</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="tries_to_ranged_attack_friends" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, the AI tries to attack whoever it considers a friend based on herd_ids, CHARMED and BERSERK status etc. useful e.g. for healers.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_melee_enabled" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>If 1, and melee attack has been configured, we can perform melee attacks</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_dash_enabled" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>If 1, and dash attack has been configured, we can perform dash attacks (a long-distance melee attack where we dash towards the enemy)</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_landing_ranged_enabled" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>If 1, and ranged attack has been configured, we can perform ranged attacks</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_ranged_enabled" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>If 1, and ranged attack has been configured, we can perform ranged attacks</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_knockback_multiplier" type="xs:decimal" default="100">
				<xs:annotation>
					<xs:documentation>`100` - `[-100, 100]`</xs:documentation>
					<xs:documentation>If not 0, melee and dash attacks cause knockback to target</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_static_turret" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>If 1, we can only attack in one fixed direction</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_melee_max_distance" type="xs:int" default="20">
				<xs:annotation>
					<xs:documentation>`20` - `[0, 400]`</xs:documentation>
					<xs:documentation>Maximum distance at which we can perform a melee attack</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_melee_action_frame" type="xs:int" default="2">
				<xs:annotation>
					<xs:documentation>`2` - `[0, 1000]`</xs:documentation>
					<xs:documentation>The animation frame during which the melee attack damage is inflicted and visual effects are created</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_melee_frames_between" type="xs:int" default="10">
				<xs:annotation>
					<xs:documentation>`10` - `[0, 1000]`</xs:documentation>
					<xs:documentation>The minimum number of frames we wait between melee attacks</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_melee_damage_min" type="xs:decimal" default="0.4">
				<xs:annotation>
					<xs:documentation>`0.4` - `[0, 100]`</xs:documentation>
					<xs:documentation>Melee attack damage inclusive minimum amount. The damage is randomized between melee attack_damage_min and attack_melee_damage_max</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_melee_damage_max" type="xs:decimal" default="0.6">
				<xs:annotation>
					<xs:documentation>`0.6` - `[0, 100]`</xs:documentation>
					<xs:documentation>Melee attack damage inclusive maximum amount. The damage is randomized between melee attack_damage_min and attack_melee_damage_max</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_melee_impulse_vector_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-100, 100]`</xs:documentation>
					<xs:documentation>The x component of the impulse that is applied to damaged entities</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_melee_impulse_vector_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-100, 100]`</xs:documentation>
					<xs:documentation>The y component of the impulse that is applied to damaged entities</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_melee_impulse_multiplier" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-100, 100]`</xs:documentation>
					<xs:documentation>A multiplier applied to attack_melee_impulse</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_melee_offset_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-1000, 1000]`</xs:documentation>
					<xs:documentation>Melee attack particle effects are created here</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_melee_offset_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-1000, 1000]`</xs:documentation>
					<xs:documentation>Melee attack particle effects are created here</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_melee_finish_enabled" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>If 1, we perform a finishing move when our attack would kill the target using the 'attack_finish' animation</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_melee_finish_action_frame" type="xs:int" default="2">
				<xs:annotation>
					<xs:documentation>`2` - `[0, 1000]`</xs:documentation>
					<xs:documentation>The animation frame during which the melee attack finishing move damage is inflicted and visual effects are created</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_dash_distance" type="xs:decimal" default="50">
				<xs:annotation>
					<xs:documentation>`50` - `[0, 10000]`</xs:documentation>
					<xs:documentation>The maximum distance from enemy at which we can perform a dash attack. If a normal melee attack is possible we always do that instead</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_dash_frames_between" type="xs:int" default="120">
				<xs:annotation>
					<xs:documentation>`120` - `[0, 1200]`</xs:documentation>
					<xs:documentation>The minimum number of frames we wait between dash attacks</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_dash_damage" type="xs:decimal" default="0.25">
				<xs:annotation>
					<xs:documentation>`0.25` - `[0, 20]`</xs:documentation>
					<xs:documentation>The amount of damage inflicted by the dash attack</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_dash_speed" type="xs:decimal" default="200">
				<xs:annotation>
					<xs:documentation>`200` - `[0, 5000]`</xs:documentation>
					<xs:documentation>The speed at which we dash</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_dash_lob" type="xs:decimal" default="0.9">
				<xs:annotation>
					<xs:documentation>`0.9` - `[0, 6]`</xs:documentation>
					<xs:documentation>The smaller this value is the more curved our dash attack trajectory is</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_ranged_min_distance" type="xs:decimal" default="10">
				<xs:annotation>
					<xs:documentation>`10` - `[0, 10000]`</xs:documentation>
					<xs:documentation>The minimum distance from enemy at which we can perform a ranged attack.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_ranged_max_distance" type="xs:decimal" default="160">
				<xs:annotation>
					<xs:documentation>`160` - `[0, 10000]`</xs:documentation>
					<xs:documentation>The maximum distance from enemy at which we can perform a ranged attack.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_ranged_action_frame" type="xs:int" default="2">
				<xs:annotation>
					<xs:documentation>`2` - `[0, 1000]`</xs:documentation>
					<xs:documentation>The frame of the 'attack_ranged' animation during which the ranged attack actually occurs</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_ranged_offset_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-1000, 1000]`</xs:documentation>
					<xs:documentation>'attack_ranged_entity_file' is created here when performing a ranged attack</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_ranged_offset_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-1000, 1000]`</xs:documentation>
					<xs:documentation>'attack_ranged_entity_file' is created here when performing a ranged attack</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_ranged_use_message" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>If 1, we do ranged attacks by sending a Message_UseItem</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_ranged_predict" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>If 1, we attempt to predict target movement and shoot accordingly</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_ranged_entity_file" type="xs:string" default="data/entities/projectiles/spear.xml">
				<xs:annotation>
					<xs:documentation>`data/entities/projectiles/spear.xml` - `[0, 1]`</xs:documentation>
					<xs:documentation>File to projectile entity that is created when performing a ranged attack</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_ranged_entity_count_min" type="xs:int" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1000]`</xs:documentation>
					<xs:documentation>Minimum number of projectiles shot when performing a ranged attack</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_ranged_entity_count_max" type="xs:int" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1000]`</xs:documentation>
					<xs:documentation>Maximum number of projectiles shot when performing a ranged attack</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_ranged_use_laser_sight" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>If 1, we draw a laser sight to our target. Requires entity to have a sprite with tag 'laser_sight'</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_ranged_laser_sight_beam_kind" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>0 = red, 1 = blue </xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_ranged_aim_rotation_enabled" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_ranged_aim_rotation_speed" type="xs:decimal" default="3">
				<xs:annotation>
					<xs:documentation>`3` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_ranged_aim_rotation_shooting_ok_angle_deg" type="xs:decimal" default="10">
				<xs:annotation>
					<xs:documentation>`10` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_ranged_state_duration_frames" type="xs:int" default="45">
				<xs:annotation>
					<xs:documentation>`45` - `[0, 1000]`</xs:documentation>
					<xs:documentation>How long do we stay in the attack state, before other states are allowed?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="hide_from_prey" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>If 1, we attempt to hide from our target after a succesful attack</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="hide_from_prey_target_distance" type="xs:decimal" default="200">
				<xs:annotation>
					<xs:documentation>`200` - `[0, 10000]`</xs:documentation>
					<xs:documentation>The minimum distance from our target where we should move when hiding</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="hide_from_prey_time" type="xs:int" default="300">
				<xs:annotation>
					<xs:documentation>`300` - `[0, 1]`</xs:documentation>
					<xs:documentation>The number of frames we spend hiding and staying hiding</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="food_eating_create_particles" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>If 1, we replace eaten cells with particles made of this material</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="eating_area_radius_x" type="xs:int" default="3">
				<xs:annotation>
					<xs:documentation>`3` - `[-100, 100]`</xs:documentation>
					<xs:documentation>1/2 width of the area from which we eat food</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="eating_area_radius_y" type="xs:int" default="8">
				<xs:annotation>
					<xs:documentation>`8` - `[-100, 100]`</xs:documentation>
					<xs:documentation>1/2 height of the area from which we eat food</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mouth_offset_x" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-100, 100]`</xs:documentation>
					<xs:documentation>The center of the area from which we eat food</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mouth_offset_y" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-100, 100]`</xs:documentation>
					<xs:documentation>The center of the area from which we eat food</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="defecates_and_pees" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>If 1, we occasionally take a leak or a dump</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="butt_offset_x" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-100, 100]`</xs:documentation>
					<xs:documentation>Bodily wastes are created here</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="butt_offset_y" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-100, 100]`</xs:documentation>
					<xs:documentation>Bodily wastes are created here</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="pee_velocity_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-1000, 1000]`</xs:documentation>
					<xs:documentation>The velocity at which our piss gets shot</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="pee_velocity_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-1000, 1000]`</xs:documentation>
					<xs:documentation>The velocity at which our piss gets shot</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="needs_food" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>If 1, we stop to eat if we encounter 'food_material' cells</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="sense_creatures" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>If 1, we occasionally search our surroundings for prey and threats</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="sense_creatures_through_walls" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>If 1, will see creatures even if the wall raycast fails</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="can_fly" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>If 1, we can fly. Please set 'PathFindingComponent.can_fly' to 1 as well if this is 1</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="can_walk" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>If 1, we can walk. Please set 'PathFindingComponent.can_walk' to 1 as well if this is 1</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="path_distance_to_target_node_to_turn_around" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1000]`</xs:documentation>
					<xs:documentation>If we're further than this from target path finding node on the X-axis we turn to face it</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="path_cleanup_explosion_radius" type="xs:decimal" default="6">
				<xs:annotation>
					<xs:documentation>`6` - `[0, 1000]`</xs:documentation>
					<xs:documentation>If we get stuck on ground we create an explosion this big to clear our surroundings a bit</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="max_distance_to_move_from_home" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: ConfigExplosion for attack_melee_finish_config_explosion -->
			<xs:attribute name="attack_ranged_frames_between" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>The minimum number of frames we wait between ranged attacks</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="food_material" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>The cell material we eat if encountering said material and 'needs_food' is 1</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="food_particle_effect_material" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>We create particles made of this material when eating if 'food_eating_create_particles' is 1</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mAggression" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>the greater this value the more likely we're to attack creatures from other herds</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: AI_STATE_STACK for mAiStateStack -->
			<xs:attribute name="mAiStateLastSwitchFrame" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>when was the last time we switched a state</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mAiStatePrev" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>previous AI state</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mCreatureDetectionNextCheck" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>threat/prey check, next time we check for threat/prey</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: EntityID for mGreatestThreat -->
				<!-- Some Unknown Type: EntityID for mGreatestPrey -->
			<xs:attribute name="mSelectedMultiAttack" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
					<xs:documentation>which AIAttackComponent attack are we using?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mHasFoundPrey" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>1, if we have ever found prey</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mHasBeenAttackedByPlayer" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>1, if we have been ever attacked</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mHasStartedAttacking" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>1, if we have ever started attacking anyone</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mNearbyFoodCount" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>amount of 'food_material' near us</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mEatNextFrame" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>next frame we can eat</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mEatTime" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>time we've been constantly eating</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mFrameNextGiveUp" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>next frame we consider ourselves to be stuck</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mLastFramesMovementAreaMin.x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>AABB min of the area where we've been since the last time we got stuck</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mLastFramesMovementAreaMin.y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>AABB min of the area where we've been since the last time we got stuck</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mLastFramesMovementAreaMax.x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>AABB max of the area where we've been since the last time we got stuck</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mLastFramesMovementAreaMax.y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>AABB max of the area where we've been since the last time we got stuck</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mFoodMaterialId" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
					<xs:documentation>cached id of 'food_material'</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mFoodParticleEffectMaterialId" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
					<xs:documentation>cached id of 'food_particle_effect_material'</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mNextJumpLob" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>we use this for next jump</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mNextJumpTarget.x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>we use this for next jump</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mNextJumpTarget.y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>we use this for next jump</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mNextJumpHasVelocity" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>we use this for next jump</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mLastFrameJumped" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
					<xs:documentation>previous frame we launched into a jump</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mFramesWithoutTarget" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mLastFrameCanDamageOwnHerd" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mHomePosition.x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>where our home is located</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mHomePosition.y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>where our home is located</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mLastFrameAttackWasDone" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>when was the last time we did an attack (not necessarily did damage to anyone though)</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mNextFrameCanCallFriend" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mNextFrameRespondFriend" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mHasNoticedPlayer" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, we have noticed player or player projectile</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mRangedAttackCurrentAimAngle" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>which direction does our gun currently point at, physically saying?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mRangedAttackNextFrame" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>next frame we can perform a ranged attack</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mMeleeAttackNextFrame" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>next frame we can perform a melee attack</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mNextMeleeAttackDamage" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>the amount of damage our next melee attack will cause. used by finishing move logic</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mMeleeAttacking" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>1, if we're doing a melee attack</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mMeleeAttackDashNextFrame" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>the next frame we can perform a melee attack</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: RtsUnitGoal for mCurrentJob -->
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="ArcComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ArcComponent {<br>&emsp;&emsp;&emsp;&emsp;int lifetime = 60; // [0, 1] remaining number of frames the arc exists<br>&emsp;&emsp;&emsp;&emsp;ARC_TYPE::Enum type; //  which implementation the arc should use<br>&emsp;&emsp;&emsp;&emsp;int material = 0; // [0, 1] string name for the material the arc is made of<br>&emsp;&emsp;&emsp;&emsp;EntityID mArcTarget = 0; // [0, 1] if 'mArcTarget' points to an existing entity a lighting arc will be created between this entity and 'mArcTarget'<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="lifetime" type="xs:int" default="60">
				<xs:annotation>
					<xs:documentation>`60` - `[0, 1]`</xs:documentation>
					<xs:documentation>remaining number of frames the arc exists</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: ARC_TYPE::Enum for type -->
			<xs:attribute name="material" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>string name for the material the arc is made of</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: EntityID for mArcTarget -->
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="AreaDamageComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class AreaDamageComponent {<br>&emsp;&emsp;&emsp;&emsp;float circle_radius = 0; // [0, 1] if > 0, will only damage entities inside the aabb rectangle which are closer than 'circle_radius' to the aabb center.<br>&emsp;&emsp;&emsp;&emsp;float damage_per_frame = 10; // [0, 256] <br>&emsp;&emsp;&emsp;&emsp;int update_every_n_frame = 1; // [0, 60] <br>&emsp;&emsp;&emsp;&emsp;EntityID entity_responsible = 0; // [0, 1] if NULL, will try to figure out who to blame<br>&emsp;&emsp;&emsp;&emsp;std::string death_cause = "$damage_curse"; // [0, 60] <br>&emsp;&emsp;&emsp;&emsp;std::string entities_with_tag = "mortal"; // [0, 1] damage entities with this tag<br>&emsp;&emsp;&emsp;&emsp;vec2 aabb_min;<br>&emsp;&emsp;&emsp;&emsp;vec2 aabb_max;<br>&emsp;&emsp;&emsp;&emsp;DAMAGE_TYPES::Enum damage_type; //  the damage type<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="circle_radius" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if &gt; 0, will only damage entities inside the aabb rectangle which are closer than 'circle_radius' to the aabb center.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="damage_per_frame" type="xs:decimal" default="10">
				<xs:annotation>
					<xs:documentation>`10` - `[0, 256]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="update_every_n_frame" type="xs:int" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 60]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: EntityID for entity_responsible -->
			<xs:attribute name="death_cause" type="xs:string" default="$damage_curse">
				<xs:annotation>
					<xs:documentation>`$damage_curse` - `[0, 60]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="entities_with_tag" type="xs:string" default="mortal">
				<xs:annotation>
					<xs:documentation>`mortal` - `[0, 1]`</xs:documentation>
					<xs:documentation>damage entities with this tag</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="aabb_min.x" type="xs:decimal" default="0" />
			<xs:attribute name="aabb_min.y" type="xs:decimal" default="0" />
			<xs:attribute name="aabb_max.x" type="xs:decimal" default="0" />
			<xs:attribute name="aabb_max.y" type="xs:decimal" default="0" />
				<!-- Some Unknown Type: DAMAGE_TYPES::Enum for damage_type -->
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="AttachToEntityComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class AttachToEntityComponent {<br>&emsp;&emsp;&emsp;&emsp;bool only_position = 0; // [0, 1] if 1, we only inherit position. it is calculated as follows: target_position + target_offset * target_scale<br>&emsp;&emsp;&emsp;&emsp;std::string target_hotspot_tag; //  if set, we apply the offset of target HotSpot with this tag<br>&emsp;&emsp;&emsp;&emsp;int target_sprite_id = -1; // [0, 1] if >= 0, the Nth sprite transform in target entity is inherited<br>&emsp;&emsp;&emsp;&emsp;bool rotate_based_on_x_scale = 0; // [0, 1] if 1, the rotation is set to 0 deg if scale >= 0 else to 180 deg<br>&emsp;&emsp;&emsp;&emsp;bool destroy_component_when_target_is_gone = 1; // [0, 1] should probably be on by default<br>&emsp;&emsp;&emsp;&emsp;types::xform Transform;<br>&emsp;&emsp;&emsp;&emsp;EntityID target = 0; // [0, 1] EntityID of the entity we're attached to. This will fail after save/load, unfortunately<br>&emsp;&emsp;&emsp;&emsp;int mUpdateFrame = -1; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:sequence minOccurs="0"> <xs:element name="Transform" type="Transform" /></xs:sequence>
			<xs:attribute name="only_position" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, we only inherit position. it is calculated as follows: target_position + target_offset * target_scale</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="target_hotspot_tag" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>if set, we apply the offset of target HotSpot with this tag</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="target_sprite_id" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if &gt;= 0, the Nth sprite transform in target entity is inherited</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="rotate_based_on_x_scale" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, the rotation is set to 0 deg if scale &gt;= 0 else to 180 deg</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="destroy_component_when_target_is_gone" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>should probably be on by default</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: EntityID for target -->
			<xs:attribute name="mUpdateFrame" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="AudioComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class AudioComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string file;<br>&emsp;&emsp;&emsp;&emsp;std::string event_root;<br>&emsp;&emsp;&emsp;&emsp;std::string audio_physics_material;<br>&emsp;&emsp;&emsp;&emsp;bool set_latest_event_position = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool remove_latest_event_on_destroyed = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool send_message_on_event_dead = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool play_only_if_visible = 0; // [0, 1] plays sounds only if entity position is on screen and not covered by fog of war<br>&emsp;&emsp;&emsp;&emsp;int m_audio_physics_material = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;AudioSourceHandle m_latest_source = -1; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="file" type="xs:string" default="" />
			<xs:attribute name="event_root" type="xs:string" default="" />
			<xs:attribute name="audio_physics_material" type="xs:string" default="" />
			<xs:attribute name="set_latest_event_position" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="remove_latest_event_on_destroyed" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="send_message_on_event_dead" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="play_only_if_visible" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>plays sounds only if entity position is on screen and not covered by fog of war</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="m_audio_physics_material" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: AudioSourceHandle for m_latest_source -->
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="AudioListenerComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class AudioListenerComponent {<br>&emsp;&emsp;&emsp;&emsp;float z = 0; // [-500, 500] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="z" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-500, 500]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="AudioLoopComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class AudioLoopComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string file;<br>&emsp;&emsp;&emsp;&emsp;std::string event_name;<br>&emsp;&emsp;&emsp;&emsp;bool auto_play = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool auto_play_if_enabled = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool play_on_component_enable = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool calculate_material_lowpass = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool set_speed_parameter = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool set_speed_parameter_only_based_on_x_movement = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool set_speed_parameter_only_based_on_y_movement = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float volume_autofade_speed = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float m_volume = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float m_intensity = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float m_intensity2 = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;AudioSourceHandle m_source = -1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int m_frame_created = -1; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="file" type="xs:string" default="" />
			<xs:attribute name="event_name" type="xs:string" default="" />
			<xs:attribute name="auto_play" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="auto_play_if_enabled" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="play_on_component_enable" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="calculate_material_lowpass" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="set_speed_parameter" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="set_speed_parameter_only_based_on_x_movement" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="set_speed_parameter_only_based_on_y_movement" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="volume_autofade_speed" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="m_volume" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="m_intensity" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="m_intensity2" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: AudioSourceHandle for m_source -->
			<xs:attribute name="m_frame_created" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="BiomeTrackerComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class BiomeTrackerComponent {<br>&emsp;&emsp;&emsp;&emsp;int limit_to_every_n_frame = 0; // [0, 1] if > 1, we will only check the biome every n frames<br>&emsp;&emsp;&emsp;&emsp;Biome* unsafe_current_biome; //  DO NOT ACCESS, since this can be in valid<br>&emsp;&emsp;&emsp;&emsp;std::string current_biome_name; //  used to track in which biome we are at<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="limit_to_every_n_frame" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if &gt; 1, we will only check the biome every n frames</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: Biome* for unsafe_current_biome -->
			<xs:attribute name="current_biome_name" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>used to track in which biome we are at</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="BlackHoleComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class BlackHoleComponent {<br>&emsp;&emsp;&emsp;&emsp;float radius = 16; // [0, 128] <br>&emsp;&emsp;&emsp;&emsp;float particle_attractor_force = 2; // [0, 32] <br>&emsp;&emsp;&emsp;&emsp;float damage_probability = 0.25; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float damage_amount = 0.1; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;int16 m_particle_attractor_id = -1; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="radius" type="xs:decimal" default="16">
				<xs:annotation>
					<xs:documentation>`16` - `[0, 128]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="particle_attractor_force" type="xs:decimal" default="2">
				<xs:annotation>
					<xs:documentation>`2` - `[0, 32]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="damage_probability" type="xs:decimal" default="0.25">
				<xs:annotation>
					<xs:documentation>`0.25` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="damage_amount" type="xs:decimal" default="0.1">
				<xs:annotation>
					<xs:documentation>`0.1` - `[0, 10]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="m_particle_attractor_id" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="BookComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class BookComponent {<br>&emsp;&emsp;&emsp;&emsp;float TEMP_TEMPY = 0; // [0, 3.5] <br>&emsp;&emsp;&emsp;&emsp;float TEMP_TEMP_TEMP = 0; // [0, 3.5] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="TEMP_TEMPY" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 3.5]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="TEMP_TEMP_TEMP" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 3.5]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="BossDragonComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class BossDragonComponent {<br>&emsp;&emsp;&emsp;&emsp;float speed = 1; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float speed_hunt = 3; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float acceleration = 3; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float direction_adjust_speed = 1; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float direction_adjust_speed_hunt = 1; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float gravity = 3; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float tail_gravity = 30; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float part_distance = 10; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;int ground_check_offset = 0; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float eat_ground_radius = 1; // [0, 1e+006] <br>&emsp;&emsp;&emsp;&emsp;bool eat_ground = 1; // [0, 1] does the worm destroy the ground it moves through or not?<br>&emsp;&emsp;&emsp;&emsp;float hitbox_radius = 1; // [0, 1e+006] <br>&emsp;&emsp;&emsp;&emsp;float bite_damage = 2; // [0, 10] how much damage does this do when it hits an entity<br>&emsp;&emsp;&emsp;&emsp;float target_kill_radius = 1; // [0, 1e+006] <br>&emsp;&emsp;&emsp;&emsp;float target_kill_ragdoll_force = 1; // [0, 1e+006] <br>&emsp;&emsp;&emsp;&emsp;float hunt_box_radius = 512; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float random_target_box_radius = 512; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;int new_hunt_target_check_every = 30; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;int new_random_target_check_every = 120; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float jump_cam_shake = 20; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float jump_cam_shake_distance = 256; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float eat_anim_wait_mult = 0.05; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;std::string projectile_1 = "data/entities/projectiles/bossdragon.xml"; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int projectile_1_count = 2; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;std::string projectile_2 = "data/entities/projectiles/bossdragon_ray.xml"; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int projectile_2_count = 5; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;std::string ragdoll_filename;<br>&emsp;&emsp;&emsp;&emsp;int mTargetEntityId = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;vec2 mTargetVec;<br>&emsp;&emsp;&emsp;&emsp;float mGravVelocity = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float mSpeed = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;vec2 mRandomTarget;<br>&emsp;&emsp;&emsp;&emsp;vec2 mLastLivingTargetPos;<br>&emsp;&emsp;&emsp;&emsp;int mNextTargetCheckFrame = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mNextHuntTargetCheckFrame = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mOnGroundPrev = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mMaterialIdPrev = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mPhase = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mNextPhaseSwitchTime = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float mPartDistance = 2; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mIsInitialized = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="speed" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="speed_hunt" type="xs:decimal" default="3">
				<xs:annotation>
					<xs:documentation>`3` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="acceleration" type="xs:decimal" default="3">
				<xs:annotation>
					<xs:documentation>`3` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="direction_adjust_speed" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="direction_adjust_speed_hunt" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="gravity" type="xs:decimal" default="3">
				<xs:annotation>
					<xs:documentation>`3` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="tail_gravity" type="xs:decimal" default="30">
				<xs:annotation>
					<xs:documentation>`30` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="part_distance" type="xs:decimal" default="10">
				<xs:annotation>
					<xs:documentation>`10` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ground_check_offset" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="eat_ground_radius" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1e+006]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="eat_ground" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>does the worm destroy the ground it moves through or not?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="hitbox_radius" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1e+006]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="bite_damage" type="xs:decimal" default="2">
				<xs:annotation>
					<xs:documentation>`2` - `[0, 10]`</xs:documentation>
					<xs:documentation>how much damage does this do when it hits an entity</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="target_kill_radius" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1e+006]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="target_kill_ragdoll_force" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1e+006]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="hunt_box_radius" type="xs:decimal" default="512">
				<xs:annotation>
					<xs:documentation>`512` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="random_target_box_radius" type="xs:decimal" default="512">
				<xs:annotation>
					<xs:documentation>`512` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="new_hunt_target_check_every" type="xs:int" default="30">
				<xs:annotation>
					<xs:documentation>`30` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="new_random_target_check_every" type="xs:int" default="120">
				<xs:annotation>
					<xs:documentation>`120` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="jump_cam_shake" type="xs:decimal" default="20">
				<xs:annotation>
					<xs:documentation>`20` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="jump_cam_shake_distance" type="xs:decimal" default="256">
				<xs:annotation>
					<xs:documentation>`256` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="eat_anim_wait_mult" type="xs:decimal" default="0.05">
				<xs:annotation>
					<xs:documentation>`0.05` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="projectile_1" type="xs:string" default="data/entities/projectiles/bossdragon.xml">
				<xs:annotation>
					<xs:documentation>`data/entities/projectiles/bossdragon.xml` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="projectile_1_count" type="xs:int" default="2">
				<xs:annotation>
					<xs:documentation>`2` - `[0, 10]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="projectile_2" type="xs:string" default="data/entities/projectiles/bossdragon_ray.xml">
				<xs:annotation>
					<xs:documentation>`data/entities/projectiles/bossdragon_ray.xml` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="projectile_2_count" type="xs:int" default="5">
				<xs:annotation>
					<xs:documentation>`5` - `[0, 10]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ragdoll_filename" type="xs:string" default="" />
			<xs:attribute name="mTargetEntityId" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mTargetVec.x" type="xs:decimal" default="0" />
			<xs:attribute name="mTargetVec.y" type="xs:decimal" default="0" />
			<xs:attribute name="mGravVelocity" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mSpeed" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mRandomTarget.x" type="xs:decimal" default="0" />
			<xs:attribute name="mRandomTarget.y" type="xs:decimal" default="0" />
			<xs:attribute name="mLastLivingTargetPos.x" type="xs:decimal" default="0" />
			<xs:attribute name="mLastLivingTargetPos.y" type="xs:decimal" default="0" />
			<xs:attribute name="mNextTargetCheckFrame" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mNextHuntTargetCheckFrame" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mOnGroundPrev" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mMaterialIdPrev" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mPhase" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mNextPhaseSwitchTime" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mPartDistance" type="xs:decimal" default="2">
				<xs:annotation>
					<xs:documentation>`2` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mIsInitialized" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="BossHealthBarComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class BossHealthBarComponent {<br>&emsp;&emsp;&emsp;&emsp;bool gui = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool gui_special_final_boss = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool in_world = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float gui_max_distance_visible = 600; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mOldSpritesDestroyed = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="gui" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="gui_special_final_boss" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="in_world" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="gui_max_distance_visible" type="xs:decimal" default="600">
				<xs:annotation>
					<xs:documentation>`600` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mOldSpritesDestroyed" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="CameraBoundComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class CameraBoundComponent {<br>&emsp;&emsp;&emsp;&emsp;bool enabled = 1; // [0, 1] If enabled, kills this component if it's outside the camera distance<br>&emsp;&emsp;&emsp;&emsp;float distance = 250; // [0, 1024] Distance in pixels from the center of camera, if outside this distance the entity is destroyed<br>&emsp;&emsp;&emsp;&emsp;float distance_border = 20; // [0, 1024] Offset towards camera in pixels from 'distance' where the entity is respawned if it was frozen<br>&emsp;&emsp;&emsp;&emsp;int max_count = 10; // [0, 1024] If more than 'max_count' entities of this type exist the one furthest from camera is destroyed<br>&emsp;&emsp;&emsp;&emsp;bool freeze_on_distance_kill = 1; // [0, 1] If true and the entity went too far - this entity will be stored so we can later respawn it where it was destroyed because it got too far from the camera?<br>&emsp;&emsp;&emsp;&emsp;bool freeze_on_max_count_kill = 1; // [0, 1] If true and the entity was one too many of its kind - this entity will be stored so we can later respawn it where it was destroyed because it got too far from the camera?<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="enabled" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>If enabled, kills this component if it's outside the camera distance</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="distance" type="xs:decimal" default="250">
				<xs:annotation>
					<xs:documentation>`250` - `[0, 1024]`</xs:documentation>
					<xs:documentation>Distance in pixels from the center of camera, if outside this distance the entity is destroyed</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="distance_border" type="xs:decimal" default="20">
				<xs:annotation>
					<xs:documentation>`20` - `[0, 1024]`</xs:documentation>
					<xs:documentation>Offset towards camera in pixels from 'distance' where the entity is respawned if it was frozen</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="max_count" type="xs:int" default="10">
				<xs:annotation>
					<xs:documentation>`10` - `[0, 1024]`</xs:documentation>
					<xs:documentation>If more than 'max_count' entities of this type exist the one furthest from camera is destroyed</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="freeze_on_distance_kill" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>If true and the entity went too far - this entity will be stored so we can later respawn it where it was destroyed because it got too far from the camera?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="freeze_on_max_count_kill" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>If true and the entity was one too many of its kind - this entity will be stored so we can later respawn it where it was destroyed because it got too far from the camera?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="CardinalMovementComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class CardinalMovementComponent {<br>&emsp;&emsp;&emsp;&emsp;bool horizontal_movement = 1; // [0, 1] allow horizontal movement<br>&emsp;&emsp;&emsp;&emsp;bool vertical_movement = 1; // [0, 1] allow vertical movement<br>&emsp;&emsp;&emsp;&emsp;bool intercardinal_movement = 0; // [0, 1] allow intercardinal movement<br>&emsp;&emsp;&emsp;&emsp;vec2 mPrevPos;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="horizontal_movement" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>allow horizontal movement</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="vertical_movement" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>allow vertical movement</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="intercardinal_movement" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>allow intercardinal movement</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mPrevPos.x" type="xs:decimal" default="0" />
			<xs:attribute name="mPrevPos.y" type="xs:decimal" default="0" />
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="CellEaterComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class CellEaterComponent {<br>&emsp;&emsp;&emsp;&emsp;float radius = 10; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;int eat_probability = 100; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;bool only_stain = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool eat_dynamic_physics_bodies = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool limited_materials = 0; // [0, 1] if true, will only eat the materials defined in material_list<br>&emsp;&emsp;&emsp;&emsp;std::string ignored_material_tag; //  if set, will not eat any materials with this tag. please note that this lowers the performance of cell eating by some amount.<br>&emsp;&emsp;&emsp;&emsp;int ignored_material = 0; // [0, 1] String name of a material that shouldn't be eaten by the component<br>&emsp;&emsp;&emsp;&emsp;VEC_OF_MATERIALS materials; //  is a list of accepted materials sorted<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="radius" type="xs:decimal" default="10">
				<xs:annotation>
					<xs:documentation>`10` - `[0, 100]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="eat_probability" type="xs:int" default="100">
				<xs:annotation>
					<xs:documentation>`100` - `[0, 100]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="only_stain" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="eat_dynamic_physics_bodies" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="limited_materials" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, will only eat the materials defined in material_list</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ignored_material_tag" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>if set, will not eat any materials with this tag. please note that this lowers the performance of cell eating by some amount.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ignored_material" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>String name of a material that shouldn't be eaten by the component</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: VEC_OF_MATERIALS for materials -->
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="CharacterCollisionComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class CharacterCollisionComponent {<br>&emsp;&emsp;&emsp;&emsp;int getting_crushed_threshold = 5; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;int moving_up_before_getting_crushed_threshold = 3; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;int getting_crushed_counter = 0; // [0, 1] 1.12.2018 - Is this still used?<br>&emsp;&emsp;&emsp;&emsp;int stuck_in_ground_counter = 0; // [0, 1] used this mostly for player to figure out if it's stuck in ground<br>&emsp;&emsp;&emsp;&emsp;bool mCollidedHorizontally = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="getting_crushed_threshold" type="xs:int" default="5">
				<xs:annotation>
					<xs:documentation>`5` - `[0, 100]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="moving_up_before_getting_crushed_threshold" type="xs:int" default="3">
				<xs:annotation>
					<xs:documentation>`3` - `[0, 100]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="getting_crushed_counter" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>1.12.2018 - Is this still used?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="stuck_in_ground_counter" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>used this mostly for player to figure out if it's stuck in ground</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mCollidedHorizontally" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="CharacterDataComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class CharacterDataComponent {<br>&emsp;&emsp;&emsp;&emsp;int platforming_type = 0; // [0, 3] 0 = oldest, 1 = newer, 2 = safest<br>&emsp;&emsp;&emsp;&emsp;float mass = 1; // [0, 10] 1.0 = approx. mass of player<br>&emsp;&emsp;&emsp;&emsp;int buoyancy_check_offset_y = -6; // [-1000, 1000] <br>&emsp;&emsp;&emsp;&emsp;float liquid_velocity_coeff = 9; // [0, 20] how much do liquids move this character. e.g. when standing in a flowing river<br>&emsp;&emsp;&emsp;&emsp;float gravity = 100; // [0, 250] <br>&emsp;&emsp;&emsp;&emsp;float fly_recharge_spd = 0; // [0, 250] <br>&emsp;&emsp;&emsp;&emsp;float fly_recharge_spd_ground = 0; // [0, 250] <br>&emsp;&emsp;&emsp;&emsp;bool flying_needs_recharge = 0; // [0, 1] const variable... player has this as true<br>&emsp;&emsp;&emsp;&emsp;int flying_in_air_wait_frames = 44; // [0, 200] to fix the tap tap tap flying cheese, we wait this many frames before recharging in air<br>&emsp;&emsp;&emsp;&emsp;int flying_recharge_removal_frames = 8; // [0, 20] another fix to the tap tap - this is how many frames from pressing down up we'll remove fly charge<br>&emsp;&emsp;&emsp;&emsp;int climb_over_y = 3; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;int check_collision_max_size_x = 5; // [0, 50] <br>&emsp;&emsp;&emsp;&emsp;int check_collision_max_size_y = 5; // [0, 50] <br>&emsp;&emsp;&emsp;&emsp;bool is_on_ground = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool is_on_slippery_ground = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float ground_stickyness = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool effect_hit_ground = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int eff_hg_damage_min = 0; // [0, 1] if we want to damage ground when hitting it... this is the place<br>&emsp;&emsp;&emsp;&emsp;int eff_hg_damage_max = 0; // [0, 1] if we want to damage ground when hitting it... this is the place<br>&emsp;&emsp;&emsp;&emsp;float eff_hg_position_x = 0; // [-15, 15] <br>&emsp;&emsp;&emsp;&emsp;float eff_hg_position_y = 0; // [-15, 15] <br>&emsp;&emsp;&emsp;&emsp;float eff_hg_size_x = 0; // [-15, 15] <br>&emsp;&emsp;&emsp;&emsp;float eff_hg_size_y = 0; // [-15, 15] <br>&emsp;&emsp;&emsp;&emsp;float eff_hg_velocity_min_x = 0; // [-65, 65] <br>&emsp;&emsp;&emsp;&emsp;float eff_hg_velocity_max_x = 0; // [-65, 65] <br>&emsp;&emsp;&emsp;&emsp;float eff_hg_velocity_min_y = 0; // [-65, 65] <br>&emsp;&emsp;&emsp;&emsp;float eff_hg_velocity_max_y = 0; // [-65, 65] <br>&emsp;&emsp;&emsp;&emsp;float eff_hg_offset_y = 0; // [-15, 15] <br>&emsp;&emsp;&emsp;&emsp;bool eff_hg_update_box2d = 0; // [0, 1] if true, will move physics bodies that it hits<br>&emsp;&emsp;&emsp;&emsp;float eff_hg_b2force_multiplier = 0.0035; // [0, 1] multiplies the velocity with this...<br>&emsp;&emsp;&emsp;&emsp;float destroy_ground = 0; // [0, 1] how much damage do we do the ground when land on it<br>&emsp;&emsp;&emsp;&emsp;bool send_transform_update_message = 0; // [0, 1] if 1, will send Message_TransformUpdated to updated entities and their children when the component is processed by PlayerCollisionSystem or CharacterCollisionSystem<br>&emsp;&emsp;&emsp;&emsp;bool dont_update_velocity_and_xform = 0; // [0, 1] might be useful if you want to use CharacterCollisionSystem to only update on_ground status<br>&emsp;&emsp;&emsp;&emsp;float mFlyingTimeLeft = 1000; // [0, 1] How much flying energy do we have left? - NOTE( Petri ): 1.3.2023 - This used to be a private variable. It was changed to fix the save/load infinite flying bug.<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> collision_aabb_min_x;<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> collision_aabb_max_x;<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> collision_aabb_min_y;<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> collision_aabb_max_y;<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> fly_time_max; //  how much flying energy + <br>&emsp;&emsp;&emsp;&emsp;int mFramesOnGround = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mLastFrameOnGround = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;vec2 mVelocity;<br>&emsp;&emsp;&emsp;&emsp;bool mCollidedHorizontally = 0; // [0, 1] moved this here from CharacterCollisionComponent - since that is multithreaded and we needed a non multithreaded version<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="platforming_type" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 3]`</xs:documentation>
					<xs:documentation>0 = oldest, 1 = newer, 2 = safest</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mass" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 10]`</xs:documentation>
					<xs:documentation>1.0 = approx. mass of player</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="buoyancy_check_offset_y" type="xs:int" default="-6">
				<xs:annotation>
					<xs:documentation>`-6` - `[-1000, 1000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="liquid_velocity_coeff" type="xs:decimal" default="9">
				<xs:annotation>
					<xs:documentation>`9` - `[0, 20]`</xs:documentation>
					<xs:documentation>how much do liquids move this character. e.g. when standing in a flowing river</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="gravity" type="xs:decimal" default="100">
				<xs:annotation>
					<xs:documentation>`100` - `[0, 250]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="fly_recharge_spd" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 250]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="fly_recharge_spd_ground" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 250]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="flying_needs_recharge" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>const variable... player has this as true</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="flying_in_air_wait_frames" type="xs:int" default="44">
				<xs:annotation>
					<xs:documentation>`44` - `[0, 200]`</xs:documentation>
					<xs:documentation>to fix the tap tap tap flying cheese, we wait this many frames before recharging in air</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="flying_recharge_removal_frames" type="xs:int" default="8">
				<xs:annotation>
					<xs:documentation>`8` - `[0, 20]`</xs:documentation>
					<xs:documentation>another fix to the tap tap - this is how many frames from pressing down up we'll remove fly charge</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="climb_over_y" type="xs:int" default="3">
				<xs:annotation>
					<xs:documentation>`3` - `[0, 10]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="check_collision_max_size_x" type="xs:int" default="5">
				<xs:annotation>
					<xs:documentation>`5` - `[0, 50]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="check_collision_max_size_y" type="xs:int" default="5">
				<xs:annotation>
					<xs:documentation>`5` - `[0, 50]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_on_ground" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_on_slippery_ground" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ground_stickyness" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="effect_hit_ground" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="eff_hg_damage_min" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if we want to damage ground when hitting it... this is the place</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="eff_hg_damage_max" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if we want to damage ground when hitting it... this is the place</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="eff_hg_position_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-15, 15]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="eff_hg_position_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-15, 15]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="eff_hg_size_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-15, 15]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="eff_hg_size_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-15, 15]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="eff_hg_velocity_min_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-65, 65]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="eff_hg_velocity_max_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-65, 65]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="eff_hg_velocity_min_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-65, 65]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="eff_hg_velocity_max_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-65, 65]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="eff_hg_offset_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-15, 15]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="eff_hg_update_box2d" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, will move physics bodies that it hits</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="eff_hg_b2force_multiplier" type="xs:decimal" default="0.0035">
				<xs:annotation>
					<xs:documentation>`0.0035` - `[0, 1]`</xs:documentation>
					<xs:documentation>multiplies the velocity with this...</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="destroy_ground" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>how much damage do we do the ground when land on it</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="send_transform_update_message" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, will send Message_TransformUpdated to updated entities and their children when the component is processed by PlayerCollisionSystem or CharacterCollisionSystem</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="dont_update_velocity_and_xform" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>might be useful if you want to use CharacterCollisionSystem to only update on_ground status</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mFlyingTimeLeft" type="xs:decimal" default="1000">
				<xs:annotation>
					<xs:documentation>`1000` - `[0, 1]`</xs:documentation>
					<xs:documentation>How much flying energy do we have left? - NOTE( Petri ): 1.3.2023 - This used to be a private variable. It was changed to fix the save/load infinite flying bug.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="collision_aabb_min_x" type="xs:decimal" default="0" />
			<xs:attribute name="collision_aabb_max_x" type="xs:decimal" default="0" />
			<xs:attribute name="collision_aabb_min_y" type="xs:decimal" default="0" />
			<xs:attribute name="collision_aabb_max_y" type="xs:decimal" default="0" />
			<xs:attribute name="fly_time_max" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>how much flying energy + </xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mFramesOnGround" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mLastFrameOnGround" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mVelocity.x" type="xs:decimal" default="0" />
			<xs:attribute name="mVelocity.y" type="xs:decimal" default="0" />
			<xs:attribute name="mCollidedHorizontally" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>moved this here from CharacterCollisionComponent - since that is multithreaded and we needed a non multithreaded version</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="CharacterPlatformingComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class CharacterPlatformingComponent {<br>&emsp;&emsp;&emsp;&emsp;float jump_velocity_x = 0; // [0, 500] <br>&emsp;&emsp;&emsp;&emsp;float jump_velocity_y = -175; // [-500, 0] <br>&emsp;&emsp;&emsp;&emsp;int jump_keydown_buffer = 2; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;float fly_speed_mult = 0; // [-100, 100] AI stuff<br>&emsp;&emsp;&emsp;&emsp;float fly_speed_change_spd = 5; // [0, 1000] player<br>&emsp;&emsp;&emsp;&emsp;bool fly_model_player = 0; // [0, 1] if true, uses player fly model<br>&emsp;&emsp;&emsp;&emsp;bool fly_smooth_y = 1; // [0, 1] if true, smooths out the AI fly model<br>&emsp;&emsp;&emsp;&emsp;float accel_x = 1; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;float accel_x_air = 0.1; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;float pixel_gravity = 600; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;float swim_idle_buoyancy_coeff = 1.2; // [0, 2] <br>&emsp;&emsp;&emsp;&emsp;float swim_down_buoyancy_coeff = 0.7; // [0, 2] <br>&emsp;&emsp;&emsp;&emsp;float swim_up_buoyancy_coeff = 0.9; // [0, 2] <br>&emsp;&emsp;&emsp;&emsp;float swim_drag = 0.95; // [0, 2] when in water velocity *= swim_drag<br>&emsp;&emsp;&emsp;&emsp;float swim_extra_horizontal_drag = 0.9; // [0, 2] when in water velocity.x *= swim_extra_horizontal_drag<br>&emsp;&emsp;&emsp;&emsp;bool mouse_look = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float mouse_look_buffer = 1; // [0, 5] <br>&emsp;&emsp;&emsp;&emsp;bool keyboard_look = 0; // [0, 1] if true, turns based on if left or right has been pressed down<br>&emsp;&emsp;&emsp;&emsp;float turning_buffer = 0.1; // [0, 2] <br>&emsp;&emsp;&emsp;&emsp;std::string animation_to_play;<br>&emsp;&emsp;&emsp;&emsp;std::string animation_to_play_next;<br>&emsp;&emsp;&emsp;&emsp;float run_animation_velocity_switching_threshold = 45; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;bool run_animation_velocity_switching_enabled = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int turn_animation_frames_between = 20; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;int precision_jumping_max_duration_frames = -1; // [0, 1] maximum duration of precision jump or knockback. -1 = infinite<br>&emsp;&emsp;&emsp;&emsp;float audio_liquid_splash_intensity = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;LensValue<float> velocity_min_x;<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> velocity_max_x;<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> velocity_min_y;<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> velocity_max_y;<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> run_velocity;<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> fly_velocity_x;<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> fly_speed_max_up;<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> fly_speed_max_down;<br>&emsp;&emsp;&emsp;&emsp;vec2 mExAnimationPos;<br>&emsp;&emsp;&emsp;&emsp;int mFramesInAirCounter = -1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mIsPrecisionJumping = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mPrecisionJumpingTime = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float mPrecisionJumpingSpeedX = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mPrecisionJumpingTimeLeft = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float mFlyThrottle = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float mSmoothedFlyingTargetY = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mJetpackEmitting = -1; // [0, 1] -1 = undefined, 0 = not emitting, 1 = emitting<br>&emsp;&emsp;&emsp;&emsp;int mNextTurnAnimationFrame = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mFramesNotSwimming = 10; // [0, 1] 0 = currently swimming<br>&emsp;&emsp;&emsp;&emsp;int mFramesSwimming = 0; // [0, 1] 0 = not currently swimming<br>&emsp;&emsp;&emsp;&emsp;bool mShouldCrouch = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mShouldCrouchPrev = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mLastPostureSwitchFrame = -1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mLookOverrideLastFrame = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mLookOverrideDirection = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="jump_velocity_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 500]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="jump_velocity_y" type="xs:decimal" default="-175">
				<xs:annotation>
					<xs:documentation>`-175` - `[-500, 0]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="jump_keydown_buffer" type="xs:int" default="2">
				<xs:annotation>
					<xs:documentation>`2` - `[0, 10]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="fly_speed_mult" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-100, 100]`</xs:documentation>
					<xs:documentation>AI stuff</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="fly_speed_change_spd" type="xs:decimal" default="5">
				<xs:annotation>
					<xs:documentation>`5` - `[0, 1000]`</xs:documentation>
					<xs:documentation>player</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="fly_model_player" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, uses player fly model</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="fly_smooth_y" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, smooths out the AI fly model</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="accel_x" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="accel_x_air" type="xs:decimal" default="0.1">
				<xs:annotation>
					<xs:documentation>`0.1` - `[0, 1000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="pixel_gravity" type="xs:decimal" default="600">
				<xs:annotation>
					<xs:documentation>`600` - `[0, 1000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="swim_idle_buoyancy_coeff" type="xs:decimal" default="1.2">
				<xs:annotation>
					<xs:documentation>`1.2` - `[0, 2]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="swim_down_buoyancy_coeff" type="xs:decimal" default="0.7">
				<xs:annotation>
					<xs:documentation>`0.7` - `[0, 2]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="swim_up_buoyancy_coeff" type="xs:decimal" default="0.9">
				<xs:annotation>
					<xs:documentation>`0.9` - `[0, 2]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="swim_drag" type="xs:decimal" default="0.95">
				<xs:annotation>
					<xs:documentation>`0.95` - `[0, 2]`</xs:documentation>
					<xs:documentation>when in water velocity *= swim_drag</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="swim_extra_horizontal_drag" type="xs:decimal" default="0.9">
				<xs:annotation>
					<xs:documentation>`0.9` - `[0, 2]`</xs:documentation>
					<xs:documentation>when in water velocity.x *= swim_extra_horizontal_drag</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mouse_look" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mouse_look_buffer" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 5]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="keyboard_look" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, turns based on if left or right has been pressed down</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="turning_buffer" type="xs:decimal" default="0.1">
				<xs:annotation>
					<xs:documentation>`0.1` - `[0, 2]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="animation_to_play" type="xs:string" default="" />
			<xs:attribute name="animation_to_play_next" type="xs:string" default="" />
			<xs:attribute name="run_animation_velocity_switching_threshold" type="xs:decimal" default="45">
				<xs:annotation>
					<xs:documentation>`45` - `[0, 1000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="run_animation_velocity_switching_enabled" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="turn_animation_frames_between" type="xs:int" default="20">
				<xs:annotation>
					<xs:documentation>`20` - `[0, 100]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="precision_jumping_max_duration_frames" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
					<xs:documentation>maximum duration of precision jump or knockback. -1 = infinite</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="audio_liquid_splash_intensity" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="velocity_min_x" type="xs:decimal" default="0" />
			<xs:attribute name="velocity_max_x" type="xs:decimal" default="0" />
			<xs:attribute name="velocity_min_y" type="xs:decimal" default="0" />
			<xs:attribute name="velocity_max_y" type="xs:decimal" default="0" />
			<xs:attribute name="run_velocity" type="xs:decimal" default="0" />
			<xs:attribute name="fly_velocity_x" type="xs:decimal" default="0" />
			<xs:attribute name="fly_speed_max_up" type="xs:decimal" default="0" />
			<xs:attribute name="fly_speed_max_down" type="xs:decimal" default="0" />
			<xs:attribute name="mExAnimationPos.x" type="xs:decimal" default="0" />
			<xs:attribute name="mExAnimationPos.y" type="xs:decimal" default="0" />
			<xs:attribute name="mFramesInAirCounter" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mIsPrecisionJumping" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mPrecisionJumpingTime" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mPrecisionJumpingSpeedX" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mPrecisionJumpingTimeLeft" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mFlyThrottle" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mSmoothedFlyingTargetY" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mJetpackEmitting" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
					<xs:documentation>-1 = undefined, 0 = not emitting, 1 = emitting</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mNextTurnAnimationFrame" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mFramesNotSwimming" type="xs:int" default="10">
				<xs:annotation>
					<xs:documentation>`10` - `[0, 1]`</xs:documentation>
					<xs:documentation>0 = currently swimming</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mFramesSwimming" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>0 = not currently swimming</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mShouldCrouch" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mShouldCrouchPrev" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mLastPostureSwitchFrame" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mLookOverrideLastFrame" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mLookOverrideDirection" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="CharacterStatsComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class CharacterStatsComponent {<br>&emsp;&emsp;&emsp;&emsp;CharacterStatsModifier stats;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
				<!-- Some Unknown Type: CharacterStatsModifier for stats -->
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="CollisionTriggerComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class CollisionTriggerComponent {<br>&emsp;&emsp;&emsp;&emsp;float width = 32; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;float height = 32; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;float radius = 32; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;std::string required_tag = "mortal"; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool remove_component_when_triggered = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool destroy_this_entity_when_triggered = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int timer_for_destruction = 0; // [0, 60] <br>&emsp;&emsp;&emsp;&emsp;bool self_trigger = 0; // [0, 1] if true, the shooter can trigger it<br>&emsp;&emsp;&emsp;&emsp;int skip_self_frames = 60; // [0, 1] skips checks against self during these frames<br>&emsp;&emsp;&emsp;&emsp;int mTimer = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="width" type="xs:decimal" default="32">
				<xs:annotation>
					<xs:documentation>`32` - `[0, 100]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="height" type="xs:decimal" default="32">
				<xs:annotation>
					<xs:documentation>`32` - `[0, 100]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="radius" type="xs:decimal" default="32">
				<xs:annotation>
					<xs:documentation>`32` - `[0, 100]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="required_tag" type="xs:string" default="mortal">
				<xs:annotation>
					<xs:documentation>`mortal` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="remove_component_when_triggered" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="destroy_this_entity_when_triggered" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="timer_for_destruction" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 60]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="self_trigger" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, the shooter can trigger it</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="skip_self_frames" type="xs:int" default="60">
				<xs:annotation>
					<xs:documentation>`60` - `[0, 1]`</xs:documentation>
					<xs:documentation>skips checks against self during these frames</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mTimer" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="ConsumableTeleportComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ConsumableTeleportComponent {<br>&emsp;&emsp;&emsp;&emsp;bool create_other_end = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool is_at_home = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float collision_radius = 10; // [0, 20] <br>&emsp;&emsp;&emsp;&emsp;uint32 target_id = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;uint32 id = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mNextUsableFrame = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mHasOtherEnd = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;vec2 target_location;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="create_other_end" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_at_home" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="collision_radius" type="xs:decimal" default="10">
				<xs:annotation>
					<xs:documentation>`10` - `[0, 20]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="target_id" type="xs:unsignedInt" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="id" type="xs:unsignedInt" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mNextUsableFrame" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mHasOtherEnd" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="target_location.x" type="xs:decimal" default="0" />
			<xs:attribute name="target_location.y" type="xs:decimal" default="0" />
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="ControllerGoombaAIComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ControllerGoombaAIComponent {<br>&emsp;&emsp;&emsp;&emsp;bool auto_turn_around_enabled = 1; // [0, 1] disable this if you don't want creature to 'look around', while standing still<br>&emsp;&emsp;&emsp;&emsp;int wait_to_turn_around = 50; // [0, 300] <br>&emsp;&emsp;&emsp;&emsp;int wall_hit_wait = 10; // [0, 300] <br>&emsp;&emsp;&emsp;&emsp;bool check_wall_detection = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float wall_detection_aabb_min_x = 0; // [-15, 15] <br>&emsp;&emsp;&emsp;&emsp;float wall_detection_aabb_max_x = 0; // [-15, 15] <br>&emsp;&emsp;&emsp;&emsp;float wall_detection_aabb_min_y = 0; // [-15, 15] <br>&emsp;&emsp;&emsp;&emsp;float wall_detection_aabb_max_y = 0; // [-15, 15] <br>&emsp;&emsp;&emsp;&emsp;bool check_floor_detection = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float floor_detection_aabb_min_x = 0; // [-15, 15] <br>&emsp;&emsp;&emsp;&emsp;float floor_detection_aabb_max_x = 0; // [-15, 15] <br>&emsp;&emsp;&emsp;&emsp;float floor_detection_aabb_min_y = 0; // [-15, 15] <br>&emsp;&emsp;&emsp;&emsp;float floor_detection_aabb_max_y = 0; // [-15, 15] <br>&emsp;&emsp;&emsp;&emsp;int mChangingDirectionCounter = -1; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="auto_turn_around_enabled" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>disable this if you don't want creature to 'look around', while standing still</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="wait_to_turn_around" type="xs:int" default="50">
				<xs:annotation>
					<xs:documentation>`50` - `[0, 300]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="wall_hit_wait" type="xs:int" default="10">
				<xs:annotation>
					<xs:documentation>`10` - `[0, 300]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="check_wall_detection" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="wall_detection_aabb_min_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-15, 15]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="wall_detection_aabb_max_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-15, 15]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="wall_detection_aabb_min_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-15, 15]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="wall_detection_aabb_max_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-15, 15]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="check_floor_detection" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="floor_detection_aabb_min_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-15, 15]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="floor_detection_aabb_max_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-15, 15]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="floor_detection_aabb_min_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-15, 15]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="floor_detection_aabb_max_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-15, 15]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mChangingDirectionCounter" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="ControlsComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ControlsComponent {<br>&emsp;&emsp;&emsp;&emsp;bool polymorph_hax = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int polymorph_next_attack_frame = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool enabled = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool gamepad_indirect_aiming_enabled = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool gamepad_fire_on_thumbstick_extend = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float gamepad_fire_on_thumbstick_extend_threshold = 0.7; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownFire = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameFire = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mButtonLastFrameFire = -2; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownFire2 = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameFire2 = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownAction = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameAction = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownThrow = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameThrow = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownInteract = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameInteract = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownLeft = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameLeft = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownRight = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameRight = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownUp = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameUp = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownDown = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameDown = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownJump = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameJump = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownRun = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameRun = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownFly = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameFly = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownDig = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameDig = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownChangeItemR = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameChangeItemR = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mButtonCountChangeItemR = 0; // [0, 1] note these have special count property<br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownChangeItemL = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameChangeItemL = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mButtonCountChangeItemL = 0; // [0, 1] note these have special count property<br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownInventory = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameInventory = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownHolsterItem = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameHolsterItem = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownDropItem = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameDropItem = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownKick = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameKick = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownEat = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameEat = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownLeftClick = 0; // [0, 1] NOTE! Ignores gamepad, if mouse is pressed this will be true.<br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameLeftClick = 0; // [0, 1] NOTE! Ignores gamepad, if mouse is pressed this will be true.<br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownRightClick = 0; // [0, 1] NOTE! Ignores gamepad, if mouse is pressed this will be true.<br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameRightClick = 0; // [0, 1] NOTE! Ignores gamepad, if mouse is pressed this will be true.<br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownTransformLeft = 0; // [0, 1] NOT IN USE!<br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameTransformLeft = 0; // [0, 1] NOT IN USE!<br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownTransformRight = 0; // [0, 1] NOT IN USE!<br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameTransformRight = 0; // [0, 1] NOT IN USE!<br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownTransformUp = 0; // [0, 1] NOT IN USE!<br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameTransformUp = 0; // [0, 1] NOT IN USE!<br>&emsp;&emsp;&emsp;&emsp;int mButtonCountTransformUp = 0; // [0, 1] NOT IN USE!<br>&emsp;&emsp;&emsp;&emsp;bool mButtonDownTransformDown = 0; // [0, 1] NOT IN USE!<br>&emsp;&emsp;&emsp;&emsp;int mButtonFrameTransformDown = 0; // [0, 1] NOT IN USE!<br>&emsp;&emsp;&emsp;&emsp;int mButtonCountTransformDown = 0; // [0, 1] NOT IN USE!<br>&emsp;&emsp;&emsp;&emsp;float mFlyingTargetY = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;vec2 mAimingVector;<br>&emsp;&emsp;&emsp;&emsp;vec2 mAimingVectorNormalized; //  Aiming vector normalized to unit sphere.<br>&emsp;&emsp;&emsp;&emsp;vec2 mAimingVectorNonZeroLatest;<br>&emsp;&emsp;&emsp;&emsp;vec2 mGamepadAimingVectorRaw;<br>&emsp;&emsp;&emsp;&emsp;vec2 mJumpVelocity; //  used mostly by AI only?<br>&emsp;&emsp;&emsp;&emsp;vec2 mMousePosition;<br>&emsp;&emsp;&emsp;&emsp;vec2 mMousePositionRaw;<br>&emsp;&emsp;&emsp;&emsp;vec2 mMousePositionRawPrev;<br>&emsp;&emsp;&emsp;&emsp;vec2 mMouseDelta;<br>&emsp;&emsp;&emsp;&emsp;vec2 mGamepadIndirectAiming;<br>&emsp;&emsp;&emsp;&emsp;vec2 mGamePadCursorInWorld; //  where the aiming cursor is in the world, updated by platformshooterplayer_system <br>&emsp;&emsp;&emsp;&emsp;uint32_t mButtonDownDelayLineFire = 0; // [0, 1] Used to delay input for some game effects<br>&emsp;&emsp;&emsp;&emsp;uint32_t mButtonDownDelayLineFire2 = 0; // [0, 1] Used to delay input for some game effects<br>&emsp;&emsp;&emsp;&emsp;uint32_t mButtonDownDelayLineRight = 0; // [0, 1] Used to delay input for some game effects<br>&emsp;&emsp;&emsp;&emsp;uint32_t mButtonDownDelayLineLeft = 0; // [0, 1] Used to delay input for some game effects<br>&emsp;&emsp;&emsp;&emsp;uint32_t mButtonDownDelayLineUp = 0; // [0, 1] Used to delay input for some game effects<br>&emsp;&emsp;&emsp;&emsp;uint32_t mButtonDownDelayLineDown = 0; // [0, 1] Used to delay input for some game effects<br>&emsp;&emsp;&emsp;&emsp;uint32_t mButtonDownDelayLineKick = 0; // [0, 1] Used to delay input for some game effects<br>&emsp;&emsp;&emsp;&emsp;uint32_t mButtonDownDelayLineThrow = 0; // [0, 1] Used to delay input for some game effects<br>&emsp;&emsp;&emsp;&emsp;uint32_t mButtonDownDelayLineJump = 0; // [0, 1] Used to delay input for some game effects<br>&emsp;&emsp;&emsp;&emsp;uint32_t mButtonDownDelayLineFly = 0; // [0, 1] Used to delay input for some game effects<br>&emsp;&emsp;&emsp;&emsp;LensValue<int> input_latency_frames; //  Adds latency to some inputs. Used by some game effects. Max 31.<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="polymorph_hax" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="polymorph_next_attack_frame" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="enabled" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="gamepad_indirect_aiming_enabled" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="gamepad_fire_on_thumbstick_extend" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="gamepad_fire_on_thumbstick_extend_threshold" type="xs:decimal" default="0.7">
				<xs:annotation>
					<xs:documentation>`0.7` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonDownFire" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonFrameFire" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonLastFrameFire" type="xs:int" default="-2">
				<xs:annotation>
					<xs:documentation>`-2` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonDownFire2" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonFrameFire2" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonDownAction" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonFrameAction" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonDownThrow" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonFrameThrow" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonDownInteract" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonFrameInteract" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonDownLeft" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonFrameLeft" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonDownRight" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonFrameRight" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonDownUp" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonFrameUp" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonDownDown" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonFrameDown" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonDownJump" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonFrameJump" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonDownRun" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonFrameRun" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonDownFly" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonFrameFly" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonDownDig" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonFrameDig" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonDownChangeItemR" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonFrameChangeItemR" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonCountChangeItemR" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>note these have special count property</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonDownChangeItemL" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonFrameChangeItemL" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonCountChangeItemL" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>note these have special count property</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonDownInventory" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonFrameInventory" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonDownHolsterItem" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonFrameHolsterItem" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonDownDropItem" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonFrameDropItem" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonDownKick" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonFrameKick" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonDownEat" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonFrameEat" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonDownLeftClick" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>NOTE! Ignores gamepad, if mouse is pressed this will be true.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonFrameLeftClick" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>NOTE! Ignores gamepad, if mouse is pressed this will be true.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonDownRightClick" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>NOTE! Ignores gamepad, if mouse is pressed this will be true.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonFrameRightClick" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>NOTE! Ignores gamepad, if mouse is pressed this will be true.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonDownTransformLeft" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>NOT IN USE!</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonFrameTransformLeft" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>NOT IN USE!</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonDownTransformRight" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>NOT IN USE!</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonFrameTransformRight" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>NOT IN USE!</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonDownTransformUp" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>NOT IN USE!</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonFrameTransformUp" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>NOT IN USE!</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonCountTransformUp" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>NOT IN USE!</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonDownTransformDown" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>NOT IN USE!</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonFrameTransformDown" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>NOT IN USE!</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonCountTransformDown" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>NOT IN USE!</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mFlyingTargetY" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mAimingVector.x" type="xs:decimal" default="0" />
			<xs:attribute name="mAimingVector.y" type="xs:decimal" default="0" />
			<xs:attribute name="mAimingVectorNormalized.x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>Aiming vector normalized to unit sphere.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mAimingVectorNormalized.y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>Aiming vector normalized to unit sphere.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mAimingVectorNonZeroLatest.x" type="xs:decimal" default="0" />
			<xs:attribute name="mAimingVectorNonZeroLatest.y" type="xs:decimal" default="0" />
			<xs:attribute name="mGamepadAimingVectorRaw.x" type="xs:decimal" default="0" />
			<xs:attribute name="mGamepadAimingVectorRaw.y" type="xs:decimal" default="0" />
			<xs:attribute name="mJumpVelocity.x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>used mostly by AI only?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mJumpVelocity.y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>used mostly by AI only?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mMousePosition.x" type="xs:decimal" default="0" />
			<xs:attribute name="mMousePosition.y" type="xs:decimal" default="0" />
			<xs:attribute name="mMousePositionRaw.x" type="xs:decimal" default="0" />
			<xs:attribute name="mMousePositionRaw.y" type="xs:decimal" default="0" />
			<xs:attribute name="mMousePositionRawPrev.x" type="xs:decimal" default="0" />
			<xs:attribute name="mMousePositionRawPrev.y" type="xs:decimal" default="0" />
			<xs:attribute name="mMouseDelta.x" type="xs:decimal" default="0" />
			<xs:attribute name="mMouseDelta.y" type="xs:decimal" default="0" />
			<xs:attribute name="mGamepadIndirectAiming.x" type="xs:decimal" default="0" />
			<xs:attribute name="mGamepadIndirectAiming.y" type="xs:decimal" default="0" />
			<xs:attribute name="mGamePadCursorInWorld.x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>where the aiming cursor is in the world, updated by platformshooterplayer_system </xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mGamePadCursorInWorld.y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>where the aiming cursor is in the world, updated by platformshooterplayer_system </xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonDownDelayLineFire" type="xs:unsignedInt" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>Used to delay input for some game effects</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonDownDelayLineFire2" type="xs:unsignedInt" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>Used to delay input for some game effects</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonDownDelayLineRight" type="xs:unsignedInt" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>Used to delay input for some game effects</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonDownDelayLineLeft" type="xs:unsignedInt" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>Used to delay input for some game effects</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonDownDelayLineUp" type="xs:unsignedInt" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>Used to delay input for some game effects</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonDownDelayLineDown" type="xs:unsignedInt" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>Used to delay input for some game effects</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonDownDelayLineKick" type="xs:unsignedInt" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>Used to delay input for some game effects</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonDownDelayLineThrow" type="xs:unsignedInt" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>Used to delay input for some game effects</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonDownDelayLineJump" type="xs:unsignedInt" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>Used to delay input for some game effects</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mButtonDownDelayLineFly" type="xs:unsignedInt" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>Used to delay input for some game effects</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="input_latency_frames" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>Adds latency to some inputs. Used by some game effects. Max 31.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="CrawlerAnimalComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class CrawlerAnimalComponent {<br>&emsp;&emsp;&emsp;&emsp;float ray_length = 5; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;int ray_count = 16; // [0, 64] <br>&emsp;&emsp;&emsp;&emsp;float gravity = 600; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float terminal_velocity = 600; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float speed = 0.2; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;int give_up_area_radius = 20; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;int give_up_time = 45; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;float attack_from_ceiling_check_ray_length = 128; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;int attack_from_ceiling_check_every_n_frames = 15; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;float collision_damage = 0.25; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;float collision_damage_radius = 10; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;int collision_damage_frames_between = 10; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;bool animate = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mDir = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mFrameNextGiveUp = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mFrameNextDamage = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mFrameNextAttackFromCeilingCheck = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;vec2 mMin;<br>&emsp;&emsp;&emsp;&emsp;vec2 mMax;<br>&emsp;&emsp;&emsp;&emsp;vec2 mPrevNonSnappedPosition;<br>&emsp;&emsp;&emsp;&emsp;ivec2 mPrevCellPosition;<br>&emsp;&emsp;&emsp;&emsp;ivec2 mPrevCellPosition2;<br>&emsp;&emsp;&emsp;&emsp;ivec2 mPrevCellPosition3;<br>&emsp;&emsp;&emsp;&emsp;ivec2 mPrevCellPosition4;<br>&emsp;&emsp;&emsp;&emsp;ivec2 mPrevCellPosition5;<br>&emsp;&emsp;&emsp;&emsp;ivec2 mPrevCellPosition6;<br>&emsp;&emsp;&emsp;&emsp;ivec2 mPrevCellPosition7;<br>&emsp;&emsp;&emsp;&emsp;ivec2 mPrevCellPosition8;<br>&emsp;&emsp;&emsp;&emsp;ivec2 mLatestPosition;<br>&emsp;&emsp;&emsp;&emsp;bool mPrevFalling = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mIsInitialized = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float mVelocityY = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float mAngle = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float mMovementStepAccumulator = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="ray_length" type="xs:decimal" default="5">
				<xs:annotation>
					<xs:documentation>`5` - `[0, 100]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ray_count" type="xs:int" default="16">
				<xs:annotation>
					<xs:documentation>`16` - `[0, 64]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="gravity" type="xs:decimal" default="600">
				<xs:annotation>
					<xs:documentation>`600` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="terminal_velocity" type="xs:decimal" default="600">
				<xs:annotation>
					<xs:documentation>`600` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="speed" type="xs:decimal" default="0.2">
				<xs:annotation>
					<xs:documentation>`0.2` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="give_up_area_radius" type="xs:int" default="20">
				<xs:annotation>
					<xs:documentation>`20` - `[0, 1000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="give_up_time" type="xs:int" default="45">
				<xs:annotation>
					<xs:documentation>`45` - `[0, 1000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_from_ceiling_check_ray_length" type="xs:decimal" default="128">
				<xs:annotation>
					<xs:documentation>`128` - `[0, 1000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attack_from_ceiling_check_every_n_frames" type="xs:int" default="15">
				<xs:annotation>
					<xs:documentation>`15` - `[0, 1000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="collision_damage" type="xs:decimal" default="0.25">
				<xs:annotation>
					<xs:documentation>`0.25` - `[0, 1000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="collision_damage_radius" type="xs:decimal" default="10">
				<xs:annotation>
					<xs:documentation>`10` - `[0, 1000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="collision_damage_frames_between" type="xs:int" default="10">
				<xs:annotation>
					<xs:documentation>`10` - `[0, 1000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="animate" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mDir" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mFrameNextGiveUp" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mFrameNextDamage" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mFrameNextAttackFromCeilingCheck" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mMin.x" type="xs:decimal" default="0" />
			<xs:attribute name="mMin.y" type="xs:decimal" default="0" />
			<xs:attribute name="mMax.x" type="xs:decimal" default="0" />
			<xs:attribute name="mMax.y" type="xs:decimal" default="0" />
			<xs:attribute name="mPrevNonSnappedPosition.x" type="xs:decimal" default="0" />
			<xs:attribute name="mPrevNonSnappedPosition.y" type="xs:decimal" default="0" />
			<xs:attribute name="mPrevCellPosition.x" type="xs:int" default="0" />
			<xs:attribute name="mPrevCellPosition.y" type="xs:int" default="0" />
			<xs:attribute name="mPrevCellPosition2.x" type="xs:int" default="0" />
			<xs:attribute name="mPrevCellPosition2.y" type="xs:int" default="0" />
			<xs:attribute name="mPrevCellPosition3.x" type="xs:int" default="0" />
			<xs:attribute name="mPrevCellPosition3.y" type="xs:int" default="0" />
			<xs:attribute name="mPrevCellPosition4.x" type="xs:int" default="0" />
			<xs:attribute name="mPrevCellPosition4.y" type="xs:int" default="0" />
			<xs:attribute name="mPrevCellPosition5.x" type="xs:int" default="0" />
			<xs:attribute name="mPrevCellPosition5.y" type="xs:int" default="0" />
			<xs:attribute name="mPrevCellPosition6.x" type="xs:int" default="0" />
			<xs:attribute name="mPrevCellPosition6.y" type="xs:int" default="0" />
			<xs:attribute name="mPrevCellPosition7.x" type="xs:int" default="0" />
			<xs:attribute name="mPrevCellPosition7.y" type="xs:int" default="0" />
			<xs:attribute name="mPrevCellPosition8.x" type="xs:int" default="0" />
			<xs:attribute name="mPrevCellPosition8.y" type="xs:int" default="0" />
			<xs:attribute name="mLatestPosition.x" type="xs:int" default="0" />
			<xs:attribute name="mLatestPosition.y" type="xs:int" default="0" />
			<xs:attribute name="mPrevFalling" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mIsInitialized" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mVelocityY" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mAngle" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mMovementStepAccumulator" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="CutThroughWorldDoneHereComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class CutThroughWorldDoneHereComponent {<br>&emsp;&emsp;&emsp;&emsp;uint32 id_of_done_cut = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="id_of_done_cut" type="xs:unsignedInt" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="DamageModelComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class DamageModelComponent {<br>&emsp;&emsp;&emsp;&emsp;double hp = 1; // [0, 4] hit points at the moment<br>&emsp;&emsp;&emsp;&emsp;double max_hp = 0; // [0, 4] the maximum hp that this can have, we'll set this when loading<br>&emsp;&emsp;&emsp;&emsp;double max_hp_cap = 0; // [0, 12] the maximum 'max_hp' that this can have, <= 0 means no limits. Used by perks such as GLASS_CANNON<br>&emsp;&emsp;&emsp;&emsp;double max_hp_old = 0; // [0, 1] used for UI rendering<br>&emsp;&emsp;&emsp;&emsp;float critical_damage_resistance = 0; // [0, 1] 0.0 = all critical damage multiplier is applied. 1.0 = no critical damage multiplier is applied<br>&emsp;&emsp;&emsp;&emsp;int invincibility_frames = 0; // [0, 1024] if positive, doesn't take damage<br>&emsp;&emsp;&emsp;&emsp;bool falling_damages = 1; // [0, 1] do we take fall damage<br>&emsp;&emsp;&emsp;&emsp;float falling_damage_height_min = 70; // [0, 1] how far do we need to fall to take damage, we start with this height, the peasant takes min damage from this<br>&emsp;&emsp;&emsp;&emsp;float falling_damage_height_max = 250; // [0, 1] after this the peasant always takes the maximum fall damage<br>&emsp;&emsp;&emsp;&emsp;float falling_damage_damage_min = 0.1; // [0, 1] when we fall over height_min we take this much, lineary ramping to damage_max<br>&emsp;&emsp;&emsp;&emsp;float falling_damage_damage_max = 1.2; // [0, 1] when we fall over height_min we take this much, lineary ramping to damage_max<br>&emsp;&emsp;&emsp;&emsp;bool air_needed = 1; // [0, 1] Do we breath, can we take damage from not breathing?<br>&emsp;&emsp;&emsp;&emsp;float air_in_lungs = 5; // [0, 1] How much air do we have in our lungs? - after the air runs out we take damage<br>&emsp;&emsp;&emsp;&emsp;float air_in_lungs_max = 5; // [0, 1] how much air can we have in our lungs, it's filled to this point if we're not in water<br>&emsp;&emsp;&emsp;&emsp;float air_lack_of_damage = 0.2; // [0, 1] (* dt)... damage in a second if we're in the water<br>&emsp;&emsp;&emsp;&emsp;float minimum_knockback_force = 0; // [0, 1] Minimum knockback force required to do the knockback<br>&emsp;&emsp;&emsp;&emsp;bool materials_damage = 1; // [0, 1] should materials do damage or not?<br>&emsp;&emsp;&emsp;&emsp;int material_damage_min_cell_count = 4; // [0, 1] if material damage is received from less than 'material_damage_min_cell_count' this frame, it is ignored<br>&emsp;&emsp;&emsp;&emsp;std::string materials_that_damage = "acid"; // [0, 1] list of materials that do damage, separated by ',' e.g. 'acid, fire, smoke'<br>&emsp;&emsp;&emsp;&emsp;std::string materials_how_much_damage = "0.1"; // [0, 1] list of damage amount per material in materials_that_damage, separated by ','<br>&emsp;&emsp;&emsp;&emsp;bool materials_damage_proportional_to_maxhp = 0; // [0, 1] if damage from materials is proportional to max hp, instead of just damage<br>&emsp;&emsp;&emsp;&emsp;bool physics_objects_damage = 0; // [0, 1] if true, will take damage from physics objects that hit it<br>&emsp;&emsp;&emsp;&emsp;bool materials_create_messages = 0; // [0, 1] should collisions with certain materials create messages or not?<br>&emsp;&emsp;&emsp;&emsp;std::string materials_that_create_messages = "meat"; // [0, 1] list of materials that generate CollisionWithCell messages, separated by ',' e.g. 'acid, fire, smoke'<br>&emsp;&emsp;&emsp;&emsp;std::string ragdoll_filenames_file = "data/temp/ragdoll/filenames.txt"; // [0, 1] the file from which to load a ragdoll on death'<br>&emsp;&emsp;&emsp;&emsp;std::string ragdoll_material = "meat"; // [0, 1] what material is the ragdoll made out of<br>&emsp;&emsp;&emsp;&emsp;float ragdoll_offset_x = 0; // [0, 1] where should the ragdoll be created relative to our entity position'<br>&emsp;&emsp;&emsp;&emsp;float ragdoll_offset_y = 0; // [0, 1] where should the ragdoll be created relative to our entity position'<br>&emsp;&emsp;&emsp;&emsp;std::string blood_material = "blood_fading"; // [0, 1] this is the material that gets thrown as particles when this entity takes damage<br>&emsp;&emsp;&emsp;&emsp;std::string blood_spray_material; //  this is the material that gets thrown as particles when this entity sprays blood on death<br>&emsp;&emsp;&emsp;&emsp;bool blood_spray_create_some_cosmetic = 0; // [0, 1] if true, we force some blood spray particles to be cosmetic (can be enabled to avoid making a huge mess of blood spray)<br>&emsp;&emsp;&emsp;&emsp;float blood_multiplier = 1; // [0, 10] how much blood, this is the multiplier used for sprouting lots or little blood<br>&emsp;&emsp;&emsp;&emsp;int ragdoll_blood_amount_absolute = -1; // [-1, 1000] if > -1, this is the absolute amount of blood we share between particle emitters in the ragdoll<br>&emsp;&emsp;&emsp;&emsp;std::string blood_sprite_directional; //  this sprite is loaded at damage position if we take damage that creates a blood effect<br>&emsp;&emsp;&emsp;&emsp;std::string blood_sprite_large; //  this sprite is loaded at damage position if we take explosion/heavy damage<br>&emsp;&emsp;&emsp;&emsp;std::string healing_particle_effect_entity; //  if this is set, will load this entity as a child of this entity, when this entity is healed<br>&emsp;&emsp;&emsp;&emsp;bool create_ragdoll = 1; // [0, 1] if 0, we skip ragdoll creation on death<br>&emsp;&emsp;&emsp;&emsp;bool ragdollify_child_entity_sprites = 0; // [0, 1] if 1, we ragdollify child entity sprites<br>&emsp;&emsp;&emsp;&emsp;float ragdollify_root_angular_damping = 0; // [0, 1] If ragdoll_filenames_file= and > 0, the angular damping of the first ragdoll body is set to this value.<br>&emsp;&emsp;&emsp;&emsp;bool ragdollify_disintegrate_nonroot = 0; // [0, 1] If ragdoll_filenames_file= and true, all but the first sprite on the root entity will be disintegrated instead of being turned into physics bodies.<br>&emsp;&emsp;&emsp;&emsp;bool wait_for_kill_flag_on_death = 0; // [0, 1] if 1, we wont kill the entity along with kill fx and ragdoll until 'kill' is 1<br>&emsp;&emsp;&emsp;&emsp;bool kill_now = 0; // [0, 1] if 1, we wont kill the entity along with kill fx and ragdoll until 'kill_now' is 1<br>&emsp;&emsp;&emsp;&emsp;bool drop_items_on_death = 1; // [0, 1] drop the abilities as items on death?<br>&emsp;&emsp;&emsp;&emsp;bool ui_report_damage = 1; // [0, 1] If 1, damage numbers are displayed when this entity is damaged<br>&emsp;&emsp;&emsp;&emsp;bool ui_force_report_damage = 0; // [0, 1] If 1, damage numbers are displayed when this entity is damaged, even if the numbers are disabled in settings<br>&emsp;&emsp;&emsp;&emsp;int in_liquid_shooting_electrify_prob = 0; // [0, 100] when shooting underwater how likely are we to electrify the water<br>&emsp;&emsp;&emsp;&emsp;float wet_status_effect_damage = 0; // [0, 0.1] how much damage per 10 frames is done if entity has 'wet' status effect<br>&emsp;&emsp;&emsp;&emsp;bool is_on_fire = 0; // [0, 1] Tells us we're on fire or not<br>&emsp;&emsp;&emsp;&emsp;float fire_probability_of_ignition = 0.5; // [0, 1] what is the probability that we'll ignite, 0 means won't ever ignite<br>&emsp;&emsp;&emsp;&emsp;int fire_how_much_fire_generates = 4; // [0, 10] how many fire particles do we generate each frame<br>&emsp;&emsp;&emsp;&emsp;float fire_damage_ignited_amount = 0.0003; // [0, 2] how much damage does being ignited do?<br>&emsp;&emsp;&emsp;&emsp;float fire_damage_amount = 0.2; // [0, 2] how much damage does fire do?, 0.2 is pretty good<br>&emsp;&emsp;&emsp;&emsp;int mLastElectricityResistanceFrame = -2147483648; // [0, 1] Last frame electricity has no effect. Should not be private!<br>&emsp;&emsp;&emsp;&emsp;int mLastFrameReportedBlock = -2147483648; // [0, 1] Last frame a damage block message was displayed for this entity<br>&emsp;&emsp;&emsp;&emsp;int mLastMaxHpChangeFrame = -10000; // [0, 1] used for UI rendering<br>&emsp;&emsp;&emsp;&emsp;ConfigDamagesByType damage_multipliers; //  the multipliers applied to different types of damage<br>&emsp;&emsp;&emsp;&emsp;RAGDOLL_FX::Enum ragdoll_fx_forced; //  if set, will force this ragdoll fx to happen everytime<br>&emsp;&emsp;&emsp;&emsp;bool mIsOnFire = 0; // [0, 1] private variable to check when we're on fire and not<br>&emsp;&emsp;&emsp;&emsp;int mFireProbability = 100; // [0, 1] this gets decreased if we can't ignite anything else<br>&emsp;&emsp;&emsp;&emsp;int mFireFramesLeft = 0; // [0, 1] this is the remaining frames we're on fire<br>&emsp;&emsp;&emsp;&emsp;int mFireDurationFrames = 0; // [0, 1] this is the total duration in frames we're on fire<br>&emsp;&emsp;&emsp;&emsp;bool mFireTriedIgniting = 0; // [0, 1] private variable to check when we could have been ignited or not<br>&emsp;&emsp;&emsp;&emsp;int mLastCheckX = 0; // [0, 1] an optimization, so we don't have to check everything every frame<br>&emsp;&emsp;&emsp;&emsp;int mLastCheckY = 0; // [0, 1] an optimization, so we don't have to check everything every frame<br>&emsp;&emsp;&emsp;&emsp;int mLastCheckTime = 0; // [0, 1] an optimization, so we don't have to check everything every frame<br>&emsp;&emsp;&emsp;&emsp;int mLastMaterialDamageFrame = 0; // [0, 1] this is the last frame we took material damage<br>&emsp;&emsp;&emsp;&emsp;bool mFallIsOnGround = 0; // [0, 1] for fall damage, keeps a private variable about if we're on ground or not<br>&emsp;&emsp;&emsp;&emsp;float mFallHighestY = 340282000000000014192072600942972764160; // [0, 1] private var to keep track of how high have we flown to<br>&emsp;&emsp;&emsp;&emsp;int mFallCount = 0; // [0, 1] how many times have we fallen? This is used to make sure we don't take damage from the first fall<br>&emsp;&emsp;&emsp;&emsp;bool mAirAreWeInWater = 0; // [0, 1] a private variable to track our state in drowning<br>&emsp;&emsp;&emsp;&emsp;int mAirFramesNotInWater = 0; // [0, 1] how many frames have been with air to breathe<br>&emsp;&emsp;&emsp;&emsp;bool mAirDoWeHave = 0; // [0, 1] a private variable to track our state in drowning<br>&emsp;&emsp;&emsp;&emsp;int mTotalCells = 0; // [0, 1] how many cells are there total<br>&emsp;&emsp;&emsp;&emsp;int mLiquidCount = 0; // [0, 1] how many of the cells are liquid<br>&emsp;&emsp;&emsp;&emsp;int mLiquidMaterialWeAreIn = -1; // [0, 1] stores the liquid material we're in... may not be the most accurate<br>&emsp;&emsp;&emsp;&emsp;std::vector< int > mDamageMaterials; //  NOTE! Sorted! a list of materials that do damage (materials_that_damage)<br>&emsp;&emsp;&emsp;&emsp;std::vector< float > mDamageMaterialsHowMuch; //  NOTE! Sorted! a list of materials that do damage (materials_that_damage)<br>&emsp;&emsp;&emsp;&emsp;std::vector< int > mCollisionMessageMaterials; //  NOTE! Sorted! a list of materials that create messages (materials_that_create_messages)<br>&emsp;&emsp;&emsp;&emsp;std::vector< int > mCollisionMessageMaterialCountsThisFrame; //  Number of cells per collided with this frame. Order matches mCollisionMessageMaterials<br>&emsp;&emsp;&emsp;&emsp;std::vector< float > mMaterialDamageThisFrame; //  A list of damage per material that damages us. In same order as materials<br>&emsp;&emsp;&emsp;&emsp;float mFallDamageThisFrame = 0; // [0, 1] Amount of fall damage received this frame<br>&emsp;&emsp;&emsp;&emsp;float mElectricityDamageThisFrame = 0; // [0, 1] Amount of electricity damage received this frame<br>&emsp;&emsp;&emsp;&emsp;float mPhysicsDamageThisFrame = 0; // [0, 1] max physics damage we have taken this round<br>&emsp;&emsp;&emsp;&emsp;vec2 mPhysicsDamageVecThisFrame; //  direction of physics damage<br>&emsp;&emsp;&emsp;&emsp;int mPhysicsDamageLastFrame = 0; // [0, 1] frame number when we took physics damage<br>&emsp;&emsp;&emsp;&emsp;EntityTypeID mPhysicsDamageEntity = 0; // [0, 1] the physics entity that hit us<br>&emsp;&emsp;&emsp;&emsp;EntityTypeID mPhysicsDamageTelekinesisCasterEntity = 0; // [0, 1] who moved an object that hit us via telekinesis<br>&emsp;&emsp;&emsp;&emsp;int mLastDamageFrame = -120; // [0, 1] frame number when we took any damage<br>&emsp;&emsp;&emsp;&emsp;double mHpBeforeLastDamage = 0; // [0, 1] how much hp did we have a while ago?<br>&emsp;&emsp;&emsp;&emsp;float mFireDamageBuffered = 0; // [0, 1] used to optimized cases where lots of entities are taking fire damage<br>&emsp;&emsp;&emsp;&emsp;int32 mFireDamageBufferedNextDeliveryFrame = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="hp" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 4]`</xs:documentation>
					<xs:documentation>hit points at the moment</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="max_hp" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 4]`</xs:documentation>
					<xs:documentation>the maximum hp that this can have, we'll set this when loading</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="max_hp_cap" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 12]`</xs:documentation>
					<xs:documentation>the maximum 'max_hp' that this can have, &lt;= 0 means no limits. Used by perks such as GLASS_CANNON</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="max_hp_old" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>used for UI rendering</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="critical_damage_resistance" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>0.0 = all critical damage multiplier is applied. 1.0 = no critical damage multiplier is applied</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="invincibility_frames" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1024]`</xs:documentation>
					<xs:documentation>if positive, doesn't take damage</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="falling_damages" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>do we take fall damage</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="falling_damage_height_min" type="xs:decimal" default="70">
				<xs:annotation>
					<xs:documentation>`70` - `[0, 1]`</xs:documentation>
					<xs:documentation>how far do we need to fall to take damage, we start with this height, the peasant takes min damage from this</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="falling_damage_height_max" type="xs:decimal" default="250">
				<xs:annotation>
					<xs:documentation>`250` - `[0, 1]`</xs:documentation>
					<xs:documentation>after this the peasant always takes the maximum fall damage</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="falling_damage_damage_min" type="xs:decimal" default="0.1">
				<xs:annotation>
					<xs:documentation>`0.1` - `[0, 1]`</xs:documentation>
					<xs:documentation>when we fall over height_min we take this much, lineary ramping to damage_max</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="falling_damage_damage_max" type="xs:decimal" default="1.2">
				<xs:annotation>
					<xs:documentation>`1.2` - `[0, 1]`</xs:documentation>
					<xs:documentation>when we fall over height_min we take this much, lineary ramping to damage_max</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="air_needed" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>Do we breath, can we take damage from not breathing?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="air_in_lungs" type="xs:decimal" default="5">
				<xs:annotation>
					<xs:documentation>`5` - `[0, 1]`</xs:documentation>
					<xs:documentation>How much air do we have in our lungs? - after the air runs out we take damage</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="air_in_lungs_max" type="xs:decimal" default="5">
				<xs:annotation>
					<xs:documentation>`5` - `[0, 1]`</xs:documentation>
					<xs:documentation>how much air can we have in our lungs, it's filled to this point if we're not in water</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="air_lack_of_damage" type="xs:decimal" default="0.2">
				<xs:annotation>
					<xs:documentation>`0.2` - `[0, 1]`</xs:documentation>
					<xs:documentation>(* dt)... damage in a second if we're in the water</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="minimum_knockback_force" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>Minimum knockback force required to do the knockback</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="materials_damage" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>should materials do damage or not?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="material_damage_min_cell_count" type="xs:int" default="4">
				<xs:annotation>
					<xs:documentation>`4` - `[0, 1]`</xs:documentation>
					<xs:documentation>if material damage is received from less than 'material_damage_min_cell_count' this frame, it is ignored</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="materials_that_damage" type="xs:string" default="acid">
				<xs:annotation>
					<xs:documentation>`acid` - `[0, 1]`</xs:documentation>
					<xs:documentation>list of materials that do damage, separated by ',' e.g. 'acid, fire, smoke'</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="materials_how_much_damage" type="xs:string" default="0.1">
				<xs:annotation>
					<xs:documentation>`0.1` - `[0, 1]`</xs:documentation>
					<xs:documentation>list of damage amount per material in materials_that_damage, separated by ','</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="materials_damage_proportional_to_maxhp" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if damage from materials is proportional to max hp, instead of just damage</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="physics_objects_damage" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, will take damage from physics objects that hit it</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="materials_create_messages" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>should collisions with certain materials create messages or not?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="materials_that_create_messages" type="xs:string" default="meat">
				<xs:annotation>
					<xs:documentation>`meat` - `[0, 1]`</xs:documentation>
					<xs:documentation>list of materials that generate CollisionWithCell messages, separated by ',' e.g. 'acid, fire, smoke'</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ragdoll_filenames_file" type="xs:string" default="data/temp/ragdoll/filenames.txt">
				<xs:annotation>
					<xs:documentation>`data/temp/ragdoll/filenames.txt` - `[0, 1]`</xs:documentation>
					<xs:documentation>the file from which to load a ragdoll on death'</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ragdoll_material" type="xs:string" default="meat">
				<xs:annotation>
					<xs:documentation>`meat` - `[0, 1]`</xs:documentation>
					<xs:documentation>what material is the ragdoll made out of</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ragdoll_offset_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>where should the ragdoll be created relative to our entity position'</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ragdoll_offset_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>where should the ragdoll be created relative to our entity position'</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="blood_material" type="xs:string" default="blood_fading">
				<xs:annotation>
					<xs:documentation>`blood_fading` - `[0, 1]`</xs:documentation>
					<xs:documentation>this is the material that gets thrown as particles when this entity takes damage</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="blood_spray_material" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>this is the material that gets thrown as particles when this entity sprays blood on death</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="blood_spray_create_some_cosmetic" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, we force some blood spray particles to be cosmetic (can be enabled to avoid making a huge mess of blood spray)</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="blood_multiplier" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 10]`</xs:documentation>
					<xs:documentation>how much blood, this is the multiplier used for sprouting lots or little blood</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ragdoll_blood_amount_absolute" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[-1, 1000]`</xs:documentation>
					<xs:documentation>if &gt; -1, this is the absolute amount of blood we share between particle emitters in the ragdoll</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="blood_sprite_directional" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>this sprite is loaded at damage position if we take damage that creates a blood effect</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="blood_sprite_large" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>this sprite is loaded at damage position if we take explosion/heavy damage</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="healing_particle_effect_entity" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>if this is set, will load this entity as a child of this entity, when this entity is healed</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="create_ragdoll" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 0, we skip ragdoll creation on death</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ragdollify_child_entity_sprites" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, we ragdollify child entity sprites</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ragdollify_root_angular_damping" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>If ragdoll_filenames_file= and &gt; 0, the angular damping of the first ragdoll body is set to this value.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ragdollify_disintegrate_nonroot" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>If ragdoll_filenames_file= and true, all but the first sprite on the root entity will be disintegrated instead of being turned into physics bodies.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="wait_for_kill_flag_on_death" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, we wont kill the entity along with kill fx and ragdoll until 'kill' is 1</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="kill_now" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, we wont kill the entity along with kill fx and ragdoll until 'kill_now' is 1</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="drop_items_on_death" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>drop the abilities as items on death?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ui_report_damage" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>If 1, damage numbers are displayed when this entity is damaged</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ui_force_report_damage" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>If 1, damage numbers are displayed when this entity is damaged, even if the numbers are disabled in settings</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="in_liquid_shooting_electrify_prob" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 100]`</xs:documentation>
					<xs:documentation>when shooting underwater how likely are we to electrify the water</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="wet_status_effect_damage" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 0.1]`</xs:documentation>
					<xs:documentation>how much damage per 10 frames is done if entity has 'wet' status effect</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_on_fire" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>Tells us we're on fire or not</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="fire_probability_of_ignition" type="xs:decimal" default="0.5">
				<xs:annotation>
					<xs:documentation>`0.5` - `[0, 1]`</xs:documentation>
					<xs:documentation>what is the probability that we'll ignite, 0 means won't ever ignite</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="fire_how_much_fire_generates" type="xs:int" default="4">
				<xs:annotation>
					<xs:documentation>`4` - `[0, 10]`</xs:documentation>
					<xs:documentation>how many fire particles do we generate each frame</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="fire_damage_ignited_amount" type="xs:decimal" default="0.0003">
				<xs:annotation>
					<xs:documentation>`0.0003` - `[0, 2]`</xs:documentation>
					<xs:documentation>how much damage does being ignited do?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="fire_damage_amount" type="xs:decimal" default="0.2">
				<xs:annotation>
					<xs:documentation>`0.2` - `[0, 2]`</xs:documentation>
					<xs:documentation>how much damage does fire do?, 0.2 is pretty good</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mLastElectricityResistanceFrame" type="xs:int" default="-2147483648">
				<xs:annotation>
					<xs:documentation>`-2147483648` - `[0, 1]`</xs:documentation>
					<xs:documentation>Last frame electricity has no effect. Should not be private!</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mLastFrameReportedBlock" type="xs:int" default="-2147483648">
				<xs:annotation>
					<xs:documentation>`-2147483648` - `[0, 1]`</xs:documentation>
					<xs:documentation>Last frame a damage block message was displayed for this entity</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mLastMaxHpChangeFrame" type="xs:int" default="-10000">
				<xs:annotation>
					<xs:documentation>`-10000` - `[0, 1]`</xs:documentation>
					<xs:documentation>used for UI rendering</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: ConfigDamagesByType for damage_multipliers -->
				<!-- Some Unknown Type: RAGDOLL_FX::Enum for ragdoll_fx_forced -->
			<xs:attribute name="mIsOnFire" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>private variable to check when we're on fire and not</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mFireProbability" type="xs:int" default="100">
				<xs:annotation>
					<xs:documentation>`100` - `[0, 1]`</xs:documentation>
					<xs:documentation>this gets decreased if we can't ignite anything else</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mFireFramesLeft" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>this is the remaining frames we're on fire</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mFireDurationFrames" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>this is the total duration in frames we're on fire</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mFireTriedIgniting" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>private variable to check when we could have been ignited or not</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mLastCheckX" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>an optimization, so we don't have to check everything every frame</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mLastCheckY" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>an optimization, so we don't have to check everything every frame</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mLastCheckTime" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>an optimization, so we don't have to check everything every frame</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mLastMaterialDamageFrame" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>this is the last frame we took material damage</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mFallIsOnGround" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>for fall damage, keeps a private variable about if we're on ground or not</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mFallHighestY" type="xs:decimal" default="340282000000000014192072600942972764160">
				<xs:annotation>
					<xs:documentation>`3.40282e+038` - `[0, 1]`</xs:documentation>
					<xs:documentation>private var to keep track of how high have we flown to</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mFallCount" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>how many times have we fallen? This is used to make sure we don't take damage from the first fall</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mAirAreWeInWater" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>a private variable to track our state in drowning</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mAirFramesNotInWater" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>how many frames have been with air to breathe</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mAirDoWeHave" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>a private variable to track our state in drowning</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mTotalCells" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>how many cells are there total</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mLiquidCount" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>how many of the cells are liquid</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mLiquidMaterialWeAreIn" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
					<xs:documentation>stores the liquid material we're in... may not be the most accurate</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: std::vector< int > for mDamageMaterials -->
				<!-- Some Unknown Type: std::vector< float > for mDamageMaterialsHowMuch -->
				<!-- Some Unknown Type: std::vector< int > for mCollisionMessageMaterials -->
				<!-- Some Unknown Type: std::vector< int > for mCollisionMessageMaterialCountsThisFrame -->
				<!-- Some Unknown Type: std::vector< float > for mMaterialDamageThisFrame -->
			<xs:attribute name="mFallDamageThisFrame" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>Amount of fall damage received this frame</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mElectricityDamageThisFrame" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>Amount of electricity damage received this frame</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mPhysicsDamageThisFrame" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>max physics damage we have taken this round</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mPhysicsDamageVecThisFrame.x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>direction of physics damage</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mPhysicsDamageVecThisFrame.y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>direction of physics damage</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mPhysicsDamageLastFrame" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>frame number when we took physics damage</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: EntityTypeID for mPhysicsDamageEntity -->
				<!-- Some Unknown Type: EntityTypeID for mPhysicsDamageTelekinesisCasterEntity -->
			<xs:attribute name="mLastDamageFrame" type="xs:int" default="-120">
				<xs:annotation>
					<xs:documentation>`-120` - `[0, 1]`</xs:documentation>
					<xs:documentation>frame number when we took any damage</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mHpBeforeLastDamage" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>how much hp did we have a while ago?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mFireDamageBuffered" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>used to optimized cases where lots of entities are taking fire damage</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mFireDamageBufferedNextDeliveryFrame" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="DamageNearbyEntitiesComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class DamageNearbyEntitiesComponent {<br>&emsp;&emsp;&emsp;&emsp;float radius = 10; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float damage_min = 0.1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float damage_max = 0.2; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float target_vec_max_len = 5; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float knockback_multiplier = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int time_between_damaging = 20; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;std::string damage_description = "bite"; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;std::string target_tag = "mortal"; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;DAMAGE_TYPES::Enum damage_type; //  the damage type<br>&emsp;&emsp;&emsp;&emsp;RAGDOLL_FX::Enum ragdoll_fx;<br>&emsp;&emsp;&emsp;&emsp;vec2 mVelocity;<br>&emsp;&emsp;&emsp;&emsp;int mNextDamageFrame = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="radius" type="xs:decimal" default="10">
				<xs:annotation>
					<xs:documentation>`10` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="damage_min" type="xs:decimal" default="0.1">
				<xs:annotation>
					<xs:documentation>`0.1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="damage_max" type="xs:decimal" default="0.2">
				<xs:annotation>
					<xs:documentation>`0.2` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="target_vec_max_len" type="xs:decimal" default="5">
				<xs:annotation>
					<xs:documentation>`5` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="knockback_multiplier" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="time_between_damaging" type="xs:int" default="20">
				<xs:annotation>
					<xs:documentation>`20` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="damage_description" type="xs:string" default="bite">
				<xs:annotation>
					<xs:documentation>`bite` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="target_tag" type="xs:string" default="mortal">
				<xs:annotation>
					<xs:documentation>`mortal` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: DAMAGE_TYPES::Enum for damage_type -->
				<!-- Some Unknown Type: RAGDOLL_FX::Enum for ragdoll_fx -->
			<xs:attribute name="mVelocity.x" type="xs:decimal" default="0" />
			<xs:attribute name="mVelocity.y" type="xs:decimal" default="0" />
			<xs:attribute name="mNextDamageFrame" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="DebugFollowMouseComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class DebugFollowMouseComponent {<br><br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">

			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="DebugLogMessagesComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class DebugLogMessagesComponent {<br>&emsp;&emsp;&emsp;&emsp;float TEMP_TEMPY = 0; // [0, 3.5] <br>&emsp;&emsp;&emsp;&emsp;float TEMP_TEMP_TEMP = 0; // [0, 3.5] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="TEMP_TEMPY" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 3.5]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="TEMP_TEMP_TEMP" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 3.5]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="DebugSpatialVisualizerComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class DebugSpatialVisualizerComponent {<br>&emsp;&emsp;&emsp;&emsp;float min_x = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float min_y = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float max_x = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float max_y = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;unsigned int color = 4294967295; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="min_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="min_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="max_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="max_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="color" type="xs:unsignedInt" default="4294967295">
				<xs:annotation>
					<xs:documentation>`4294967295` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="DieIfSpeedBelowComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class DieIfSpeedBelowComponent {<br>&emsp;&emsp;&emsp;&emsp;float min_speed = 1; // [0, 1000] The entity that owns this component is killed if its speed (via VelocityComponent) falls below this value.<br>&emsp;&emsp;&emsp;&emsp;float mMinSpeedSquared = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="min_speed" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1000]`</xs:documentation>
					<xs:documentation>The entity that owns this component is killed if its speed (via VelocityComponent) falls below this value.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mMinSpeedSquared" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="DroneLauncherComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class DroneLauncherComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string drone_entity_file = "data/entities/misc/player_drone.xml"; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="drone_entity_file" type="xs:string" default="data/entities/misc/player_drone.xml">
				<xs:annotation>
					<xs:documentation>`data/entities/misc/player_drone.xml` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="DrugEffectComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class DrugEffectComponent {<br>&emsp;&emsp;&emsp;&emsp;ConfigDrugFx drug_fx_target;<br>&emsp;&emsp;&emsp;&emsp;ConfigDrugFx m_drug_fx_current;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
				<!-- Some Unknown Type: ConfigDrugFx for drug_fx_target -->
				<!-- Some Unknown Type: ConfigDrugFx for m_drug_fx_current -->
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="DrugEffectModifierComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class DrugEffectModifierComponent {<br>&emsp;&emsp;&emsp;&emsp;ConfigDrugFx fx_add;<br>&emsp;&emsp;&emsp;&emsp;ConfigDrugFx fx_multiply;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
				<!-- Some Unknown Type: ConfigDrugFx for fx_add -->
				<!-- Some Unknown Type: ConfigDrugFx for fx_multiply -->
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="ElectricChargeComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ElectricChargeComponent {<br>&emsp;&emsp;&emsp;&emsp;int charge_time_frames = 120; // [0, 240] <br>&emsp;&emsp;&emsp;&emsp;float fx_velocity_max = 120; // [0, 240] <br>&emsp;&emsp;&emsp;&emsp;int electricity_emission_interval_frames = 5; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;int fx_emission_interval_min = 2; // [0, 20] <br>&emsp;&emsp;&emsp;&emsp;int fx_emission_interval_max = 15; // [0, 30] <br>&emsp;&emsp;&emsp;&emsp;int charge = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="charge_time_frames" type="xs:int" default="120">
				<xs:annotation>
					<xs:documentation>`120` - `[0, 240]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="fx_velocity_max" type="xs:decimal" default="120">
				<xs:annotation>
					<xs:documentation>`120` - `[0, 240]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="electricity_emission_interval_frames" type="xs:int" default="5">
				<xs:annotation>
					<xs:documentation>`5` - `[0, 10]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="fx_emission_interval_min" type="xs:int" default="2">
				<xs:annotation>
					<xs:documentation>`2` - `[0, 20]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="fx_emission_interval_max" type="xs:int" default="15">
				<xs:annotation>
					<xs:documentation>`15` - `[0, 30]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="charge" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="ElectricityComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ElectricityComponent {<br>&emsp;&emsp;&emsp;&emsp;int energy = 1000; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float probability_to_heat = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int speed = 32; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;int splittings_min = 0; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;int splittings_max = 0; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;int splitting_energy_min = 0; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;int splitting_energy_max = 0; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;bool hack_is_material_crack = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool hack_crack_ice = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool hack_is_set_fire = 0; // [0, 1] if set will set the thing on fire where this is located at<br>&emsp;&emsp;&emsp;&emsp;int mSplittingsLeft = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mSplittingEnergy = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;vec2 mAvgDir;<br>&emsp;&emsp;&emsp;&emsp;ivec2 mPrevPos;<br>&emsp;&emsp;&emsp;&emsp;int mPrevMaterial = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mShouldPlaySound = 1; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="energy" type="xs:int" default="1000">
				<xs:annotation>
					<xs:documentation>`1000` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="probability_to_heat" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="speed" type="xs:int" default="32">
				<xs:annotation>
					<xs:documentation>`32` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="splittings_min" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="splittings_max" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="splitting_energy_min" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="splitting_energy_max" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="hack_is_material_crack" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="hack_crack_ice" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="hack_is_set_fire" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if set will set the thing on fire where this is located at</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mSplittingsLeft" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mSplittingEnergy" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mAvgDir.x" type="xs:decimal" default="0" />
			<xs:attribute name="mAvgDir.y" type="xs:decimal" default="0" />
			<xs:attribute name="mPrevPos.x" type="xs:int" default="0" />
			<xs:attribute name="mPrevPos.y" type="xs:int" default="0" />
			<xs:attribute name="mPrevMaterial" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mShouldPlaySound" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="ElectricityReceiverComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ElectricityReceiverComponent {<br>&emsp;&emsp;&emsp;&emsp;int offset_x = 0; // [1, 3] <br>&emsp;&emsp;&emsp;&emsp;int offset_y = 0; // [1, 3] <br>&emsp;&emsp;&emsp;&emsp;int radius = 1; // [1, 3] <br>&emsp;&emsp;&emsp;&emsp;int active_time_frames = 1; // [1, 15] <br>&emsp;&emsp;&emsp;&emsp;int switch_on_msg_interval_frames = 0; // [0, 60] <br>&emsp;&emsp;&emsp;&emsp;int electrified_msg_interval_frames = -1; // [0, 15] <br>&emsp;&emsp;&emsp;&emsp;int mLastFrameElectrified = -1000; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mNextElectrifiedMsgFrame = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mNextSwitchOnMsgFrame = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="offset_x" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[1, 3]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="offset_y" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[1, 3]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="radius" type="xs:int" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[1, 3]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="active_time_frames" type="xs:int" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[1, 15]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="switch_on_msg_interval_frames" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 60]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="electrified_msg_interval_frames" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 15]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mLastFrameElectrified" type="xs:int" default="-1000">
				<xs:annotation>
					<xs:documentation>`-1000` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mNextElectrifiedMsgFrame" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mNextSwitchOnMsgFrame" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="ElectricitySourceComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ElectricitySourceComponent {<br>&emsp;&emsp;&emsp;&emsp;int radius = 5; // [1, 16] <br>&emsp;&emsp;&emsp;&emsp;int emission_interval_frames = 15; // [1, 10] <br>&emsp;&emsp;&emsp;&emsp;int mNextFrameEmitElectricity = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="radius" type="xs:int" default="5">
				<xs:annotation>
					<xs:documentation>`5` - `[1, 16]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="emission_interval_frames" type="xs:int" default="15">
				<xs:annotation>
					<xs:documentation>`15` - `[1, 10]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mNextFrameEmitElectricity" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="EndingMcGuffinComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class EndingMcGuffinComponent {<br>&emsp;&emsp;&emsp;&emsp;float TEMP_TEMPY = 0; // [0, 3.5] <br>&emsp;&emsp;&emsp;&emsp;float TEMP_TEMP_TEMP = 0; // [0, 3.5] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="TEMP_TEMPY" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 3.5]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="TEMP_TEMP_TEMP" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 3.5]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="EnergyShieldComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class EnergyShieldComponent {<br>&emsp;&emsp;&emsp;&emsp;float radius = 16; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;float damage_multiplier = 1.5; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;float max_energy = 1; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;float energy_required_to_shield = 0.2; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;float recharge_speed = 1; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;float sector_degrees = 360; // [0, 360] if less than 180 we only provide partial cover to the current direction of the entity<br>&emsp;&emsp;&emsp;&emsp;float energy = 0; // [0, 3] <br>&emsp;&emsp;&emsp;&emsp;vec2 mPrevPosition;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="radius" type="xs:decimal" default="16">
				<xs:annotation>
					<xs:documentation>`16` - `[0, 100]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="damage_multiplier" type="xs:decimal" default="1.5">
				<xs:annotation>
					<xs:documentation>`1.5` - `[0, 10]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="max_energy" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 10]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="energy_required_to_shield" type="xs:decimal" default="0.2">
				<xs:annotation>
					<xs:documentation>`0.2` - `[0, 10]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="recharge_speed" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 10]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="sector_degrees" type="xs:decimal" default="360">
				<xs:annotation>
					<xs:documentation>`360` - `[0, 360]`</xs:documentation>
					<xs:documentation>if less than 180 we only provide partial cover to the current direction of the entity</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="energy" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 3]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mPrevPosition.x" type="xs:decimal" default="0" />
			<xs:attribute name="mPrevPosition.y" type="xs:decimal" default="0" />
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="ExplodeOnDamageComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ExplodeOnDamageComponent {<br>&emsp;&emsp;&emsp;&emsp;float explode_on_death_percent = 1; // [0, 1] rolls a dice (0 - 1) if we explode on death<br>&emsp;&emsp;&emsp;&emsp;float explode_on_damage_percent = 1; // [0, 1] rolls a dice (0 - 1) if we explode on damage<br>&emsp;&emsp;&emsp;&emsp;float physics_body_modified_death_probability = 0; // [0, 1] if we get message about the physics body being modified, do we explode on what percent<br>&emsp;&emsp;&emsp;&emsp;float physics_body_destruction_required = 0.5; // [0, 1] how big of percent of our body, do we need to lose before we explode<br>&emsp;&emsp;&emsp;&emsp;ConfigExplosion config_explosion; //  if we have explosion, it's the setup for it<br>&emsp;&emsp;&emsp;&emsp;bool mDone = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="explode_on_death_percent" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>rolls a dice (0 - 1) if we explode on death</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="explode_on_damage_percent" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>rolls a dice (0 - 1) if we explode on damage</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="physics_body_modified_death_probability" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if we get message about the physics body being modified, do we explode on what percent</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="physics_body_destruction_required" type="xs:decimal" default="0.5">
				<xs:annotation>
					<xs:documentation>`0.5` - `[0, 1]`</xs:documentation>
					<xs:documentation>how big of percent of our body, do we need to lose before we explode</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: ConfigExplosion for config_explosion -->
			<xs:attribute name="mDone" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="ExplosionComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ExplosionComponent {<br>&emsp;&emsp;&emsp;&emsp;int timeout_frames = 0; // [0, 180] for timer<br>&emsp;&emsp;&emsp;&emsp;int timeout_frames_random = 0; // [0, 180] a random value between 0 and 'timout_frames_random' is added to timer<br>&emsp;&emsp;&emsp;&emsp;bool kill_entity = 1; // [0, 1] if 1, we kill the entity when exploding<br>&emsp;&emsp;&emsp;&emsp;int mTimerTriggerFrame = -1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;ConfigExplosion config_explosion; //  setup for out explosion<br>&emsp;&emsp;&emsp;&emsp;EXPLOSION_TRIGGER_TYPE::Enum trigger; //  what triggers the explosion<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="timeout_frames" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 180]`</xs:documentation>
					<xs:documentation>for timer</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="timeout_frames_random" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 180]`</xs:documentation>
					<xs:documentation>a random value between 0 and 'timout_frames_random' is added to timer</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="kill_entity" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, we kill the entity when exploding</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mTimerTriggerFrame" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: ConfigExplosion for config_explosion -->
				<!-- Some Unknown Type: EXPLOSION_TRIGGER_TYPE::Enum for trigger -->
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="FishAIComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class FishAIComponent {<br>&emsp;&emsp;&emsp;&emsp;int direction = 0; // [-1, 1] <br>&emsp;&emsp;&emsp;&emsp;float speed = 100; // [1, 1000] <br>&emsp;&emsp;&emsp;&emsp;vec2 aabb_min;<br>&emsp;&emsp;&emsp;&emsp;vec2 aabb_max;<br>&emsp;&emsp;&emsp;&emsp;vec2 velocity;<br>&emsp;&emsp;&emsp;&emsp;int stuck_counter = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;vec2 mLastCheckPos;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="direction" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-1, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="speed" type="xs:decimal" default="100">
				<xs:annotation>
					<xs:documentation>`100` - `[1, 1000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="aabb_min.x" type="xs:decimal" default="0" />
			<xs:attribute name="aabb_min.y" type="xs:decimal" default="0" />
			<xs:attribute name="aabb_max.x" type="xs:decimal" default="0" />
			<xs:attribute name="aabb_max.y" type="xs:decimal" default="0" />
			<xs:attribute name="velocity.x" type="xs:decimal" default="0" />
			<xs:attribute name="velocity.y" type="xs:decimal" default="0" />
			<xs:attribute name="stuck_counter" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mLastCheckPos.x" type="xs:decimal" default="0" />
			<xs:attribute name="mLastCheckPos.y" type="xs:decimal" default="0" />
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="FlyingComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class FlyingComponent {<br>&emsp;&emsp;&emsp;&emsp;int type = 0; // [0, 1] type of flight, 1 = perlin noise<br>&emsp;&emsp;&emsp;&emsp;float perlin_freq = 0.2; // [0, 1] frequency of the perlin noise sampling<br>&emsp;&emsp;&emsp;&emsp;float perlin_time_freq = 0.3; // [0, 1] t *= perlin_time_freq<br>&emsp;&emsp;&emsp;&emsp;float perlin_wind_x = 0; // [-1, 1] wind velocity that gets added to the samples<br>&emsp;&emsp;&emsp;&emsp;float perlin_wind_y = 0; // [-1, 1] wind velocity that gets added to the samples<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="type" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>type of flight, 1 = perlin noise</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="perlin_freq" type="xs:decimal" default="0.2">
				<xs:annotation>
					<xs:documentation>`0.2` - `[0, 1]`</xs:documentation>
					<xs:documentation>frequency of the perlin noise sampling</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="perlin_time_freq" type="xs:decimal" default="0.3">
				<xs:annotation>
					<xs:documentation>`0.3` - `[0, 1]`</xs:documentation>
					<xs:documentation>t *= perlin_time_freq</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="perlin_wind_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-1, 1]`</xs:documentation>
					<xs:documentation>wind velocity that gets added to the samples</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="perlin_wind_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-1, 1]`</xs:documentation>
					<xs:documentation>wind velocity that gets added to the samples</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="FogOfWarRadiusComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class FogOfWarRadiusComponent {<br>&emsp;&emsp;&emsp;&emsp;float radius = 256; // [0, 1024] 256 is the default player has<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="radius" type="xs:decimal" default="256">
				<xs:annotation>
					<xs:documentation>`256` - `[0, 1024]`</xs:documentation>
					<xs:documentation>256 is the default player has</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="FogOfWarRemoverComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class FogOfWarRemoverComponent {<br>&emsp;&emsp;&emsp;&emsp;float radius = 140; // [0, 2000] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="radius" type="xs:decimal" default="140">
				<xs:annotation>
					<xs:documentation>`140` - `[0, 2000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="GameAreaEffectComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class GameAreaEffectComponent {<br>&emsp;&emsp;&emsp;&emsp;float radius = 0; // [0, 3.5] what's the radius (in pixels) of the area effect<br>&emsp;&emsp;&emsp;&emsp;std::string collide_with_tag = "hittable"; // [0, 1] the tags we're looking for<br>&emsp;&emsp;&emsp;&emsp;int frame_length = -1; // [0, 1] if not 0 will reapply this effect after this many frames have gone by<br>&emsp;&emsp;&emsp;&emsp;VECTOR_STR game_effect_entitities; //  just a vector of the game_effect entities<br>&emsp;&emsp;&emsp;&emsp;VECTOR_ENTITYID mEntitiesAppliedOutTo;<br>&emsp;&emsp;&emsp;&emsp;VECTOR_INT mEntitiesAppliedFrame;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="radius" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 3.5]`</xs:documentation>
					<xs:documentation>what's the radius (in pixels) of the area effect</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="collide_with_tag" type="xs:string" default="hittable">
				<xs:annotation>
					<xs:documentation>`hittable` - `[0, 1]`</xs:documentation>
					<xs:documentation>the tags we're looking for</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="frame_length" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if not 0 will reapply this effect after this many frames have gone by</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: VECTOR_STR for game_effect_entitities -->
				<!-- Some Unknown Type: VECTOR_ENTITYID for mEntitiesAppliedOutTo -->
				<!-- Some Unknown Type: VECTOR_INT for mEntitiesAppliedFrame -->
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="GameEffectComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class GameEffectComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string custom_effect_id; //  if 'effect' is set to 'CUSTOM', this will define effect uniqueness.<br>&emsp;&emsp;&emsp;&emsp;int frames = -1; // [0, 1] how many frames does it affect -1 = forever<br>&emsp;&emsp;&emsp;&emsp;int exclusivity_group = 0; // [0, 1] if > 0, previous game effects with the same exclusivity group as new one will be removed when calling LoadGameEffectEntityTo<br>&emsp;&emsp;&emsp;&emsp;bool report_block_msg = 1; // [0, 1] to disable the block message that rises<br>&emsp;&emsp;&emsp;&emsp;bool disable_movement = 0; // [0, 1] if set, will disable movement<br>&emsp;&emsp;&emsp;&emsp;std::string ragdoll_effect_custom_entity_file; //  an entity that is loaded to each ragdoll part if 'ragdoll_effect' is set to 'CUSTOM_RAGDOLL_ENTITY'<br>&emsp;&emsp;&emsp;&emsp;bool ragdoll_fx_custom_entity_apply_only_to_largest_body = 0; // [0, 1] if 1, 'ragdoll_effect_custom_entity_file' is loaded only to the largest piece in the ragdoll <br>&emsp;&emsp;&emsp;&emsp;std::string polymorph_target; //  when doing a polymorph, this is what we convert it to<br>&emsp;&emsp;&emsp;&emsp;USTRING mSerializedData; //  polymorph stores the serialized entity here...<br>&emsp;&emsp;&emsp;&emsp;EntityID mCaster = 0; // [0, 1] Contains a handle to the caster of this GameEffect<br>&emsp;&emsp;&emsp;&emsp;int mCasterHerdId = 0; // [0, 1] Contains the herd if of the caster of this GameEffect<br>&emsp;&emsp;&emsp;&emsp;int teleportation_probability = 600; // [0, 1] How likely is it that we teleport, larger = less often<br>&emsp;&emsp;&emsp;&emsp;int teleportation_delay_min_frames = 30; // [0, 1] Never teleports more often that this<br>&emsp;&emsp;&emsp;&emsp;float teleportation_radius_min = 128; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float teleportation_radius_max = 1024; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int teleportations_num = 0; // [0, 1] How many times has this GameEffectComponent teleported the owner?<br>&emsp;&emsp;&emsp;&emsp;double no_heal_max_hp_cap = 340282000000000014192072600942972764160; // [0, 1] If current hp is less than this, we store it here. Then we make sure the hp never exceeds this.<br>&emsp;&emsp;&emsp;&emsp;bool caused_by_ingestion_status_effect = 0; // [0, 1] Did this effect occur because someone ate something?<br>&emsp;&emsp;&emsp;&emsp;bool caused_by_stains = 0; // [0, 1] was this caused by stains<br>&emsp;&emsp;&emsp;&emsp;bool mCharmDisabledCameraBound = 0; // [0, 1] When charmed, will try to disable CameraBound. This keeps track if we've done it, so we can enable it back<br>&emsp;&emsp;&emsp;&emsp;bool mCharmEnabledTeleporting = 0; // [0, 1] When charmed, will try to enable teleporting (tag:teleportable_NOT). This keeps track if we've done it, so we can disable it again<br>&emsp;&emsp;&emsp;&emsp;bool mInvisible = 0; // [0, 1] Are we invisible?<br>&emsp;&emsp;&emsp;&emsp;int mCounter = 0; // [0, 1] Counts stuff<br>&emsp;&emsp;&emsp;&emsp;int mCooldown = 0; // [0, 1] Counts cooldown<br>&emsp;&emsp;&emsp;&emsp;bool mIsExtension = 0; // [0, 1] If 1, this is an effect extension and shouldn't create an extension when removed<br>&emsp;&emsp;&emsp;&emsp;bool mIsSpent = 0; // [0, 1] NOTE( Petri ): 29.4.2024 - this is used internally to make RESPAWN perk disabled in the UI<br>&emsp;&emsp;&emsp;&emsp;GAME_EFFECT::Enum effect; //  GAME_EFFECT<br>&emsp;&emsp;&emsp;&emsp;RAGDOLL_FX::Enum ragdoll_effect; //  if set, will use this for ragdoll effect<br>&emsp;&emsp;&emsp;&emsp;int ragdoll_material = 0; // [0, 1] converts to string name of the material that ragdoll is made out of<br>&emsp;&emsp;&emsp;&emsp;StatusEffectType causing_status_effect = 0; // [0, 1] Status effect that caused this game effect, if any<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="custom_effect_id" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>if 'effect' is set to 'CUSTOM', this will define effect uniqueness.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="frames" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
					<xs:documentation>how many frames does it affect -1 = forever</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="exclusivity_group" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if &gt; 0, previous game effects with the same exclusivity group as new one will be removed when calling LoadGameEffectEntityTo</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="report_block_msg" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>to disable the block message that rises</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="disable_movement" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if set, will disable movement</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ragdoll_effect_custom_entity_file" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>an entity that is loaded to each ragdoll part if 'ragdoll_effect' is set to 'CUSTOM_RAGDOLL_ENTITY'</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ragdoll_fx_custom_entity_apply_only_to_largest_body" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, 'ragdoll_effect_custom_entity_file' is loaded only to the largest piece in the ragdoll </xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="polymorph_target" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>when doing a polymorph, this is what we convert it to</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: USTRING for mSerializedData -->
				<!-- Some Unknown Type: EntityID for mCaster -->
			<xs:attribute name="mCasterHerdId" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>Contains the herd if of the caster of this GameEffect</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="teleportation_probability" type="xs:int" default="600">
				<xs:annotation>
					<xs:documentation>`600` - `[0, 1]`</xs:documentation>
					<xs:documentation>How likely is it that we teleport, larger = less often</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="teleportation_delay_min_frames" type="xs:int" default="30">
				<xs:annotation>
					<xs:documentation>`30` - `[0, 1]`</xs:documentation>
					<xs:documentation>Never teleports more often that this</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="teleportation_radius_min" type="xs:decimal" default="128">
				<xs:annotation>
					<xs:documentation>`128` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="teleportation_radius_max" type="xs:decimal" default="1024">
				<xs:annotation>
					<xs:documentation>`1024` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="teleportations_num" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>How many times has this GameEffectComponent teleported the owner?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="no_heal_max_hp_cap" type="xs:decimal" default="340282000000000014192072600942972764160">
				<xs:annotation>
					<xs:documentation>`3.40282e+038` - `[0, 1]`</xs:documentation>
					<xs:documentation>If current hp is less than this, we store it here. Then we make sure the hp never exceeds this.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="caused_by_ingestion_status_effect" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>Did this effect occur because someone ate something?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="caused_by_stains" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>was this caused by stains</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mCharmDisabledCameraBound" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>When charmed, will try to disable CameraBound. This keeps track if we've done it, so we can enable it back</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mCharmEnabledTeleporting" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>When charmed, will try to enable teleporting (tag:teleportable_NOT). This keeps track if we've done it, so we can disable it again</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mInvisible" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>Are we invisible?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mCounter" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>Counts stuff</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mCooldown" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>Counts cooldown</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mIsExtension" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>If 1, this is an effect extension and shouldn't create an extension when removed</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mIsSpent" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>NOTE( Petri ): 29.4.2024 - this is used internally to make RESPAWN perk disabled in the UI</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: GAME_EFFECT::Enum for effect -->
				<!-- Some Unknown Type: RAGDOLL_FX::Enum for ragdoll_effect -->
			<xs:attribute name="ragdoll_material" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>converts to string name of the material that ragdoll is made out of</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: StatusEffectType for causing_status_effect -->
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="GameLogComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class GameLogComponent {<br>&emsp;&emsp;&emsp;&emsp;bool report_death = 1; // [0, 1] switches on reporting things<br>&emsp;&emsp;&emsp;&emsp;bool report_damage = 0; // [0, 1] if set, will report when receiving damage<br>&emsp;&emsp;&emsp;&emsp;bool report_new_biomes = 1; // [0, 1] if false, won't report when player enters new biomes<br>&emsp;&emsp;&emsp;&emsp;VISITED_VEC mVisitiedBiomes; //  list of visited biomes<br>&emsp;&emsp;&emsp;&emsp;int mNewBiomeCheckFrame = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="report_death" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>switches on reporting things</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="report_damage" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if set, will report when receiving damage</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="report_new_biomes" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if false, won't report when player enters new biomes</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: VISITED_VEC for mVisitiedBiomes -->
			<xs:attribute name="mNewBiomeCheckFrame" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="GameStatsComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class GameStatsComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string name; //  no one uses the name variable on entity, so we have to do this to make it happen<br>&emsp;&emsp;&emsp;&emsp;std::string stats_filename; //  also generated from the gunk<br>&emsp;&emsp;&emsp;&emsp;bool is_player = 0; // [0, 1] if true, will use the session file for loading stats<br>&emsp;&emsp;&emsp;&emsp;std::string extra_death_msg; //  set when e.g. polymorphed<br>&emsp;&emsp;&emsp;&emsp;bool dont_do_logplayerkill = 0; // [0, 1] if 1, StatsLogPlayerKill must be manually called from lua<br>&emsp;&emsp;&emsp;&emsp;int player_polymorph_count = 0; // [0, 1] skip loading of stats if this higher than 0 and decrament this by one<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="name" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>no one uses the name variable on entity, so we have to do this to make it happen</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="stats_filename" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>also generated from the gunk</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_player" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, will use the session file for loading stats</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="extra_death_msg" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>set when e.g. polymorphed</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="dont_do_logplayerkill" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, StatsLogPlayerKill must be manually called from lua</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="player_polymorph_count" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>skip loading of stats if this higher than 0 and decrament this by one</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="GasBubbleComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class GasBubbleComponent {<br>&emsp;&emsp;&emsp;&emsp;float acceleration = -1; // [-100, 0] <br>&emsp;&emsp;&emsp;&emsp;float max_speed = 20; // [0, 20] <br>&emsp;&emsp;&emsp;&emsp;float mVelocity = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="acceleration" type="xs:decimal" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[-100, 0]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="max_speed" type="xs:decimal" default="20">
				<xs:annotation>
					<xs:documentation>`20` - `[0, 20]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mVelocity" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="GenomeDataComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class GenomeDataComponent {<br>&emsp;&emsp;&emsp;&emsp;bool is_predator = 0; // [0, 1] Predators are considered threats by other species and hunt for food.<br>&emsp;&emsp;&emsp;&emsp;float food_chain_rank = 0; // [0, 200] 0 means king of the hill. Greater number = more likely to get eaten by other species.<br>&emsp;&emsp;&emsp;&emsp;bool berserk_dont_attack_friends = 0; // [0, 1] if 1, this animal will not try to attack player who would normally be its friend<br>&emsp;&emsp;&emsp;&emsp;LensValue<int> herd_id; //  This is used for example to separate people in different tribes.<br>&emsp;&emsp;&emsp;&emsp;LensValue<bool> friend_thundermage; //  if 1, thunder mage doesn't attack this<br>&emsp;&emsp;&emsp;&emsp;LensValue<bool> friend_firemage; //  if 1, fire mage doesn't attack this<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="is_predator" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>Predators are considered threats by other species and hunt for food.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="food_chain_rank" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 200]`</xs:documentation>
					<xs:documentation>0 means king of the hill. Greater number = more likely to get eaten by other species.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="berserk_dont_attack_friends" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, this animal will not try to attack player who would normally be its friend</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="herd_id" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>This is used for example to separate people in different tribes.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="friend_thundermage" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>if 1, thunder mage doesn't attack this</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="friend_firemage" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>if 1, fire mage doesn't attack this</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="GhostComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class GhostComponent {<br>&emsp;&emsp;&emsp;&emsp;float speed = 5; // [0, 1] pixels per second<br>&emsp;&emsp;&emsp;&emsp;int new_hunt_target_check_every = 0; // [0, 1] how often do we look for targets<br>&emsp;&emsp;&emsp;&emsp;float hunt_box_radius = 512; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float aggressiveness = 100; // [0, 1] if higher than relations then will attack<br>&emsp;&emsp;&emsp;&emsp;float max_distance_from_home = 300; // [0, 1] how far from home can we go?<br>&emsp;&emsp;&emsp;&emsp;bool die_if_no_home = 1; // [0, 1] if set to false will die, if it can't find home<br>&emsp;&emsp;&emsp;&emsp;std::string target_tag = "player_unit"; // [0, 1] if something else (like mortal), will attack the home<br>&emsp;&emsp;&emsp;&emsp;vec2 velocity;<br>&emsp;&emsp;&emsp;&emsp;EntityID mEntityHome = 0; // [0, 1] where is our home?<br>&emsp;&emsp;&emsp;&emsp;int mFramesWithoutHome = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;vec2 mTargetPosition;<br>&emsp;&emsp;&emsp;&emsp;int mTargetEntityId = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;vec2 mRandomTarget;<br>&emsp;&emsp;&emsp;&emsp;int mNextTargetCheckFrame = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="speed" type="xs:decimal" default="5">
				<xs:annotation>
					<xs:documentation>`5` - `[0, 1]`</xs:documentation>
					<xs:documentation>pixels per second</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="new_hunt_target_check_every" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>how often do we look for targets</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="hunt_box_radius" type="xs:decimal" default="512">
				<xs:annotation>
					<xs:documentation>`512` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="aggressiveness" type="xs:decimal" default="100">
				<xs:annotation>
					<xs:documentation>`100` - `[0, 1]`</xs:documentation>
					<xs:documentation>if higher than relations then will attack</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="max_distance_from_home" type="xs:decimal" default="300">
				<xs:annotation>
					<xs:documentation>`300` - `[0, 1]`</xs:documentation>
					<xs:documentation>how far from home can we go?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="die_if_no_home" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if set to false will die, if it can't find home</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="target_tag" type="xs:string" default="player_unit">
				<xs:annotation>
					<xs:documentation>`player_unit` - `[0, 1]`</xs:documentation>
					<xs:documentation>if something else (like mortal), will attack the home</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="velocity.x" type="xs:decimal" default="0" />
			<xs:attribute name="velocity.y" type="xs:decimal" default="0" />
				<!-- Some Unknown Type: EntityID for mEntityHome -->
			<xs:attribute name="mFramesWithoutHome" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mTargetPosition.x" type="xs:decimal" default="0" />
			<xs:attribute name="mTargetPosition.y" type="xs:decimal" default="0" />
			<xs:attribute name="mTargetEntityId" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mRandomTarget.x" type="xs:decimal" default="0" />
			<xs:attribute name="mRandomTarget.y" type="xs:decimal" default="0" />
			<xs:attribute name="mNextTargetCheckFrame" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="GodInfoComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class GodInfoComponent {<br>&emsp;&emsp;&emsp;&emsp;float mana_current = 0; // [0, 1000] How much mana the player now has to use<br>&emsp;&emsp;&emsp;&emsp;float mana_max = 500; // [0, 1000] Max size of the mana pool<br>&emsp;&emsp;&emsp;&emsp;float gold = 0; // [0, 1000] How much gold the player has<br>&emsp;&emsp;&emsp;&emsp;Entity* god_entity;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="mana_current" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1000]`</xs:documentation>
					<xs:documentation>How much mana the player now has to use</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mana_max" type="xs:decimal" default="500">
				<xs:annotation>
					<xs:documentation>`500` - `[0, 1000]`</xs:documentation>
					<xs:documentation>Max size of the mana pool</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="gold" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1000]`</xs:documentation>
					<xs:documentation>How much gold the player has</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: Entity* for god_entity -->
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="GunComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class GunComponent {<br>&emsp;&emsp;&emsp;&emsp;LuaManager* mLuaManager;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
				<!-- Some Unknown Type: LuaManager* for mLuaManager -->
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="HealthBarComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class HealthBarComponent {<br><br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">

			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="HitEffectComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class HitEffectComponent {<br>&emsp;&emsp;&emsp;&emsp;int value = 0; // [0, 100] Usage depends on selected 'effect_hit'<br>&emsp;&emsp;&emsp;&emsp;std::string value_string; //  Usage depends on selected 'effect_hit'<br>&emsp;&emsp;&emsp;&emsp;GAME_EFFECT::Enum condition_effect; //  Hit entity needs to have this 'GAME_EFFECT' for effects to apply. If both 'condition_effect' and 'condition_status' are set, they are combined with AND logic<br>&emsp;&emsp;&emsp;&emsp;StatusEffectType condition_status = 0; // [0, 1] Hit entity needs to have this 'STATUS_EFFECT' for effects to apply<br>&emsp;&emsp;&emsp;&emsp;HIT_EFFECT::Enum effect_hit; //  What kind of 'HIT_EFFECT' is applied to hit entity if condition is true<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="value" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 100]`</xs:documentation>
					<xs:documentation>Usage depends on selected 'effect_hit'</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="value_string" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>Usage depends on selected 'effect_hit'</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: GAME_EFFECT::Enum for condition_effect -->
				<!-- Some Unknown Type: StatusEffectType for condition_status -->
				<!-- Some Unknown Type: HIT_EFFECT::Enum for effect_hit -->
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="HitboxComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class HitboxComponent {<br>&emsp;&emsp;&emsp;&emsp;bool is_player = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool is_enemy = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool is_item = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float aabb_min_x = -5; // [-15, 15] <br>&emsp;&emsp;&emsp;&emsp;float aabb_max_x = 5; // [-15, 15] <br>&emsp;&emsp;&emsp;&emsp;float aabb_min_y = -5; // [-15, 15] <br>&emsp;&emsp;&emsp;&emsp;float aabb_max_y = 5; // [-15, 15] <br>&emsp;&emsp;&emsp;&emsp;float damage_multiplier = 1; // [0, 1] All damage from hits to this hitbox is multiplied with this value before applying it.<br>&emsp;&emsp;&emsp;&emsp;vec2 offset;<br>&emsp;&emsp;&emsp;&emsp;bool dead = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="is_player" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_enemy" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_item" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="aabb_min_x" type="xs:decimal" default="-5">
				<xs:annotation>
					<xs:documentation>`-5` - `[-15, 15]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="aabb_max_x" type="xs:decimal" default="5">
				<xs:annotation>
					<xs:documentation>`5` - `[-15, 15]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="aabb_min_y" type="xs:decimal" default="-5">
				<xs:annotation>
					<xs:documentation>`-5` - `[-15, 15]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="aabb_max_y" type="xs:decimal" default="5">
				<xs:annotation>
					<xs:documentation>`5` - `[-15, 15]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="damage_multiplier" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>All damage from hits to this hitbox is multiplied with this value before applying it.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="offset.x" type="xs:decimal" default="0" />
			<xs:attribute name="offset.y" type="xs:decimal" default="0" />
			<xs:attribute name="dead" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="HomingComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class HomingComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string target_tag = "homing_target"; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool target_who_shot = 0; // [0, 1] If 1, targets who shot the projectile, ignores 'target_tag'.<br>&emsp;&emsp;&emsp;&emsp;float detect_distance = 150; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;float homing_velocity_multiplier = 0.9; // [-100, 100] <br>&emsp;&emsp;&emsp;&emsp;float homing_targeting_coeff = 160; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;bool just_rotate_towards_target = 0; // [0, 1] the default accelerates towards a target. If true will only rotate towards the target.<br>&emsp;&emsp;&emsp;&emsp;float max_turn_rate = 0.05; // [0, 6.283] radians. If just_rotate_towards_target then this is the maximum radians it can turn per frame<br>&emsp;&emsp;&emsp;&emsp;EntityID predefined_target = 0; // [0, 1] If set, we track this entity<br>&emsp;&emsp;&emsp;&emsp;bool look_for_root_entities_only = 0; // [0, 1] if set, will only look for entities that are _not_ child entities.<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="target_tag" type="xs:string" default="homing_target">
				<xs:annotation>
					<xs:documentation>`homing_target` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="target_who_shot" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>If 1, targets who shot the projectile, ignores 'target_tag'.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="detect_distance" type="xs:decimal" default="150">
				<xs:annotation>
					<xs:documentation>`150` - `[0, 1000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="homing_velocity_multiplier" type="xs:decimal" default="0.9">
				<xs:annotation>
					<xs:documentation>`0.9` - `[-100, 100]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="homing_targeting_coeff" type="xs:decimal" default="160">
				<xs:annotation>
					<xs:documentation>`160` - `[0, 1000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="just_rotate_towards_target" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>the default accelerates towards a target. If true will only rotate towards the target.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="max_turn_rate" type="xs:decimal" default="0.05">
				<xs:annotation>
					<xs:documentation>`0.05` - `[0, 6.283]`</xs:documentation>
					<xs:documentation>radians. If just_rotate_towards_target then this is the maximum radians it can turn per frame</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: EntityID for predefined_target -->
			<xs:attribute name="look_for_root_entities_only" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if set, will only look for entities that are _not_ child entities.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="HotspotComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class HotspotComponent {<br>&emsp;&emsp;&emsp;&emsp;bool transform_with_scale = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;std::string sprite_hotspot_name;<br>&emsp;&emsp;&emsp;&emsp;vec2 offset;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="transform_with_scale" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="sprite_hotspot_name" type="xs:string" default="" />
			<xs:attribute name="offset.x" type="xs:decimal" default="0" />
			<xs:attribute name="offset.y" type="xs:decimal" default="0" />
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="IKLimbAttackerComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class IKLimbAttackerComponent {<br>&emsp;&emsp;&emsp;&emsp;float radius = 54; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float leg_velocity_coeff = 15; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float targeting_radius = 120; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool targeting_raytrace = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;std::string target_entities_with_tag = "mortal"; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;vec2 mTarget;<br>&emsp;&emsp;&emsp;&emsp;EntityID mTargetEntity = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;IKLimbAttackerState mState;<br>&emsp;&emsp;&emsp;&emsp;float mStateTimer = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="radius" type="xs:decimal" default="54">
				<xs:annotation>
					<xs:documentation>`54` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="leg_velocity_coeff" type="xs:decimal" default="15">
				<xs:annotation>
					<xs:documentation>`15` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="targeting_radius" type="xs:decimal" default="120">
				<xs:annotation>
					<xs:documentation>`120` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="targeting_raytrace" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="target_entities_with_tag" type="xs:string" default="mortal">
				<xs:annotation>
					<xs:documentation>`mortal` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mTarget.x" type="xs:decimal" default="0" />
			<xs:attribute name="mTarget.y" type="xs:decimal" default="0" />
				<!-- Some Unknown Type: EntityID for mTargetEntity -->
				<!-- Some Unknown Type: IKLimbAttackerState for mState -->
			<xs:attribute name="mStateTimer" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="IKLimbComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class IKLimbComponent {<br>&emsp;&emsp;&emsp;&emsp;float length = 40; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float thigh_extra_lenght = 2; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float mJointSideInterpolation = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;vec2 end_position;<br>&emsp;&emsp;&emsp;&emsp;vec2 mJointWorldPos;<br>&emsp;&emsp;&emsp;&emsp;vec2 mEndPrevPos;<br>&emsp;&emsp;&emsp;&emsp;vec2 mPart0PrevPos;<br>&emsp;&emsp;&emsp;&emsp;float mPart0PrevRotation = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;vec2 mPart1PrevPos;<br>&emsp;&emsp;&emsp;&emsp;float mPart1PrevRotation = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="length" type="xs:decimal" default="40">
				<xs:annotation>
					<xs:documentation>`40` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="thigh_extra_lenght" type="xs:decimal" default="2">
				<xs:annotation>
					<xs:documentation>`2` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mJointSideInterpolation" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="end_position.x" type="xs:decimal" default="0" />
			<xs:attribute name="end_position.y" type="xs:decimal" default="0" />
			<xs:attribute name="mJointWorldPos.x" type="xs:decimal" default="0" />
			<xs:attribute name="mJointWorldPos.y" type="xs:decimal" default="0" />
			<xs:attribute name="mEndPrevPos.x" type="xs:decimal" default="0" />
			<xs:attribute name="mEndPrevPos.y" type="xs:decimal" default="0" />
			<xs:attribute name="mPart0PrevPos.x" type="xs:decimal" default="0" />
			<xs:attribute name="mPart0PrevPos.y" type="xs:decimal" default="0" />
			<xs:attribute name="mPart0PrevRotation" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mPart1PrevPos.x" type="xs:decimal" default="0" />
			<xs:attribute name="mPart1PrevPos.y" type="xs:decimal" default="0" />
			<xs:attribute name="mPart1PrevRotation" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="IKLimbWalkerComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class IKLimbWalkerComponent {<br>&emsp;&emsp;&emsp;&emsp;float ground_attachment_min_spread = 16; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int ground_attachment_max_tries = 10; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float ground_attachment_max_angle = 0.8; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float ground_attachment_ray_length_coeff = 1.15; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float leg_velocity_coeff = 15; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool affect_flying = 0; // [0, 1] if set, will cause the mFlyingTime (in CharacterDataComponent) of the parent to be 0 or 1 depending on if we're touching anything<br>&emsp;&emsp;&emsp;&emsp;int mState = 0; // [0, 1] 0 = detached, 1 = attached<br>&emsp;&emsp;&emsp;&emsp;int ray_skip_material = 0; // [0, 1] String name of material to not cast rays against. Defaults to 'aluminium'<br>&emsp;&emsp;&emsp;&emsp;vec2 mTarget;<br>&emsp;&emsp;&emsp;&emsp;vec2 mPrevTarget;<br>&emsp;&emsp;&emsp;&emsp;vec2 mPrevCenterPosition;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="ground_attachment_min_spread" type="xs:decimal" default="16">
				<xs:annotation>
					<xs:documentation>`16` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ground_attachment_max_tries" type="xs:int" default="10">
				<xs:annotation>
					<xs:documentation>`10` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ground_attachment_max_angle" type="xs:decimal" default="0.8">
				<xs:annotation>
					<xs:documentation>`0.8` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ground_attachment_ray_length_coeff" type="xs:decimal" default="1.15">
				<xs:annotation>
					<xs:documentation>`1.15` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="leg_velocity_coeff" type="xs:decimal" default="15">
				<xs:annotation>
					<xs:documentation>`15` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="affect_flying" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if set, will cause the mFlyingTime (in CharacterDataComponent) of the parent to be 0 or 1 depending on if we're touching anything</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mState" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>0 = detached, 1 = attached</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ray_skip_material" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>String name of material to not cast rays against. Defaults to 'aluminium'</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mTarget.x" type="xs:decimal" default="0" />
			<xs:attribute name="mTarget.y" type="xs:decimal" default="0" />
			<xs:attribute name="mPrevTarget.x" type="xs:decimal" default="0" />
			<xs:attribute name="mPrevTarget.y" type="xs:decimal" default="0" />
			<xs:attribute name="mPrevCenterPosition.x" type="xs:decimal" default="0" />
			<xs:attribute name="mPrevCenterPosition.y" type="xs:decimal" default="0" />
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="IKLimbsAnimatorComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class IKLimbsAnimatorComponent {<br>&emsp;&emsp;&emsp;&emsp;int future_state_samples = 10; // [0, 1] The number of future animation states evaluated to find the next state<br>&emsp;&emsp;&emsp;&emsp;float ground_attachment_ray_length_coeff = 1.15; // [0, 1] Limb raycast length is (ground_attachment_ray_length_coeff * limb length)<br>&emsp;&emsp;&emsp;&emsp;float leg_velocity_coeff = 15; // [0, 1] Limbs are moved towards target position at a pace affected by this value.<br>&emsp;&emsp;&emsp;&emsp;bool affect_flying = 0; // [0, 1] If set, will cause the mFlyingTime (in CharacterDataComponent) of the entity to be 0 or 1 depending on if the limbs are touching ground<br>&emsp;&emsp;&emsp;&emsp;float large_movement_penalty_coeff = 0.25; // [0, 1] The movement score is multiplied by this value if a large move would occur<br>&emsp;&emsp;&emsp;&emsp;float no_ground_attachment_penalty_coeff = 0.75; // [0, 1] If a limb movement would make it not collide with ground, the movement score is multiplied with this value. Use lower values to make the limbs prioritize attaching to walls.<br>&emsp;&emsp;&emsp;&emsp;bool is_limp = 0; // [0, 1] If 1, will apply verlet animation to simulate ragdoll-like limbs<br>&emsp;&emsp;&emsp;&emsp;int ray_skip_material = 0; // [0, 1] String name of material to not cast rays against. Defaults to 'aluminium'<br>&emsp;&emsp;&emsp;&emsp;vec2 mPrevBodyPosition;<br>&emsp;&emsp;&emsp;&emsp;IKLimbStateVec mLimbStates;<br>&emsp;&emsp;&emsp;&emsp;bool mHasGroundAttachmentOnAnyLeg = 0; // [0, 1] Will be set to true if at least one leg is attached to ground.<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="future_state_samples" type="xs:int" default="10">
				<xs:annotation>
					<xs:documentation>`10` - `[0, 1]`</xs:documentation>
					<xs:documentation>The number of future animation states evaluated to find the next state</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ground_attachment_ray_length_coeff" type="xs:decimal" default="1.15">
				<xs:annotation>
					<xs:documentation>`1.15` - `[0, 1]`</xs:documentation>
					<xs:documentation>Limb raycast length is (ground_attachment_ray_length_coeff * limb length)</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="leg_velocity_coeff" type="xs:decimal" default="15">
				<xs:annotation>
					<xs:documentation>`15` - `[0, 1]`</xs:documentation>
					<xs:documentation>Limbs are moved towards target position at a pace affected by this value.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="affect_flying" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>If set, will cause the mFlyingTime (in CharacterDataComponent) of the entity to be 0 or 1 depending on if the limbs are touching ground</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="large_movement_penalty_coeff" type="xs:decimal" default="0.25">
				<xs:annotation>
					<xs:documentation>`0.25` - `[0, 1]`</xs:documentation>
					<xs:documentation>The movement score is multiplied by this value if a large move would occur</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="no_ground_attachment_penalty_coeff" type="xs:decimal" default="0.75">
				<xs:annotation>
					<xs:documentation>`0.75` - `[0, 1]`</xs:documentation>
					<xs:documentation>If a limb movement would make it not collide with ground, the movement score is multiplied with this value. Use lower values to make the limbs prioritize attaching to walls.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_limp" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>If 1, will apply verlet animation to simulate ragdoll-like limbs</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ray_skip_material" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>String name of material to not cast rays against. Defaults to 'aluminium'</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mPrevBodyPosition.x" type="xs:decimal" default="0" />
			<xs:attribute name="mPrevBodyPosition.y" type="xs:decimal" default="0" />
				<!-- Some Unknown Type: IKLimbStateVec for mLimbStates -->
			<xs:attribute name="mHasGroundAttachmentOnAnyLeg" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>Will be set to true if at least one leg is attached to ground.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="IngestionComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class IngestionComponent {<br>&emsp;&emsp;&emsp;&emsp;int64 ingestion_size = 0; // [0, 1] How many units of material we currently store<br>&emsp;&emsp;&emsp;&emsp;int64 ingestion_capacity = 7500; // [0, 1] How many units of material we can store<br>&emsp;&emsp;&emsp;&emsp;uint32 ingestion_cooldown_delay_frames = 600; // [0, 1] How many frames is ingestion_size retained after last time eating?<br>&emsp;&emsp;&emsp;&emsp;uint32 ingestion_reduce_every_n_frame = 5; // [0, 1] One unit of ingestion_size is removed every N frame<br>&emsp;&emsp;&emsp;&emsp;float overingestion_damage = 0.002; // [0, 1] How much damage per overingested cell is applied<br>&emsp;&emsp;&emsp;&emsp;float blood_healing_speed = 0.0008; // [0, 1000] affects healing speed if entity has HEALING_BLOOD game effect. The amount of hp restored per one blood cell.<br>&emsp;&emsp;&emsp;&emsp;std::string ingestion_satiation_material_tag; //  If set, only materials with this tag will increase satiation level<br>&emsp;&emsp;&emsp;&emsp;int32 m_ingestion_cooldown_frames = 0; // [0, 1] Next frame ingestion_size cooldown can occur<br>&emsp;&emsp;&emsp;&emsp;int32 m_next_overeating_msg_frame = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;std::string m_ingestion_satiation_material_tag_cached;<br>&emsp;&emsp;&emsp;&emsp;std::set<int32> m_ingestion_satiation_material_cache;<br>&emsp;&emsp;&emsp;&emsp;int32 m_damage_effect_lifetime = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="ingestion_size" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>How many units of material we currently store</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ingestion_capacity" type="xs:int" default="7500">
				<xs:annotation>
					<xs:documentation>`7500` - `[0, 1]`</xs:documentation>
					<xs:documentation>How many units of material we can store</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ingestion_cooldown_delay_frames" type="xs:unsignedInt" default="600">
				<xs:annotation>
					<xs:documentation>`600` - `[0, 1]`</xs:documentation>
					<xs:documentation>How many frames is ingestion_size retained after last time eating?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ingestion_reduce_every_n_frame" type="xs:unsignedInt" default="5">
				<xs:annotation>
					<xs:documentation>`5` - `[0, 1]`</xs:documentation>
					<xs:documentation>One unit of ingestion_size is removed every N frame</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="overingestion_damage" type="xs:decimal" default="0.002">
				<xs:annotation>
					<xs:documentation>`0.002` - `[0, 1]`</xs:documentation>
					<xs:documentation>How much damage per overingested cell is applied</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="blood_healing_speed" type="xs:decimal" default="0.0008">
				<xs:annotation>
					<xs:documentation>`0.0008` - `[0, 1000]`</xs:documentation>
					<xs:documentation>affects healing speed if entity has HEALING_BLOOD game effect. The amount of hp restored per one blood cell.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ingestion_satiation_material_tag" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>If set, only materials with this tag will increase satiation level</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="m_ingestion_cooldown_frames" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>Next frame ingestion_size cooldown can occur</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="m_next_overeating_msg_frame" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="m_ingestion_satiation_material_tag_cached" type="xs:string" default="" />
				<!-- Some Unknown Type: std::set<int32> for m_ingestion_satiation_material_cache -->
			<xs:attribute name="m_damage_effect_lifetime" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="InheritTransformComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class InheritTransformComponent {<br>&emsp;&emsp;&emsp;&emsp;bool use_root_parent = 0; // [0, 1] if 1, we use the root of our entity hierarchy instead of the immediate parent<br>&emsp;&emsp;&emsp;&emsp;bool only_position = 0; // [0, 1] if 1, we only inherit position. it is calculated as follows: parent_position + parent_offset * parent_scale<br>&emsp;&emsp;&emsp;&emsp;std::string parent_hotspot_tag; //  if set, we apply the offset of parent HotSpot with this tag<br>&emsp;&emsp;&emsp;&emsp;int parent_sprite_id = -1; // [0, 1] if >= 0, the Nth sprite transform in parent entity is inherited<br>&emsp;&emsp;&emsp;&emsp;bool always_use_immediate_parent_rotation = 0; // [0, 1] if 1, we use the immediate parent for rotation, no matter what other properties say<br>&emsp;&emsp;&emsp;&emsp;bool rotate_based_on_x_scale = 0; // [0, 1] if 1, the rotation is set to 0 deg if scale >= 0 else to 180 deg<br>&emsp;&emsp;&emsp;&emsp;types::xform Transform;<br>&emsp;&emsp;&emsp;&emsp;int mUpdateFrame = -1; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:sequence minOccurs="0"> <xs:element name="Transform" type="Transform" /></xs:sequence>
			<xs:attribute name="use_root_parent" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, we use the root of our entity hierarchy instead of the immediate parent</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="only_position" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, we only inherit position. it is calculated as follows: parent_position + parent_offset * parent_scale</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="parent_hotspot_tag" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>if set, we apply the offset of parent HotSpot with this tag</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="parent_sprite_id" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if &gt;= 0, the Nth sprite transform in parent entity is inherited</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="always_use_immediate_parent_rotation" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, we use the immediate parent for rotation, no matter what other properties say</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="rotate_based_on_x_scale" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, the rotation is set to 0 deg if scale &gt;= 0 else to 180 deg</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mUpdateFrame" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="InteractableComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class InteractableComponent {<br>&emsp;&emsp;&emsp;&emsp;float radius = 10; // [0, 1] Distance from entity position where interaction is possible<br>&emsp;&emsp;&emsp;&emsp;std::string ui_text; //  key or string for the text to display<br>&emsp;&emsp;&emsp;&emsp;std::string name; //  this name is called to the on_interacted function on LuaComponents<br>&emsp;&emsp;&emsp;&emsp;int exclusivity_group = 0; // [0, 1] If > 0, only 1 instance of this interaction can be display at the same time<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="radius" type="xs:decimal" default="10">
				<xs:annotation>
					<xs:documentation>`10` - `[0, 1]`</xs:documentation>
					<xs:documentation>Distance from entity position where interaction is possible</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ui_text" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>key or string for the text to display</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="name" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>this name is called to the on_interacted function on LuaComponents</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="exclusivity_group" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>If &gt; 0, only 1 instance of this interaction can be display at the same time</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="Inventory2Component">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class Inventory2Component {<br>&emsp;&emsp;&emsp;&emsp;int quick_inventory_slots = 10; // [0, 30] <br>&emsp;&emsp;&emsp;&emsp;int full_inventory_slots_x = 8; // [0, 30] <br>&emsp;&emsp;&emsp;&emsp;int full_inventory_slots_y = 8; // [0, 30] <br>&emsp;&emsp;&emsp;&emsp;uint32 mSavedActiveItemIndex = 0; // [0, 1] Used to retain active item across save/load. Don't touch this unless you know what you're doing!<br>&emsp;&emsp;&emsp;&emsp;EntityID mActiveItem = 0; // [0, 1] NOTE: Don't attempt to directly change the value of this field via lua code. It will probably break the game logic in obvious or subtle ways.<br>&emsp;&emsp;&emsp;&emsp;EntityID mActualActiveItem = 0; // [0, 1] NOTE: Don't attempt to directly change the value of this field via lua code. It will probably break the game logic in obvious or subtle ways.<br>&emsp;&emsp;&emsp;&emsp;EntityID mActiveStash = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;EntityID mThrowItem = 0; // [0, 1] Is used to store the item that is being thrown, instead of mActiveItem, since the player can switch items (mActiveItem) during the throwing animation<br>&emsp;&emsp;&emsp;&emsp;bool mItemHolstered = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mInitialized = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mForceRefresh = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mDontLogNextItemEquip = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float mSmoothedItemXOffset = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mLastItemSwitchFrame = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float mIntroEquipItemLerp = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;vec2 mSmoothedItemAngleVec;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="quick_inventory_slots" type="xs:int" default="10">
				<xs:annotation>
					<xs:documentation>`10` - `[0, 30]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="full_inventory_slots_x" type="xs:int" default="8">
				<xs:annotation>
					<xs:documentation>`8` - `[0, 30]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="full_inventory_slots_y" type="xs:int" default="8">
				<xs:annotation>
					<xs:documentation>`8` - `[0, 30]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mSavedActiveItemIndex" type="xs:unsignedInt" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>Used to retain active item across save/load. Don't touch this unless you know what you're doing!</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: EntityID for mActiveItem -->
				<!-- Some Unknown Type: EntityID for mActualActiveItem -->
				<!-- Some Unknown Type: EntityID for mActiveStash -->
				<!-- Some Unknown Type: EntityID for mThrowItem -->
			<xs:attribute name="mItemHolstered" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mInitialized" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mForceRefresh" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mDontLogNextItemEquip" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mSmoothedItemXOffset" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mLastItemSwitchFrame" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mIntroEquipItemLerp" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mSmoothedItemAngleVec.x" type="xs:decimal" default="0" />
			<xs:attribute name="mSmoothedItemAngleVec.y" type="xs:decimal" default="0" />
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="InventoryComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class InventoryComponent {<br>&emsp;&emsp;&emsp;&emsp;int ui_container_type = 1; // [0, 1] UI_CONTAINER_TYPES enum<br>&emsp;&emsp;&emsp;&emsp;std::string ui_element_sprite = "data/ui_gfx/inventory/inventory_box.png"; // [0, 1] ui back sprite<br>&emsp;&emsp;&emsp;&emsp;std::string actions; //  list of actions, used for serialization<br>&emsp;&emsp;&emsp;&emsp;ivec2 ui_container_size; //  ui size, how many items x*y we can fit in<br>&emsp;&emsp;&emsp;&emsp;ivec2 ui_element_size; //  ui size<br>&emsp;&emsp;&emsp;&emsp;ivec2 ui_position_on_screen; //  where do we load this on screen<br>&emsp;&emsp;&emsp;&emsp;InvenentoryUpdateListener* update_listener; //  listener to keep ui up with ability changes<br>&emsp;&emsp;&emsp;&emsp;INVENTORYITEM_VECTOR items;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="ui_container_type" type="xs:int" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>UI_CONTAINER_TYPES enum</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ui_element_sprite" type="xs:string" default="data/ui_gfx/inventory/inventory_box.png">
				<xs:annotation>
					<xs:documentation>`data/ui_gfx/inventory/inventory_box.png` - `[0, 1]`</xs:documentation>
					<xs:documentation>ui back sprite</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="actions" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>list of actions, used for serialization</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ui_container_size.x" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>ui size, how many items x*y we can fit in</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ui_container_size.y" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>ui size, how many items x*y we can fit in</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ui_element_size.x" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>ui size</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ui_element_size.y" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>ui size</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ui_position_on_screen.x" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>where do we load this on screen</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ui_position_on_screen.y" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>where do we load this on screen</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: InvenentoryUpdateListener* for update_listener -->
				<!-- Some Unknown Type: INVENTORYITEM_VECTOR for items -->
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="InventoryGuiComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class InventoryGuiComponent {<br>&emsp;&emsp;&emsp;&emsp;bool has_opened_inventory_edit = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int wallet_money_target = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mDisplayFireRateWaitBar = 0; // [0, 1] hax, don't touch!<br>&emsp;&emsp;&emsp;&emsp;ImGuiContext* imgui;<br>&emsp;&emsp;&emsp;&emsp;int mLastFrameInteracted = -100; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mLastFrameActionsVisible = -1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;Entity* mLastPurchasedAction;<br>&emsp;&emsp;&emsp;&emsp;bool mActive = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float mAlpha = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float mBackgroundOverlayAlpha = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mFrameShake_ReloadBar = 0; // [0, 1] for animations of shaking them bars<br>&emsp;&emsp;&emsp;&emsp;int mFrameShake_ManaBar = 0; // [0, 1] for animations of shaking them bars<br>&emsp;&emsp;&emsp;&emsp;int mFrameShake_FlyBar = 0; // [0, 1] for animations of shaking them bars<br>&emsp;&emsp;&emsp;&emsp;int mFrameShake_FireRateWaitBar = 0; // [0, 1] for animations of shaking them bars<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="has_opened_inventory_edit" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="wallet_money_target" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mDisplayFireRateWaitBar" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>hax, don't touch!</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: ImGuiContext* for imgui -->
			<xs:attribute name="mLastFrameInteracted" type="xs:int" default="-100">
				<xs:annotation>
					<xs:documentation>`-100` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mLastFrameActionsVisible" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: Entity* for mLastPurchasedAction -->
			<xs:attribute name="mActive" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mAlpha" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mBackgroundOverlayAlpha" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mFrameShake_ReloadBar" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>for animations of shaking them bars</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mFrameShake_ManaBar" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>for animations of shaking them bars</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mFrameShake_FlyBar" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>for animations of shaking them bars</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mFrameShake_FireRateWaitBar" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>for animations of shaking them bars</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="ItemAIKnowledgeComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ItemAIKnowledgeComponent {<br>&emsp;&emsp;&emsp;&emsp;bool is_ranged_weapon = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool is_throwable_weapon = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool is_melee_weapon = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool is_self_healing = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool is_other_healing = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool is_self_buffing = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool is_other_buffing = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool is_weapon = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool is_known = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool is_safe = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool is_consumed = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool never_use = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float ranged_min_distance = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="is_ranged_weapon" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_throwable_weapon" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_melee_weapon" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_self_healing" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_other_healing" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_self_buffing" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_other_buffing" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_weapon" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_known" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_safe" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_consumed" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="never_use" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ranged_min_distance" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="ItemActionComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ItemActionComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string action_id; //  the name ID of the action<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="action_id" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>the name ID of the action</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="ItemAlchemyComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ItemAlchemyComponent {<br>&emsp;&emsp;&emsp;&emsp;int material_make_always_cast = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int material_remove_shuffle = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int material_animate_wand = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int material_animate_wand_alt = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int material_increase_uses_remaining = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int material_sacrifice = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="material_make_always_cast" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="material_remove_shuffle" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="material_animate_wand" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="material_animate_wand_alt" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="material_increase_uses_remaining" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="material_sacrifice" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="ItemChestComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ItemChestComponent {<br>&emsp;&emsp;&emsp;&emsp;int item_count_min = 0; // [0, 1e+006] <br>&emsp;&emsp;&emsp;&emsp;int item_count_max = 0; // [0, 1e+006] <br>&emsp;&emsp;&emsp;&emsp;int level = 0; // [0, 1e+006] <br>&emsp;&emsp;&emsp;&emsp;bool enemy_drop = 0; // [0, 1] enemy_drop, if set will modify the item_count_min, item_count_max...<br>&emsp;&emsp;&emsp;&emsp;std::string actions; //  e.g. 'bullet,bullet,damage' ... actions are parsed into a string<br>&emsp;&emsp;&emsp;&emsp;std::string action_uses_remaining; //  e.g. '10,10,-1' ... action uses remaining counts are parsed into a string<br>&emsp;&emsp;&emsp;&emsp;std::string other_entities_to_spawn; //  file names of other entities we should spawn from this chest, comma separated<br>&emsp;&emsp;&emsp;&emsp;unsigned int mSeed = 0; // [0, 1] this is used to figure out what we spawn from this chest<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="item_count_min" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1e+006]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="item_count_max" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1e+006]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="level" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1e+006]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="enemy_drop" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>enemy_drop, if set will modify the item_count_min, item_count_max...</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="actions" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>e.g. 'bullet,bullet,damage' ... actions are parsed into a string</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="action_uses_remaining" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>e.g. '10,10,-1' ... action uses remaining counts are parsed into a string</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="other_entities_to_spawn" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>file names of other entities we should spawn from this chest, comma separated</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mSeed" type="xs:unsignedInt" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>this is used to figure out what we spawn from this chest</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="ItemComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ItemComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string item_name; //  the name of the item<br>&emsp;&emsp;&emsp;&emsp;bool is_stackable = 0; // [0, 1] does this item stack on other items the same 'item_name' in the inventory?<br>&emsp;&emsp;&emsp;&emsp;bool is_consumable = 0; // [0, 1] if 1, using this item will reduce 'uses_remaining'. When it reaches zero the item is destroyed<br>&emsp;&emsp;&emsp;&emsp;bool stats_count_as_item_pick_up = 1; // [0, 1] does this count as an item that was picked up in the stats<br>&emsp;&emsp;&emsp;&emsp;bool auto_pickup = 0; // [0, 1] if 1, item will be automatically picked up, no pickup hint is shown<br>&emsp;&emsp;&emsp;&emsp;bool permanently_attached = 0; // [0, 1] if 1, this item can't be removed from a container once it is put inside one<br>&emsp;&emsp;&emsp;&emsp;int uses_remaining = -1; // [0, 1] how many times can this item be used? -1 = unlimited, will be reset to gun_actions.lua max_uses by inventorygui_system, -2 = unlimited unlimited<br>&emsp;&emsp;&emsp;&emsp;bool is_identified = 1; // [0, 1] is it known what this item does?<br>&emsp;&emsp;&emsp;&emsp;bool is_frozen = 0; // [0, 1] if 1, this item can't be modified or moved from a wand<br>&emsp;&emsp;&emsp;&emsp;bool collect_nondefault_actions = 0; // [0, 1] does player keep this item when respawning?<br>&emsp;&emsp;&emsp;&emsp;bool remove_on_death = 0; // [0, 1] is this entity destroyed when it's in an inventory and the inventory owner dies?<br>&emsp;&emsp;&emsp;&emsp;bool remove_on_death_if_empty = 0; // [0, 1] is this entity destroyed when it's in an inventory, empty and the inventory owner dies?<br>&emsp;&emsp;&emsp;&emsp;bool remove_default_child_actions_on_death = 0; // [0, 1] if true, the default AbilityComponent.child_actions in this items will be removed when it dies<br>&emsp;&emsp;&emsp;&emsp;bool play_hover_animation = 0; // [0, 1] if 1, the item will play a hovering animation<br>&emsp;&emsp;&emsp;&emsp;bool play_spinning_animation = 1; // [0, 1] if 1, the item will play a spinning animation, if player_hover_animation is 0<br>&emsp;&emsp;&emsp;&emsp;bool is_equipable_forced = 0; // [0, 1] if 1, the default logic for determining if an item can be equiped in inventory is overridden and this can be always equipped<br>&emsp;&emsp;&emsp;&emsp;bool play_pick_sound = 1; // [0, 1] if 1, plays a default sound when picked<br>&emsp;&emsp;&emsp;&emsp;bool drinkable = 1; // [0, 1] if 0 you cannot drink this, default is 1, because that's how it was implemented and backwards compatibility<br>&emsp;&emsp;&emsp;&emsp;int max_child_items = 0; // [0, 1] number of items this can hold inside itself. TODO: get rid of all uses of 'ability->gun_config.deck_capacity' and replace them with this!<br>&emsp;&emsp;&emsp;&emsp;std::string ui_sprite; //  sprite displayed for the item in various UIs. If not empty overrides sprites declared by Ability and ItemAction<br>&emsp;&emsp;&emsp;&emsp;std::string ui_description; //  item description displayed in various UIs<br>&emsp;&emsp;&emsp;&emsp;bool enable_orb_hacks = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool is_all_spells_book = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool always_use_item_name_in_ui = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;std::string custom_pickup_string; //  if set, this is used for the 'Press $0 to pick $1' message<br>&emsp;&emsp;&emsp;&emsp;bool ui_display_description_on_pick_up_hint = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int next_frame_pickable = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int npc_next_frame_pickable = 0; // [0, 1] NPC have their own next_frame_pickable, because this is used to make NPCs not pick up gold, which also meant player couldn't pick up that gold<br>&emsp;&emsp;&emsp;&emsp;bool is_pickable = 1; // [0, 1] can this be picked up and placed on someone's inventory<br>&emsp;&emsp;&emsp;&emsp;bool is_hittable_always = 0; // [0, 1] to override the weirdness that is is_pickable, which affects if this is hittable or not. If true, will always be hittable regardless of is_pickable<br>&emsp;&emsp;&emsp;&emsp;float item_pickup_radius = 14.1; // [0, 1] how many pixels away can this item be picked up from<br>&emsp;&emsp;&emsp;&emsp;float camera_max_distance = 50; // [0, 1] how far can we move the camera from the player when this item is equipped<br>&emsp;&emsp;&emsp;&emsp;float camera_smooth_speed_multiplier = 1; // [0, 1] how quickly does the camera follow player?<br>&emsp;&emsp;&emsp;&emsp;bool has_been_picked_by_player = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mFramePickedUp = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;vec2 spawn_pos; //  the position where this item spawned<br>&emsp;&emsp;&emsp;&emsp;INVENTORY_KIND::Enum preferred_inventory; //  Which inventory do we go to when we're picked up, if it's not full.<br>&emsp;&emsp;&emsp;&emsp;ivec2 inventory_slot; //  our preferred slot (x,y) in the inventory<br>&emsp;&emsp;&emsp;&emsp;int mItemUid = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mIsIdentified = 1; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="item_name" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>the name of the item</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_stackable" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>does this item stack on other items the same 'item_name' in the inventory?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_consumable" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, using this item will reduce 'uses_remaining'. When it reaches zero the item is destroyed</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="stats_count_as_item_pick_up" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>does this count as an item that was picked up in the stats</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="auto_pickup" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, item will be automatically picked up, no pickup hint is shown</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="permanently_attached" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, this item can't be removed from a container once it is put inside one</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="uses_remaining" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
					<xs:documentation>how many times can this item be used? -1 = unlimited, will be reset to gun_actions.lua max_uses by inventorygui_system, -2 = unlimited unlimited</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_identified" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>is it known what this item does?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_frozen" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, this item can't be modified or moved from a wand</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="collect_nondefault_actions" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>does player keep this item when respawning?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="remove_on_death" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>is this entity destroyed when it's in an inventory and the inventory owner dies?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="remove_on_death_if_empty" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>is this entity destroyed when it's in an inventory, empty and the inventory owner dies?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="remove_default_child_actions_on_death" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, the default AbilityComponent.child_actions in this items will be removed when it dies</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="play_hover_animation" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, the item will play a hovering animation</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="play_spinning_animation" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, the item will play a spinning animation, if player_hover_animation is 0</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_equipable_forced" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, the default logic for determining if an item can be equiped in inventory is overridden and this can be always equipped</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="play_pick_sound" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, plays a default sound when picked</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="drinkable" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 0 you cannot drink this, default is 1, because that's how it was implemented and backwards compatibility</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="max_child_items" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>number of items this can hold inside itself. TODO: get rid of all uses of 'ability-&gt;gun_config.deck_capacity' and replace them with this!</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ui_sprite" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>sprite displayed for the item in various UIs. If not empty overrides sprites declared by Ability and ItemAction</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ui_description" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>item description displayed in various UIs</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="enable_orb_hacks" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_all_spells_book" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="always_use_item_name_in_ui" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="custom_pickup_string" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>if set, this is used for the 'Press $0 to pick $1' message</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ui_display_description_on_pick_up_hint" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="next_frame_pickable" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="npc_next_frame_pickable" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>NPC have their own next_frame_pickable, because this is used to make NPCs not pick up gold, which also meant player couldn't pick up that gold</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_pickable" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>can this be picked up and placed on someone's inventory</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_hittable_always" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>to override the weirdness that is is_pickable, which affects if this is hittable or not. If true, will always be hittable regardless of is_pickable</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="item_pickup_radius" type="xs:decimal" default="14.1">
				<xs:annotation>
					<xs:documentation>`14.1` - `[0, 1]`</xs:documentation>
					<xs:documentation>how many pixels away can this item be picked up from</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="camera_max_distance" type="xs:decimal" default="50">
				<xs:annotation>
					<xs:documentation>`50` - `[0, 1]`</xs:documentation>
					<xs:documentation>how far can we move the camera from the player when this item is equipped</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="camera_smooth_speed_multiplier" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>how quickly does the camera follow player?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="has_been_picked_by_player" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mFramePickedUp" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="spawn_pos.x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>the position where this item spawned</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="spawn_pos.y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>the position where this item spawned</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: INVENTORY_KIND::Enum for preferred_inventory -->
			<xs:attribute name="inventory_slot.x" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>our preferred slot (x,y) in the inventory</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="inventory_slot.y" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>our preferred slot (x,y) in the inventory</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mItemUid" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mIsIdentified" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="ItemCostComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ItemCostComponent {<br>&emsp;&emsp;&emsp;&emsp;int64 cost = 100; // [0, 3500] <br>&emsp;&emsp;&emsp;&emsp;bool stealable = 0; // [0, 1] if set - will check that it's within an area called shop<br>&emsp;&emsp;&emsp;&emsp;int64 mExCost = -1; // [0, 1] used to change the text on the sprite<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="cost" type="xs:int" default="100">
				<xs:annotation>
					<xs:documentation>`100` - `[0, 3500]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="stealable" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if set - will check that it's within an area called shop</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mExCost" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
					<xs:documentation>used to change the text on the sprite</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="ItemPickUpperComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ItemPickUpperComponent {<br>&emsp;&emsp;&emsp;&emsp;bool is_in_npc = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool pick_up_any_item_buggy = 0; // [0, 1] If true, will pick up _any_ item. Breaks all kinds of things, but maybe mods will find this fun to mess around with<br>&emsp;&emsp;&emsp;&emsp;bool is_immune_to_kicks = 0; // [0, 1] if set, won't drop the wand if kicked. Mainly used by wand ghosts.<br>&emsp;&emsp;&emsp;&emsp;EntityID only_pick_this_entity = 0; // [0, 1] picks up this entity and only this entity. Overrides the is_in_npc checks that try to limit things to pickuppable wands<br>&emsp;&emsp;&emsp;&emsp;bool drop_items_on_death = 1; // [0, 1] if true, will drop all items. E.g. if true for player, player drops their wands<br>&emsp;&emsp;&emsp;&emsp;vec2 mLatestItemOverlapInfoBoxPosition;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="is_in_npc" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="pick_up_any_item_buggy" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>If true, will pick up _any_ item. Breaks all kinds of things, but maybe mods will find this fun to mess around with</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_immune_to_kicks" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if set, won't drop the wand if kicked. Mainly used by wand ghosts.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: EntityID for only_pick_this_entity -->
			<xs:attribute name="drop_items_on_death" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, will drop all items. E.g. if true for player, player drops their wands</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mLatestItemOverlapInfoBoxPosition.x" type="xs:decimal" default="0" />
			<xs:attribute name="mLatestItemOverlapInfoBoxPosition.y" type="xs:decimal" default="0" />
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="ItemRechargeNearGroundComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ItemRechargeNearGroundComponent {<br>&emsp;&emsp;&emsp;&emsp;float TEMP_TEMPY = 0; // [0, 3.5] <br>&emsp;&emsp;&emsp;&emsp;float TEMP_TEMP_TEMP = 0; // [0, 3.5] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="TEMP_TEMPY" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 3.5]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="TEMP_TEMP_TEMP" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 3.5]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="ItemStashComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ItemStashComponent {<br>&emsp;&emsp;&emsp;&emsp;int throw_openable_cooldown_frames = 30; // [0, 180] <br>&emsp;&emsp;&emsp;&emsp;bool init_children = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mNextFrameOpenable = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mFrameOpened = -1; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="throw_openable_cooldown_frames" type="xs:int" default="30">
				<xs:annotation>
					<xs:documentation>`30` - `[0, 180]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="init_children" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mNextFrameOpenable" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mFrameOpened" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="KickComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class KickComponent {<br>&emsp;&emsp;&emsp;&emsp;bool can_kick = 1; // [0, 1] e.g. telekinetic kick disables this<br>&emsp;&emsp;&emsp;&emsp;float kick_radius = 3; // [0, 3.5] <br>&emsp;&emsp;&emsp;&emsp;float telekinesis_throw_speed = 25; // [0, 1] this is here, so that STRONG_KICK -perk can affect telekinetic kick as well<br>&emsp;&emsp;&emsp;&emsp;std::string kick_entities; //  comma separated list of entities that are loaded when player kicks<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> max_force;<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> player_kickforce;<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> kick_damage; //  ( 1.f / 25.f )<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> kick_knockback; //  knockback force for entities<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="can_kick" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>e.g. telekinetic kick disables this</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="kick_radius" type="xs:decimal" default="3">
				<xs:annotation>
					<xs:documentation>`3` - `[0, 3.5]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="telekinesis_throw_speed" type="xs:decimal" default="25">
				<xs:annotation>
					<xs:documentation>`25` - `[0, 1]`</xs:documentation>
					<xs:documentation>this is here, so that STRONG_KICK -perk can affect telekinetic kick as well</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="kick_entities" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>comma separated list of entities that are loaded when player kicks</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="max_force" type="xs:decimal" default="0" />
			<xs:attribute name="player_kickforce" type="xs:decimal" default="0" />
			<xs:attribute name="kick_damage" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>( 1.f / 25.f )</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="kick_knockback" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>knockback force for entities</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="LaserEmitterComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class LaserEmitterComponent {<br>&emsp;&emsp;&emsp;&emsp;bool is_emitting = 1; // [0, 1] If 1, will emit all the time<br>&emsp;&emsp;&emsp;&emsp;int32 emit_until_frame = -1; // [0, 1] Can be used to activate a laser temporarily<br>&emsp;&emsp;&emsp;&emsp;float laser_angle_add_rad = 0; // [0, 1] Beam angle = entity angle + laser_angle_add_rad<br>&emsp;&emsp;&emsp;&emsp;ConfigLaser laser;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="is_emitting" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>If 1, will emit all the time</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="emit_until_frame" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
					<xs:documentation>Can be used to activate a laser temporarily</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="laser_angle_add_rad" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>Beam angle = entity angle + laser_angle_add_rad</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: ConfigLaser for laser -->
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="LevitationComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class LevitationComponent {<br>&emsp;&emsp;&emsp;&emsp;float radius = 20; // [1, 50] the radius in which we look for entities / bodies to float<br>&emsp;&emsp;&emsp;&emsp;float entity_force = 0.3; // [0, 1] how much do we apply the mouse movements to the entitiy<br>&emsp;&emsp;&emsp;&emsp;float box2d_force = 0.3; // [0, 1] how much do we apply the mouse movements to the entitiy<br>&emsp;&emsp;&emsp;&emsp;int effect_lifetime_frames = 600; // [1, 600] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="radius" type="xs:decimal" default="20">
				<xs:annotation>
					<xs:documentation>`20` - `[1, 50]`</xs:documentation>
					<xs:documentation>the radius in which we look for entities / bodies to float</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="entity_force" type="xs:decimal" default="0.3">
				<xs:annotation>
					<xs:documentation>`0.3` - `[0, 1]`</xs:documentation>
					<xs:documentation>how much do we apply the mouse movements to the entitiy</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="box2d_force" type="xs:decimal" default="0.3">
				<xs:annotation>
					<xs:documentation>`0.3` - `[0, 1]`</xs:documentation>
					<xs:documentation>how much do we apply the mouse movements to the entitiy</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="effect_lifetime_frames" type="xs:int" default="600">
				<xs:annotation>
					<xs:documentation>`600` - `[1, 600]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="LifetimeComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class LifetimeComponent {<br>&emsp;&emsp;&emsp;&emsp;int lifetime = -1; // [0, 1] if anything else than -1 will kill this entity when this many frames have passed<br>&emsp;&emsp;&emsp;&emsp;bool fade_sprites = 0; // [0, 1] if 1, sprites will be faded as lifetime gets lower<br>&emsp;&emsp;&emsp;&emsp;bool kill_parent = 0; // [0, 1] if 1, will kill the parent entity<br>&emsp;&emsp;&emsp;&emsp;bool kill_all_parents = 0; // [0, 1] if 1, will kill all the parents entity<br>&emsp;&emsp;&emsp;&emsp;bool serialize_duration = 0; // [0, 1] if 1, will retain kill_frame and creation_frame over serialization<br>&emsp;&emsp;&emsp;&emsp;int kill_frame_serialized = 0; // [0, 1] frame that this is killed at<br>&emsp;&emsp;&emsp;&emsp;int creation_frame_serialized = 0; // [0, 1] frame that this is killed at<br>&emsp;&emsp;&emsp;&emsp;ValueRange randomize_lifetime; //  this is added to the lifetime<br>&emsp;&emsp;&emsp;&emsp;int creation_frame = 0; // [0, 1] we'll set this to GG.GetFrameNum() when this component is created<br>&emsp;&emsp;&emsp;&emsp;int kill_frame = 0; // [0, 1] frame that this is killed at<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="lifetime" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if anything else than -1 will kill this entity when this many frames have passed</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="fade_sprites" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, sprites will be faded as lifetime gets lower</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="kill_parent" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, will kill the parent entity</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="kill_all_parents" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, will kill all the parents entity</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="serialize_duration" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, will retain kill_frame and creation_frame over serialization</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="kill_frame_serialized" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>frame that this is killed at</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="creation_frame_serialized" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>frame that this is killed at</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="randomize_lifetime.min" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>this is added to the lifetime</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="randomize_lifetime.max" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>this is added to the lifetime</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="creation_frame" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>we'll set this to GG.GetFrameNum() when this component is created</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="kill_frame" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>frame that this is killed at</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="LightComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class LightComponent {<br>&emsp;&emsp;&emsp;&emsp;bool update_properties = 0; // [0, 1] turn this on if you expect this to function like the other components<br>&emsp;&emsp;&emsp;&emsp;float radius = 0; // [0, 3000] The radius of the light in world pixels.<br>&emsp;&emsp;&emsp;&emsp;unsigned int r = 255; // [0, 255] Color red 0-255<br>&emsp;&emsp;&emsp;&emsp;unsigned int g = 178; // [0, 255] Color green 0-255<br>&emsp;&emsp;&emsp;&emsp;unsigned int b = 118; // [0, 255] Color blue 0-255<br>&emsp;&emsp;&emsp;&emsp;float offset_x = 0; // [-3000, 3000] Offset from the center of entity.<br>&emsp;&emsp;&emsp;&emsp;float offset_y = 0; // [-3000, 3000] Offset from the center of entity.<br>&emsp;&emsp;&emsp;&emsp;float fade_out_time = 0; // [0, 5] time in seconds, if not 0, this is how long this takes to die, when the component is destroyed<br>&emsp;&emsp;&emsp;&emsp;float blinking_freq = 1; // [0, 1] if less than 1, will blink randomly when rand() < blinking_freq<br>&emsp;&emsp;&emsp;&emsp;float mAlpha = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;as::Sprite* mSprite;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="update_properties" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>turn this on if you expect this to function like the other components</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="radius" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 3000]`</xs:documentation>
					<xs:documentation>The radius of the light in world pixels.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="r" type="xs:unsignedInt" default="255">
				<xs:annotation>
					<xs:documentation>`255` - `[0, 255]`</xs:documentation>
					<xs:documentation>Color red 0-255</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="g" type="xs:unsignedInt" default="178">
				<xs:annotation>
					<xs:documentation>`178` - `[0, 255]`</xs:documentation>
					<xs:documentation>Color green 0-255</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="b" type="xs:unsignedInt" default="118">
				<xs:annotation>
					<xs:documentation>`118` - `[0, 255]`</xs:documentation>
					<xs:documentation>Color blue 0-255</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="offset_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-3000, 3000]`</xs:documentation>
					<xs:documentation>Offset from the center of entity.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="offset_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-3000, 3000]`</xs:documentation>
					<xs:documentation>Offset from the center of entity.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="fade_out_time" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 5]`</xs:documentation>
					<xs:documentation>time in seconds, if not 0, this is how long this takes to die, when the component is destroyed</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="blinking_freq" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if less than 1, will blink randomly when rand() &lt; blinking_freq</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mAlpha" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: as::Sprite* for mSprite -->
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="LightningComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class LightningComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string sprite_lightning_file = "data/particles/lightning_ray.png"; // [0, 1] particle effect, from where the file is loaded that lightning is generated from<br>&emsp;&emsp;&emsp;&emsp;bool is_projectile = 0; // [0, 1] if this is true, it's a projectile lightning and looks for ProjectileComponent and uses the data from there to move it<br>&emsp;&emsp;&emsp;&emsp;int explosion_type = 1; // [0, 1] 1 = lightning trail<br>&emsp;&emsp;&emsp;&emsp;int arc_lifetime = 60; // [0, 1] remaining number of frames the arc exists<br>&emsp;&emsp;&emsp;&emsp;ConfigExplosion config_explosion;<br>&emsp;&emsp;&emsp;&emsp;vec2 mExPosition; //  stores the ex position of this entity<br>&emsp;&emsp;&emsp;&emsp;EntityID mArcTarget = 0; // [0, 1] if 'mArcTarget' points to an existing entity a lighting arc will be created between this entity and 'mArcTarget'<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="sprite_lightning_file" type="xs:string" default="data/particles/lightning_ray.png">
				<xs:annotation>
					<xs:documentation>`data/particles/lightning_ray.png` - `[0, 1]`</xs:documentation>
					<xs:documentation>particle effect, from where the file is loaded that lightning is generated from</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_projectile" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if this is true, it's a projectile lightning and looks for ProjectileComponent and uses the data from there to move it</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="explosion_type" type="xs:int" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>1 = lightning trail</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="arc_lifetime" type="xs:int" default="60">
				<xs:annotation>
					<xs:documentation>`60` - `[0, 1]`</xs:documentation>
					<xs:documentation>remaining number of frames the arc exists</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: ConfigExplosion for config_explosion -->
			<xs:attribute name="mExPosition.x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>stores the ex position of this entity</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mExPosition.y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>stores the ex position of this entity</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: EntityID for mArcTarget -->
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="LimbBossComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class LimbBossComponent {<br>&emsp;&emsp;&emsp;&emsp;int state = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mStatePrev = -1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float mMoveToPositionX = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float mMoveToPositionY = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="state" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mStatePrev" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mMoveToPositionX" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mMoveToPositionY" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="LiquidDisplacerComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class LiquidDisplacerComponent {<br>&emsp;&emsp;&emsp;&emsp;int radius = 1; // [0, 20] <br>&emsp;&emsp;&emsp;&emsp;float velocity_x = 30; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;float velocity_y = 30; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;int mPrevX = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mPrevY = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="radius" type="xs:int" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 20]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="velocity_x" type="xs:decimal" default="30">
				<xs:annotation>
					<xs:documentation>`30` - `[0, 100]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="velocity_y" type="xs:decimal" default="30">
				<xs:annotation>
					<xs:documentation>`30` - `[0, 100]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mPrevX" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mPrevY" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="LoadEntitiesComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class LoadEntitiesComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string entity_file; //  path to the entity file we should load<br>&emsp;&emsp;&emsp;&emsp;bool kill_entity = 1; // [0, 1] if 1, we kill our entity when it is created<br>&emsp;&emsp;&emsp;&emsp;int timeout_frames = 0; // [0, 180] for timer<br>&emsp;&emsp;&emsp;&emsp;int mTimerTriggerFrame = -1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;ValueRangeInt count; //  how many entities should be loaded (random range)<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="entity_file" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>path to the entity file we should load</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="kill_entity" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, we kill our entity when it is created</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="timeout_frames" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 180]`</xs:documentation>
					<xs:documentation>for timer</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mTimerTriggerFrame" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="count.min" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>how many entities should be loaded (random range)</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="count.max" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>how many entities should be loaded (random range)</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="LocationMarkerComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class LocationMarkerComponent {<br>&emsp;&emsp;&emsp;&emsp;int id = 0; // [0, 3] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="id" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 3]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="LooseGroundComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class LooseGroundComponent {<br>&emsp;&emsp;&emsp;&emsp;float probability = 0; // [0, 1] how often do we do this... shoots a ray in random direction and does the loosening<br>&emsp;&emsp;&emsp;&emsp;int max_durability = 2147483647; // [0, 1] if material durability > max_durability, it is not loosened<br>&emsp;&emsp;&emsp;&emsp;float max_distance = 256; // [0, 1] how far raytraces to find things to loosen up<br>&emsp;&emsp;&emsp;&emsp;float max_angle = 1.57; // [0, 1] how much raytraces go to different directions around the up-vector. pi=full circle<br>&emsp;&emsp;&emsp;&emsp;int min_radius = 3; // [0, 1] the minimum radius of our loosening of pixels<br>&emsp;&emsp;&emsp;&emsp;int max_radius = 8; // [0, 1] the maximum radius of our loosening of pixels<br>&emsp;&emsp;&emsp;&emsp;float chunk_probability = 0; // [0, 1] if > 0, will drop box2d chunks of the ceiling<br>&emsp;&emsp;&emsp;&emsp;float chunk_max_angle = 0.7; // [0, 1] how much raytraces go to different directions around the up-vector. pi=full circle<br>&emsp;&emsp;&emsp;&emsp;int chunk_count = -1; // [0, 1] how many chunks are we allowed to do, -1 = infinite<br>&emsp;&emsp;&emsp;&emsp;std::string collapse_images = "data/procedural_gfx/collapse_big/$[0-14].png"; // [0, 1] loads these files randomly to do the collapse shapes<br>&emsp;&emsp;&emsp;&emsp;int chunk_material = 0; // [0, 1] String name of chunk material<br>&emsp;&emsp;&emsp;&emsp;int mChunkCount = 0; // [0, 1] how many chunks are we allowed to do, -1 = infinite<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="probability" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>how often do we do this... shoots a ray in random direction and does the loosening</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="max_durability" type="xs:int" default="2147483647">
				<xs:annotation>
					<xs:documentation>`2147483647` - `[0, 1]`</xs:documentation>
					<xs:documentation>if material durability &gt; max_durability, it is not loosened</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="max_distance" type="xs:decimal" default="256">
				<xs:annotation>
					<xs:documentation>`256` - `[0, 1]`</xs:documentation>
					<xs:documentation>how far raytraces to find things to loosen up</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="max_angle" type="xs:decimal" default="1.57">
				<xs:annotation>
					<xs:documentation>`1.57` - `[0, 1]`</xs:documentation>
					<xs:documentation>how much raytraces go to different directions around the up-vector. pi=full circle</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="min_radius" type="xs:int" default="3">
				<xs:annotation>
					<xs:documentation>`3` - `[0, 1]`</xs:documentation>
					<xs:documentation>the minimum radius of our loosening of pixels</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="max_radius" type="xs:int" default="8">
				<xs:annotation>
					<xs:documentation>`8` - `[0, 1]`</xs:documentation>
					<xs:documentation>the maximum radius of our loosening of pixels</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="chunk_probability" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if &gt; 0, will drop box2d chunks of the ceiling</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="chunk_max_angle" type="xs:decimal" default="0.7">
				<xs:annotation>
					<xs:documentation>`0.7` - `[0, 1]`</xs:documentation>
					<xs:documentation>how much raytraces go to different directions around the up-vector. pi=full circle</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="chunk_count" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
					<xs:documentation>how many chunks are we allowed to do, -1 = infinite</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="collapse_images" type="xs:string" default="data/procedural_gfx/collapse_big/$[0-14].png">
				<xs:annotation>
					<xs:documentation>`data/procedural_gfx/collapse_big/$[0-14].png` - `[0, 1]`</xs:documentation>
					<xs:documentation>loads these files randomly to do the collapse shapes</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="chunk_material" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>String name of chunk material</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mChunkCount" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>how many chunks are we allowed to do, -1 = infinite</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="LuaComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class LuaComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string script_source_file;<br>&emsp;&emsp;&emsp;&emsp;bool execute_on_added = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool execute_on_removed = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int execute_every_n_frame = 1; // [1, 150] 1 = execute every frame. 2 = execute every second frame. 3 = execute every third frame and so on. -1 = execute only on add/remove/event<br>&emsp;&emsp;&emsp;&emsp;int execute_times = 0; // [0, 1] How many times should the script be executed? < 1 means infinite<br>&emsp;&emsp;&emsp;&emsp;int limit_how_many_times_per_frame = -1; // [0, 1] -1 = infinite. Use this to limit how many times this can be executed per frame. Currently only used to limit script_shot from being executed forever.<br>&emsp;&emsp;&emsp;&emsp;int limit_to_every_n_frame = -1; // [0, 1] -1 = no limit. Currently only used to limit script_shot from being executed every frame.<br>&emsp;&emsp;&emsp;&emsp;bool limit_all_callbacks = 0; // [0, 1] NOTE( Petri ): 19.8.2023 - by default limit_how_many_times_per_frame and limit_to_every_n_frame only works for script_shot. If this is set to true, will limit all callbacks. Also note that this limit is shared within this component. So if this is true and both script_shot and script_damage_received and both are called within limit_to_every_n_frame frames, only one of them will be called.<br>&emsp;&emsp;&emsp;&emsp;bool remove_after_executed = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool enable_coroutines = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool call_init_function = 0; // [0, 1]  if 1, calls function init( entity_id:int ) after running the code in the file scope of script_source_file along with all mod appends. Does nothing if execute_on_added is 0<br>&emsp;&emsp;&emsp;&emsp;std::string script_enabled_changed; //  if set, calls function 'enabled_changed( entity_id:int, is_enabled:bool )' when the IsEnabled status of this LuaComponent is changed<br>&emsp;&emsp;&emsp;&emsp;std::string script_damage_received; //  if set, calls function 'damage_received( damage:number, message:string, entity_thats_responsible:int, is_fatal:bool, projectile_thats_responsible:int )' when we receive a message about damage (Message_DamageReceived)<br>&emsp;&emsp;&emsp;&emsp;std::string script_damage_about_to_be_received; //  if set, calls function 'damage_about_to_be_received( damage:number, x:number, y:number, entity_thats_responsible:int, critical_hit_chance:int )' when we receive a message (Message_DamageAboutToBeReceived) -> new_damage:number,new_critical_hit_chance:int<br>&emsp;&emsp;&emsp;&emsp;std::string script_item_picked_up; //  if set, calls function 'item_pickup( int entity_item, int entity_pickupper, string item_name )' when message 'Message_ItemPickUp' is called<br>&emsp;&emsp;&emsp;&emsp;std::string script_shot; //  if set, calls function 'shot( projectile_entity_id )' when we receive Message_Shot<br>&emsp;&emsp;&emsp;&emsp;std::string script_collision_trigger_hit; //  if set, calls function 'collision_trigger( colliding_entity_id )' when we receive Message_CollisionTriggerHit<br>&emsp;&emsp;&emsp;&emsp;std::string script_collision_trigger_timer_finished; //  if set, calls function 'collision_trigger_timer_finished()' when we receive Message_CollisionTriggerTimerFinished<br>&emsp;&emsp;&emsp;&emsp;std::string script_physics_body_modified; //  if set, calls function 'physics_body_modified( is_destroyed )' when physics body has been modified<br>&emsp;&emsp;&emsp;&emsp;std::string script_pressure_plate_change; //  if set, calls function 'pressure_plate_change( new_state )' when PressurePlateComponent decides that things have change<br>&emsp;&emsp;&emsp;&emsp;std::string script_inhaled_material; //  if set, calls function 'inhaled_material( material_name, count )' once per second for each inhaled material<br>&emsp;&emsp;&emsp;&emsp;std::string script_death; //  if set, calls function 'death( int damage_type_bit_field, string damage_message, int entity_thats_responsible, bool drop_items )' when we receive message Message_Death<br>&emsp;&emsp;&emsp;&emsp;std::string script_throw_item; //  if set, calls function 'throw_item( from_x, from_y, to_x, to_y )' when we receive message Message_ThrowItem<br>&emsp;&emsp;&emsp;&emsp;std::string script_material_area_checker_failed; //  if set, calls function 'material_area_checker_failed( pos_x, pos_y, )' when we receive message Message_MaterialAreaCheckerFailed<br>&emsp;&emsp;&emsp;&emsp;std::string script_material_area_checker_success; //  if set, calls function 'material_area_checker_success( pos_x, pos_y, )' when we receive message Message_MaterialAreaCheckerSuccess<br>&emsp;&emsp;&emsp;&emsp;std::string script_electricity_receiver_switched; //  if set, calls function 'electricity_receiver_switched( bool is_electrified )' when we receive message Message_ElectricityReceiverSwitched<br>&emsp;&emsp;&emsp;&emsp;std::string script_electricity_receiver_electrified; //  if set, calls function 'electricity_receiver_electrified()' when we receive message Message_ElectricityReceiverElectrified<br>&emsp;&emsp;&emsp;&emsp;std::string script_kick; //  if set, calls function 'kick( entity_who_kicked )' when we receive message Message_Kick<br>&emsp;&emsp;&emsp;&emsp;std::string script_interacting; //  if set, calls function 'interacting( entity_who_interacted, entity_interacted, interactable_name )' when we receive message Message_Interaction<br>&emsp;&emsp;&emsp;&emsp;std::string script_audio_event_dead; //  if set, calls function 'audio_event_dead( bank_file, event_root )' when we receive message Message_AudioEventDead<br>&emsp;&emsp;&emsp;&emsp;std::string script_wand_fired; //  if set, calls function 'wand_fired( gun_entity_id )' when we receive Message_WandFired<br>&emsp;&emsp;&emsp;&emsp;std::string script_teleported; //  if set, calls function 'teleported( from_x, from_y, to_x, to_y, bool portal_teleport )' when we receive Message_Teleported<br>&emsp;&emsp;&emsp;&emsp;std::string script_portal_teleport_used; //  if set, calls function 'portal_teleport_used( entity_that_was_teleported, from_x, from_y, to_x, to_y )' when we receive Message_PortalTeleportUsed<br>&emsp;&emsp;&emsp;&emsp;std::string script_polymorphing_to; //  if set, calls function 'polymorphing_to( string_entity_we_are_about_to_polymorph_to )' when we receive Message_PolymorphingTo<br>&emsp;&emsp;&emsp;&emsp;std::string script_biome_entered; //  if set, calls function 'biome_entered( string_biome_name, string_biome_old_name )' when this entity changes biomes. Requires BiomeTrackerComponent<br>&emsp;&emsp;&emsp;&emsp;int mLastExecutionFrame = -1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mTimesExecutedThisFrame = 0; // [0, 1] tracks how many times we've executed this frame. This will linger on and store the old value of the old frames. Used internally.<br>&emsp;&emsp;&emsp;&emsp;bool mModAppendsDone = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;LUA_VM_TYPE::Enum vm_type; //  Do we share a single Lua virtual machine for everyone who runs 'script_source_file' ('SHARED_BY_MANY_COMPONENTS'), create one VM per one LuaComponent and reuse the VM in case the component runs the script multiple times ('ONE_PER_COMPONENT_INSTANCE'), or create a new VM every time the script is executed ('CREATE_NEW_EVERY_EXECUTION', deprecated)?<br>&emsp;&emsp;&emsp;&emsp;int mNextExecutionTime = -1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mTimesExecuted = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;LuaManager* mLuaManager;<br>&emsp;&emsp;&emsp;&emsp;ValueMap mPersistentValues;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="script_source_file" type="xs:string" default="" />
			<xs:attribute name="execute_on_added" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="execute_on_removed" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="execute_every_n_frame" type="xs:int" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[1, 150]`</xs:documentation>
					<xs:documentation>1 = execute every frame. 2 = execute every second frame. 3 = execute every third frame and so on. -1 = execute only on add/remove/event</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="execute_times" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>How many times should the script be executed? &lt; 1 means infinite</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="limit_how_many_times_per_frame" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
					<xs:documentation>-1 = infinite. Use this to limit how many times this can be executed per frame. Currently only used to limit script_shot from being executed forever.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="limit_to_every_n_frame" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
					<xs:documentation>-1 = no limit. Currently only used to limit script_shot from being executed every frame.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="limit_all_callbacks" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>NOTE( Petri ): 19.8.2023 - by default limit_how_many_times_per_frame and limit_to_every_n_frame only works for script_shot. If this is set to true, will limit all callbacks. Also note that this limit is shared within this component. So if this is true and both script_shot and script_damage_received and both are called within limit_to_every_n_frame frames, only one of them will be called.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="remove_after_executed" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="enable_coroutines" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="call_init_function" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation> if 1, calls function init( entity_id:int ) after running the code in the file scope of script_source_file along with all mod appends. Does nothing if execute_on_added is 0</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="script_enabled_changed" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>if set, calls function 'enabled_changed( entity_id:int, is_enabled:bool )' when the IsEnabled status of this LuaComponent is changed</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="script_damage_received" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>if set, calls function 'damage_received( damage:number, message:string, entity_thats_responsible:int, is_fatal:bool, projectile_thats_responsible:int )' when we receive a message about damage (Message_DamageReceived)</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="script_damage_about_to_be_received" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>if set, calls function 'damage_about_to_be_received( damage:number, x:number, y:number, entity_thats_responsible:int, critical_hit_chance:int )' when we receive a message (Message_DamageAboutToBeReceived) -&gt; new_damage:number,new_critical_hit_chance:int</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="script_item_picked_up" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>if set, calls function 'item_pickup( int entity_item, int entity_pickupper, string item_name )' when message 'Message_ItemPickUp' is called</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="script_shot" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>if set, calls function 'shot( projectile_entity_id )' when we receive Message_Shot</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="script_collision_trigger_hit" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>if set, calls function 'collision_trigger( colliding_entity_id )' when we receive Message_CollisionTriggerHit</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="script_collision_trigger_timer_finished" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>if set, calls function 'collision_trigger_timer_finished()' when we receive Message_CollisionTriggerTimerFinished</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="script_physics_body_modified" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>if set, calls function 'physics_body_modified( is_destroyed )' when physics body has been modified</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="script_pressure_plate_change" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>if set, calls function 'pressure_plate_change( new_state )' when PressurePlateComponent decides that things have change</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="script_inhaled_material" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>if set, calls function 'inhaled_material( material_name, count )' once per second for each inhaled material</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="script_death" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>if set, calls function 'death( int damage_type_bit_field, string damage_message, int entity_thats_responsible, bool drop_items )' when we receive message Message_Death</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="script_throw_item" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>if set, calls function 'throw_item( from_x, from_y, to_x, to_y )' when we receive message Message_ThrowItem</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="script_material_area_checker_failed" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>if set, calls function 'material_area_checker_failed( pos_x, pos_y, )' when we receive message Message_MaterialAreaCheckerFailed</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="script_material_area_checker_success" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>if set, calls function 'material_area_checker_success( pos_x, pos_y, )' when we receive message Message_MaterialAreaCheckerSuccess</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="script_electricity_receiver_switched" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>if set, calls function 'electricity_receiver_switched( bool is_electrified )' when we receive message Message_ElectricityReceiverSwitched</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="script_electricity_receiver_electrified" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>if set, calls function 'electricity_receiver_electrified()' when we receive message Message_ElectricityReceiverElectrified</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="script_kick" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>if set, calls function 'kick( entity_who_kicked )' when we receive message Message_Kick</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="script_interacting" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>if set, calls function 'interacting( entity_who_interacted, entity_interacted, interactable_name )' when we receive message Message_Interaction</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="script_audio_event_dead" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>if set, calls function 'audio_event_dead( bank_file, event_root )' when we receive message Message_AudioEventDead</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="script_wand_fired" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>if set, calls function 'wand_fired( gun_entity_id )' when we receive Message_WandFired</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="script_teleported" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>if set, calls function 'teleported( from_x, from_y, to_x, to_y, bool portal_teleport )' when we receive Message_Teleported</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="script_portal_teleport_used" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>if set, calls function 'portal_teleport_used( entity_that_was_teleported, from_x, from_y, to_x, to_y )' when we receive Message_PortalTeleportUsed</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="script_polymorphing_to" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>if set, calls function 'polymorphing_to( string_entity_we_are_about_to_polymorph_to )' when we receive Message_PolymorphingTo</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="script_biome_entered" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>if set, calls function 'biome_entered( string_biome_name, string_biome_old_name )' when this entity changes biomes. Requires BiomeTrackerComponent</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mLastExecutionFrame" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mTimesExecutedThisFrame" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>tracks how many times we've executed this frame. This will linger on and store the old value of the old frames. Used internally.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mModAppendsDone" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: LUA_VM_TYPE::Enum for vm_type -->
			<xs:attribute name="mNextExecutionTime" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mTimesExecuted" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: LuaManager* for mLuaManager -->
				<!-- Some Unknown Type: ValueMap for mPersistentValues -->
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="MagicConvertMaterialComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class MagicConvertMaterialComponent {<br>&emsp;&emsp;&emsp;&emsp;int radius = 256; // [0, 512] <br>&emsp;&emsp;&emsp;&emsp;int min_radius = 0; // [0, 512] allows for convert to happen from x pixels from the center<br>&emsp;&emsp;&emsp;&emsp;bool is_circle = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int steps_per_frame = 10; // [0, 512] <br>&emsp;&emsp;&emsp;&emsp;std::string from_material_tag; //  the tag of material, e.g. [liquid]<br>&emsp;&emsp;&emsp;&emsp;bool from_any_material = 0; // [0, 1] if 1, converts any cells of any material to 'to_materia'<br>&emsp;&emsp;&emsp;&emsp;bool clean_stains = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool extinguish_fire = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int fan_the_flames = 0; // [0, 1] if > 0, will call UpdateFire() fan_the_flames times<br>&emsp;&emsp;&emsp;&emsp;int32 temperature_reaction_temp = 0; // [0, 1] if != 0, will use the 'cold_freezes_to_materials' and 'warmth_melts_to_materials' in CellData to convert cells different materials<br>&emsp;&emsp;&emsp;&emsp;int ignite_materials = 0; // [0, 1] if > 0, will call Ignite() with ingite_materials as probability_of_fire<br>&emsp;&emsp;&emsp;&emsp;bool loop = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool kill_when_finished = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool convert_entities = 0; // [0, 1] if 1, kills entities with a damagemodel and converts them to 'to_material'<br>&emsp;&emsp;&emsp;&emsp;bool stain_frozen = 0; // [0, 1] petri hax<br>&emsp;&emsp;&emsp;&emsp;float reaction_audio_amount = 0; // [0, 1] if > 0, will generate chemical reaction audio at converted cells<br>&emsp;&emsp;&emsp;&emsp;bool convert_same_material = 1; // [0, 1] 9.10.2020 - added this because at the end this caused the 'white ring' to appear, set it to false if you don't want constant whiteout<br>&emsp;&emsp;&emsp;&emsp;std::string from_material_array;<br>&emsp;&emsp;&emsp;&emsp;std::string to_material_array;<br>&emsp;&emsp;&emsp;&emsp;int mRadius = 0; // [0, 512] <br>&emsp;&emsp;&emsp;&emsp;int from_material = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int to_material = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mUseArrays = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;std::vector<int> mFromMaterialArray;<br>&emsp;&emsp;&emsp;&emsp;std::vector<int> mToMaterialArray;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="radius" type="xs:int" default="256">
				<xs:annotation>
					<xs:documentation>`256` - `[0, 512]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="min_radius" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 512]`</xs:documentation>
					<xs:documentation>allows for convert to happen from x pixels from the center</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_circle" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="steps_per_frame" type="xs:int" default="10">
				<xs:annotation>
					<xs:documentation>`10` - `[0, 512]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="from_material_tag" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>the tag of material, e.g. [liquid]</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="from_any_material" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, converts any cells of any material to 'to_materia'</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="clean_stains" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="extinguish_fire" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="fan_the_flames" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if &gt; 0, will call UpdateFire() fan_the_flames times</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="temperature_reaction_temp" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if != 0, will use the 'cold_freezes_to_materials' and 'warmth_melts_to_materials' in CellData to convert cells different materials</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ignite_materials" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if &gt; 0, will call Ignite() with ingite_materials as probability_of_fire</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="loop" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="kill_when_finished" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="convert_entities" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, kills entities with a damagemodel and converts them to 'to_material'</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="stain_frozen" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>petri hax</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="reaction_audio_amount" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if &gt; 0, will generate chemical reaction audio at converted cells</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="convert_same_material" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>9.10.2020 - added this because at the end this caused the 'white ring' to appear, set it to false if you don't want constant whiteout</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="from_material_array" type="xs:string" default="" />
			<xs:attribute name="to_material_array" type="xs:string" default="" />
			<xs:attribute name="mRadius" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 512]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="from_material" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="to_material" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mUseArrays" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: std::vector<int> for mFromMaterialArray -->
				<!-- Some Unknown Type: std::vector<int> for mToMaterialArray -->
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="MagicXRayComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class MagicXRayComponent {<br>&emsp;&emsp;&emsp;&emsp;int radius = 256; // [0, 512] <br>&emsp;&emsp;&emsp;&emsp;int steps_per_frame = 10; // [0, 512] <br>&emsp;&emsp;&emsp;&emsp;int mStep = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mRadius = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="radius" type="xs:int" default="256">
				<xs:annotation>
					<xs:documentation>`256` - `[0, 512]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="steps_per_frame" type="xs:int" default="10">
				<xs:annotation>
					<xs:documentation>`10` - `[0, 512]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mStep" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mRadius" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="ManaReloaderComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ManaReloaderComponent {<br><br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">

			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="MaterialAreaCheckerComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class MaterialAreaCheckerComponent {<br>&emsp;&emsp;&emsp;&emsp;int update_every_x_frame = 0; // [0, 1] if something other than 0 or 1, will only update_every_x_frames <br>&emsp;&emsp;&emsp;&emsp;bool look_for_failure = 1; // [0, 1] if true, will send message Message_MaterialAreaCheckerFailed if the material doesn't exist. If false, will send a message Message_MaterialAreaCheckerSuccess if the aabb is full of material and material2<br>&emsp;&emsp;&emsp;&emsp;int count_min = 0; // [0, 1] If > 0, and look_for_failure=0, will send message if material count exceeds this number of cells<br>&emsp;&emsp;&emsp;&emsp;bool always_check_fullness = 0; // [0, 1] if 1, and look_for_failure=0, will always check the whole area for cells<br>&emsp;&emsp;&emsp;&emsp;bool kill_after_message = 1; // [0, 1] will kill this entity after sending the message<br>&emsp;&emsp;&emsp;&emsp;types::aabb area_aabb; //  aabb offset, we check that this aabb contains only material<br>&emsp;&emsp;&emsp;&emsp;int material = 0; // [0, 1] String name of material that we check that the aabb contains<br>&emsp;&emsp;&emsp;&emsp;int material2 = 0; // [0, 1] String name of material2 that we check that the aabb contains<br>&emsp;&emsp;&emsp;&emsp;int mPosition = 0; // [0, 1] keeps track where we are<br>&emsp;&emsp;&emsp;&emsp;int mLastFrameChecked = 0; // [0, 1] keeps track of how often we've checked<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="update_every_x_frame" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if something other than 0 or 1, will only update_every_x_frames </xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="look_for_failure" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, will send message Message_MaterialAreaCheckerFailed if the material doesn't exist. If false, will send a message Message_MaterialAreaCheckerSuccess if the aabb is full of material and material2</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="count_min" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>If &gt; 0, and look_for_failure=0, will send message if material count exceeds this number of cells</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="always_check_fullness" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, and look_for_failure=0, will always check the whole area for cells</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="kill_after_message" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>will kill this entity after sending the message</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="area_aabb.min_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>aabb offset, we check that this aabb contains only material</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="area_aabb.min_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>aabb offset, we check that this aabb contains only material</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="area_aabb.max_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>aabb offset, we check that this aabb contains only material</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="area_aabb.max_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>aabb offset, we check that this aabb contains only material</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="material" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>String name of material that we check that the aabb contains</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="material2" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>String name of material2 that we check that the aabb contains</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mPosition" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>keeps track where we are</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mLastFrameChecked" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>keeps track of how often we've checked</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="MaterialInventoryComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class MaterialInventoryComponent {<br>&emsp;&emsp;&emsp;&emsp;bool drop_as_item = 1; // [0, 1] if true, drops a bag that the player can big up<br>&emsp;&emsp;&emsp;&emsp;bool on_death_spill = 0; // [0, 1] if true, on the death this will explode all the materials into air<br>&emsp;&emsp;&emsp;&emsp;bool leak_gently = 1; // [0, 1] NOTE( Petri ): 11.8.2023 - set this to false for old style leaky hidden piles situation.<br>&emsp;&emsp;&emsp;&emsp;float leak_on_damage_percent = 0; // [0, 1] if higher than 0 then it might leak when projectile damage happens<br>&emsp;&emsp;&emsp;&emsp;float leak_pressure_min = 0.7; // [0, 1] leak pressure coefficient<br>&emsp;&emsp;&emsp;&emsp;float leak_pressure_max = 1.1; // [0, 1] leak pressure coefficient<br>&emsp;&emsp;&emsp;&emsp;float min_damage_to_leak = 0.09; // [0, 1] the minimum damage that has to be done in order for a leak to occur<br>&emsp;&emsp;&emsp;&emsp;float b2_force_on_leak = 0; // [0, 10] if 0, nothing happens, elsewise will add a b2 force to the particleemitter which will push the b2body<br>&emsp;&emsp;&emsp;&emsp;float death_throw_particle_velocity_coeff = 1; // [0, 1] how far do we throw material particles on death?<br>&emsp;&emsp;&emsp;&emsp;bool kill_when_empty = 0; // [0, 1] if set, will send MessageDeath when materials are drained<br>&emsp;&emsp;&emsp;&emsp;bool halftime_materials = 0; // [0, 1] if true, will multiply the materials with the given halftimes<br>&emsp;&emsp;&emsp;&emsp;int do_reactions = 0; // [0, 100] NOTE( Petri ): 15.8.2023 - if > 0, will do CellReactions between the materials. Value is the percent chance of how often. 100 = every frame <br>&emsp;&emsp;&emsp;&emsp;bool do_reactions_explosions = 0; // [0, 1] requires do_reactions > 0 - are we allowed to do reaction explosions?<br>&emsp;&emsp;&emsp;&emsp;bool do_reactions_entities = 0; // [0, 1] requires do_reactions > 0 - are we allowed to load entities when doing reactions?<br>&emsp;&emsp;&emsp;&emsp;int reaction_speed = 5; // [0, 1] Note( Petri ): 17.8.2023 - how 'fast' do we let reactions happen. How many pixels of material do we convert at one time (5-10) seems like a nice speed.<br>&emsp;&emsp;&emsp;&emsp;bool reactions_shaking_speeds_up = 1; // [0, 1] Note( Petri ): 17.8.2023 - added the ability of shaking the bottle to cause reactions to happen quicker. <br>&emsp;&emsp;&emsp;&emsp;double max_capacity = -1; // [0, 1] how much materials we can store in total. < 0 = infinite<br>&emsp;&emsp;&emsp;&emsp;float audio_collision_size_modifier_amount = 0; // [0, 1] if > 0, 'fullness of this container' * 'audio_collision_size_modifier_amount' is added to collision audio event size<br>&emsp;&emsp;&emsp;&emsp;int32 last_frame_drank = -100; // [0, 1] last frame someone ingested from this via IngestionSystem<br>&emsp;&emsp;&emsp;&emsp;MATERIAL_VEC_DOUBLES count_per_material_type; //  Count of each material indexed by material type ID<br>&emsp;&emsp;&emsp;&emsp;bool is_death_handled = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;vec2 ex_position; //  used to figure out movement velocity<br>&emsp;&emsp;&emsp;&emsp;float ex_angle = 0; // [0, 1] used to figure out movement velocity<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="drop_as_item" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, drops a bag that the player can big up</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="on_death_spill" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, on the death this will explode all the materials into air</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="leak_gently" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>NOTE( Petri ): 11.8.2023 - set this to false for old style leaky hidden piles situation.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="leak_on_damage_percent" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if higher than 0 then it might leak when projectile damage happens</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="leak_pressure_min" type="xs:decimal" default="0.7">
				<xs:annotation>
					<xs:documentation>`0.7` - `[0, 1]`</xs:documentation>
					<xs:documentation>leak pressure coefficient</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="leak_pressure_max" type="xs:decimal" default="1.1">
				<xs:annotation>
					<xs:documentation>`1.1` - `[0, 1]`</xs:documentation>
					<xs:documentation>leak pressure coefficient</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="min_damage_to_leak" type="xs:decimal" default="0.09">
				<xs:annotation>
					<xs:documentation>`0.09` - `[0, 1]`</xs:documentation>
					<xs:documentation>the minimum damage that has to be done in order for a leak to occur</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="b2_force_on_leak" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 10]`</xs:documentation>
					<xs:documentation>if 0, nothing happens, elsewise will add a b2 force to the particleemitter which will push the b2body</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="death_throw_particle_velocity_coeff" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>how far do we throw material particles on death?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="kill_when_empty" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if set, will send MessageDeath when materials are drained</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="halftime_materials" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, will multiply the materials with the given halftimes</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="do_reactions" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 100]`</xs:documentation>
					<xs:documentation>NOTE( Petri ): 15.8.2023 - if &gt; 0, will do CellReactions between the materials. Value is the percent chance of how often. 100 = every frame </xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="do_reactions_explosions" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>requires do_reactions &gt; 0 - are we allowed to do reaction explosions?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="do_reactions_entities" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>requires do_reactions &gt; 0 - are we allowed to load entities when doing reactions?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="reaction_speed" type="xs:int" default="5">
				<xs:annotation>
					<xs:documentation>`5` - `[0, 1]`</xs:documentation>
					<xs:documentation>Note( Petri ): 17.8.2023 - how 'fast' do we let reactions happen. How many pixels of material do we convert at one time (5-10) seems like a nice speed.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="reactions_shaking_speeds_up" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>Note( Petri ): 17.8.2023 - added the ability of shaking the bottle to cause reactions to happen quicker. </xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="max_capacity" type="xs:decimal" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
					<xs:documentation>how much materials we can store in total. &lt; 0 = infinite</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="audio_collision_size_modifier_amount" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if &gt; 0, 'fullness of this container' * 'audio_collision_size_modifier_amount' is added to collision audio event size</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="last_frame_drank" type="xs:int" default="-100">
				<xs:annotation>
					<xs:documentation>`-100` - `[0, 1]`</xs:documentation>
					<xs:documentation>last frame someone ingested from this via IngestionSystem</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: MATERIAL_VEC_DOUBLES for count_per_material_type -->
			<xs:attribute name="is_death_handled" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ex_position.x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>used to figure out movement velocity</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ex_position.y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>used to figure out movement velocity</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ex_angle" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>used to figure out movement velocity</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="MaterialSeaSpawnerComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class MaterialSeaSpawnerComponent {<br>&emsp;&emsp;&emsp;&emsp;int speed = 10; // [1, 100] How many pixels to cover per one direction per one frame<br>&emsp;&emsp;&emsp;&emsp;float sine_wavelength = 10; // [0, 2] Parameters for sine wave that affects material spawn pattern<br>&emsp;&emsp;&emsp;&emsp;float sine_amplitude = 5; // [0, 2] Parameters for sine wave that affects material spawn pattern<br>&emsp;&emsp;&emsp;&emsp;double noise_scale = 0.1; // [0, 1] Parameters for noise that affects material spawn pattern<br>&emsp;&emsp;&emsp;&emsp;double noise_threshold = 0.05; // [0, 1] Parameters for noise that affects material spawn pattern<br>&emsp;&emsp;&emsp;&emsp;int m_position = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int frames_run = 0; // [0, 1] to help keep the effect<br>&emsp;&emsp;&emsp;&emsp;int material = 0; // [0, 1] String name of material this creates<br>&emsp;&emsp;&emsp;&emsp;ivec2 size; //  Size of the area to cover<br>&emsp;&emsp;&emsp;&emsp;ivec2 offset; //  Offset of the center of the area to cover<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="speed" type="xs:int" default="10">
				<xs:annotation>
					<xs:documentation>`10` - `[1, 100]`</xs:documentation>
					<xs:documentation>How many pixels to cover per one direction per one frame</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="sine_wavelength" type="xs:decimal" default="10">
				<xs:annotation>
					<xs:documentation>`10` - `[0, 2]`</xs:documentation>
					<xs:documentation>Parameters for sine wave that affects material spawn pattern</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="sine_amplitude" type="xs:decimal" default="5">
				<xs:annotation>
					<xs:documentation>`5` - `[0, 2]`</xs:documentation>
					<xs:documentation>Parameters for sine wave that affects material spawn pattern</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="noise_scale" type="xs:decimal" default="0.1">
				<xs:annotation>
					<xs:documentation>`0.1` - `[0, 1]`</xs:documentation>
					<xs:documentation>Parameters for noise that affects material spawn pattern</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="noise_threshold" type="xs:decimal" default="0.05">
				<xs:annotation>
					<xs:documentation>`0.05` - `[0, 1]`</xs:documentation>
					<xs:documentation>Parameters for noise that affects material spawn pattern</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="m_position" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="frames_run" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>to help keep the effect</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="material" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>String name of material this creates</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="size.x" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>Size of the area to cover</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="size.y" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>Size of the area to cover</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="offset.x" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>Offset of the center of the area to cover</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="offset.y" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>Offset of the center of the area to cover</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="MaterialSuckerComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class MaterialSuckerComponent {<br>&emsp;&emsp;&emsp;&emsp;int material_type = 0; // [0, 3] 0 = liquid, 1 = sand, 2 = gas (arbitary order)<br>&emsp;&emsp;&emsp;&emsp;int barrel_size = 50; // [0, 1024] how many pixels can we suck up<br>&emsp;&emsp;&emsp;&emsp;int num_cells_sucked_per_frame = 1; // [0, 5] How many cells at max can we suck per frame?<br>&emsp;&emsp;&emsp;&emsp;bool set_projectile_to_liquid = 0; // [0, 1] if set, will set the projectile what ever we're sucking...?<br>&emsp;&emsp;&emsp;&emsp;int last_material_id = 0; // [0, 1] hax... this is set if we use set_projectile_to_liquid<br>&emsp;&emsp;&emsp;&emsp;bool suck_gold = 0; // [0, 1] if set will just suck gold and update wallet<br>&emsp;&emsp;&emsp;&emsp;bool suck_health = 0; // [0, 1] if set will just suck healthium material and add 1 hp every sucked healthium<br>&emsp;&emsp;&emsp;&emsp;bool suck_static_materials = 0; // [0, 1] will suck static materials from the world<br>&emsp;&emsp;&emsp;&emsp;std::string suck_tag; //  if set, will only suck materials with this tag. NOTE, will also require the correct material_type to be set<br>&emsp;&emsp;&emsp;&emsp;int mAmountUsed = 0; // [0, 1] how full are we<br>&emsp;&emsp;&emsp;&emsp;types::iaabb randomized_position; //  random offset for pos, where we look for pixels<br>&emsp;&emsp;&emsp;&emsp;int mGoldAccumulator = 0; // [0, 1] accumulates amount of gold picked during consecutive frames<br>&emsp;&emsp;&emsp;&emsp;int mLastFramePickedGold = -2; // [0, 1] last frame we picked gold<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="material_type" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 3]`</xs:documentation>
					<xs:documentation>0 = liquid, 1 = sand, 2 = gas (arbitary order)</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="barrel_size" type="xs:int" default="50">
				<xs:annotation>
					<xs:documentation>`50` - `[0, 1024]`</xs:documentation>
					<xs:documentation>how many pixels can we suck up</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="num_cells_sucked_per_frame" type="xs:int" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 5]`</xs:documentation>
					<xs:documentation>How many cells at max can we suck per frame?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="set_projectile_to_liquid" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if set, will set the projectile what ever we're sucking...?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="last_material_id" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>hax... this is set if we use set_projectile_to_liquid</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="suck_gold" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if set will just suck gold and update wallet</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="suck_health" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if set will just suck healthium material and add 1 hp every sucked healthium</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="suck_static_materials" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>will suck static materials from the world</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="suck_tag" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>if set, will only suck materials with this tag. NOTE, will also require the correct material_type to be set</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mAmountUsed" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>how full are we</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="randomized_position.min_x" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>random offset for pos, where we look for pixels</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="randomized_position.min_y" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>random offset for pos, where we look for pixels</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="randomized_position.max_x" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>random offset for pos, where we look for pixels</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="randomized_position.max_y" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>random offset for pos, where we look for pixels</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mGoldAccumulator" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>accumulates amount of gold picked during consecutive frames</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mLastFramePickedGold" type="xs:int" default="-2">
				<xs:annotation>
					<xs:documentation>`-2` - `[0, 1]`</xs:documentation>
					<xs:documentation>last frame we picked gold</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="MoveToSurfaceOnCreateComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class MoveToSurfaceOnCreateComponent {<br>&emsp;&emsp;&emsp;&emsp;float lookup_radius = 64; // [0, 64] <br>&emsp;&emsp;&emsp;&emsp;float offset_from_surface = 2; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;int ray_count = 4; // [0, 8] <br>&emsp;&emsp;&emsp;&emsp;float verlet_min_joint_distance = 32; // [0, 128] <br>&emsp;&emsp;&emsp;&emsp;MOVETOSURFACE_TYPE::Enum type;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="lookup_radius" type="xs:decimal" default="64">
				<xs:annotation>
					<xs:documentation>`64` - `[0, 64]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="offset_from_surface" type="xs:decimal" default="2">
				<xs:annotation>
					<xs:documentation>`2` - `[0, 10]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ray_count" type="xs:int" default="4">
				<xs:annotation>
					<xs:documentation>`4` - `[0, 8]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="verlet_min_joint_distance" type="xs:decimal" default="32">
				<xs:annotation>
					<xs:documentation>`32` - `[0, 128]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: MOVETOSURFACE_TYPE::Enum for type -->
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="MusicEnergyAffectorComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class MusicEnergyAffectorComponent {<br>&emsp;&emsp;&emsp;&emsp;float energy_target = 0.5; // [0, 1] the energy this makes music go towards<br>&emsp;&emsp;&emsp;&emsp;float fade_range = 0; // [0, 256] if > 0, fade between 0 and energy_target based on distance to this entity<br>&emsp;&emsp;&emsp;&emsp;bool trigger_danger_music = 1; // [0, 1] if 1, attempts to trigger danger music no matter what energy level is reached<br>&emsp;&emsp;&emsp;&emsp;int fog_of_war_threshold = 200; // [0, 255] if fog of war at position of this entity is greater than 'fog_of_war_threshold', this has  no effect<br>&emsp;&emsp;&emsp;&emsp;bool is_enemy = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float energy_lerp_up_speed_multiplier = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="energy_target" type="xs:decimal" default="0.5">
				<xs:annotation>
					<xs:documentation>`0.5` - `[0, 1]`</xs:documentation>
					<xs:documentation>the energy this makes music go towards</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="fade_range" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 256]`</xs:documentation>
					<xs:documentation>if &gt; 0, fade between 0 and energy_target based on distance to this entity</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="trigger_danger_music" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, attempts to trigger danger music no matter what energy level is reached</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="fog_of_war_threshold" type="xs:int" default="200">
				<xs:annotation>
					<xs:documentation>`200` - `[0, 255]`</xs:documentation>
					<xs:documentation>if fog of war at position of this entity is greater than 'fog_of_war_threshold', this has  no effect</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_enemy" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="energy_lerp_up_speed_multiplier" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="NinjaRopeComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class NinjaRopeComponent {<br>&emsp;&emsp;&emsp;&emsp;float max_length = 356; // [0, 2000] <br>&emsp;&emsp;&emsp;&emsp;float mLength = 0; // [0, 2000] <br>&emsp;&emsp;&emsp;&emsp;NINJA_ROPE_SEGMENT_VECTOR mSegments;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="max_length" type="xs:decimal" default="356">
				<xs:annotation>
					<xs:documentation>`356` - `[0, 2000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mLength" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 2000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: NINJA_ROPE_SEGMENT_VECTOR for mSegments -->
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="NullDamageComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class NullDamageComponent {<br>&emsp;&emsp;&emsp;&emsp;float null_chance = 1; // [0, 1] if less than 1, then will roll the die to see if it will NULL all damage. Stick this into your projectile entity<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="null_chance" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if less than 1, then will roll the die to see if it will NULL all damage. Stick this into your projectile entity</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="OrbComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class OrbComponent {<br>&emsp;&emsp;&emsp;&emsp;int orb_id = 0; // [0, 20] must be unique for every orb in the world<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="orb_id" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 20]`</xs:documentation>
					<xs:documentation>must be unique for every orb in the world</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="ParticleEmitterComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ParticleEmitterComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string emitted_material_name = "blood"; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool create_real_particles = 0; // [0, 1] used to be emit_real_particles - creates these particles in the grid, if that happens velocity and lifetime are ignored<br>&emsp;&emsp;&emsp;&emsp;bool emit_real_particles = 0; // [0, 1] this creates particles that will behave like particles, but work outside of the screen<br>&emsp;&emsp;&emsp;&emsp;bool emit_cosmetic_particles = 0; // [0, 1] particle does have collisions, but no other physical interactions with the world. the particles are culled outside camera region<br>&emsp;&emsp;&emsp;&emsp;bool cosmetic_force_create = 1; // [0, 1] cosmetic particles are created inside grid cells<br>&emsp;&emsp;&emsp;&emsp;bool render_back = 1; // [0, 1] for cosmetic particles, if they are rendered on front or in the back...<br>&emsp;&emsp;&emsp;&emsp;bool render_ultrabright = 0; // [0, 1] if 1, particles made of a glowing material will be 3x as bright as usually<br>&emsp;&emsp;&emsp;&emsp;bool collide_with_grid = 1; // [0, 1] for cosmetic particles, if 1 the particles collide with grid and only exist in screen space<br>&emsp;&emsp;&emsp;&emsp;bool collide_with_gas_and_fire = 1; // [0, 1] does it collide with gas and fire, works with create_real_particles and raytraced images <br>&emsp;&emsp;&emsp;&emsp;bool particle_single_width = 1; // [0, 1] for cosmetic particles, forces them (gas,fire) to be only 1 pixel wide <br>&emsp;&emsp;&emsp;&emsp;bool emit_only_if_there_is_space = 0; // [0, 1] This is turned for potions after they take some damage and start leaking<br>&emsp;&emsp;&emsp;&emsp;int emitter_lifetime_frames = -1; // [0, 1] emitter lifetime in frames. -1 = infinite<br>&emsp;&emsp;&emsp;&emsp;bool fire_cells_dont_ignite_damagemodel = 0; // [0, 1] if set, and fire cells are created, this changes their default behaviour of igniting DamageModels<br>&emsp;&emsp;&emsp;&emsp;bool color_is_based_on_pos = 0; // [0, 1] if true, will get the particle color based on the world position (instead of randomizing it)<br>&emsp;&emsp;&emsp;&emsp;float custom_alpha = -1; // [0, 1] if >= 0, will use this as particle alpha<br>&emsp;&emsp;&emsp;&emsp;float x_pos_offset_min = 0; // [-20, 20] <br>&emsp;&emsp;&emsp;&emsp;float y_pos_offset_min = 0; // [-20, 20] <br>&emsp;&emsp;&emsp;&emsp;float x_pos_offset_max = 0; // [-20, 20] <br>&emsp;&emsp;&emsp;&emsp;float y_pos_offset_max = 0; // [-20, 20] <br>&emsp;&emsp;&emsp;&emsp;float area_circle_sector_degrees = 360; // [0, 360] <br>&emsp;&emsp;&emsp;&emsp;float x_vel_min = 0; // [-100, 100] <br>&emsp;&emsp;&emsp;&emsp;float x_vel_max = 0; // [-100, 100] <br>&emsp;&emsp;&emsp;&emsp;float y_vel_min = 0; // [-100, 100] <br>&emsp;&emsp;&emsp;&emsp;float y_vel_max = 0; // [-100, 100] <br>&emsp;&emsp;&emsp;&emsp;float direction_random_deg = 0; // [0, 90] <br>&emsp;&emsp;&emsp;&emsp;float velocity_always_away_from_center = 0; // [-256, 256] if set, will make the velocity's rotation always away from center of randomized aabb<br>&emsp;&emsp;&emsp;&emsp;float lifetime_min = 5; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;float lifetime_max = 10; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;float airflow_force = 0; // [0, 6] <br>&emsp;&emsp;&emsp;&emsp;float airflow_time = 1; // [0, 2] <br>&emsp;&emsp;&emsp;&emsp;float airflow_scale = 1; // [0, 2] <br>&emsp;&emsp;&emsp;&emsp;float friction = 0; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;float attractor_force = 0; // [0, 100] If > 0, an attractor is created at the position of the entity that owns this component<br>&emsp;&emsp;&emsp;&emsp;int emission_interval_min_frames = 5; // [0, 120] <br>&emsp;&emsp;&emsp;&emsp;int emission_interval_max_frames = 10; // [0, 120] <br>&emsp;&emsp;&emsp;&emsp;int emission_chance = 100; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;int delay_frames = 0; // [0, 1] if set will delay this many frames until starts<br>&emsp;&emsp;&emsp;&emsp;bool is_emitting = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool use_material_inventory = 0; // [0, 1] if set, it'll use MaterialInventoryComponent as the source of the particles emitted<br>&emsp;&emsp;&emsp;&emsp;bool is_trail = 0; // [0, 1] if set, will do a trail based on the previous position and current position<br>&emsp;&emsp;&emsp;&emsp;float trail_gap = 0; // [0, 1] if > 0, trail particles will be generated this far from each other between our old and new position, else [count_min-count_max] particles will be generated on the line<br>&emsp;&emsp;&emsp;&emsp;bool render_on_grid = 0; // [0, 1] if set, particle render positions will be snapped to cell grid<br>&emsp;&emsp;&emsp;&emsp;bool fade_based_on_lifetime = 0; // [0, 1] if set, particle's position in its lifetime will determine the rendering alpha<br>&emsp;&emsp;&emsp;&emsp;bool draw_as_long = 0; // [0, 1] if set, particle will rendered as a trail along it's movement vector<br>&emsp;&emsp;&emsp;&emsp;float b2_force = 0; // [0, 10] if 0 nothing happens, if 1 will apply a force to the physics body (if has one), also requires that we use the material inventory<br>&emsp;&emsp;&emsp;&emsp;bool set_magic_creation = 0; // [0, 1] if set will set the magic creation 1 in the cells and do the white glow effect<br>&emsp;&emsp;&emsp;&emsp;std::string image_animation_file; //  file to use for image-based animation<br>&emsp;&emsp;&emsp;&emsp;std::string image_animation_colors_file; //  file to use for image-based animation<br>&emsp;&emsp;&emsp;&emsp;float image_animation_speed = 1; // [0, 255] how long do we stay on one frame of image-based animation. 0.5 means two game frames per one animation frame. 2.0 means two animation frames per one game frame, and so on. 0 means we always emit at time 0 of the animation.<br>&emsp;&emsp;&emsp;&emsp;bool image_animation_loop = 1; // [0, 1] does image-based animation keep looping while this component is active?<br>&emsp;&emsp;&emsp;&emsp;float image_animation_phase = 0; // [0, 1] the point in time [0,1] where the image-based animation will start the first cycle<br>&emsp;&emsp;&emsp;&emsp;float image_animation_emission_probability = 1; // [0, 1] [0,1], probability of emitting image based particles is multiplied with this<br>&emsp;&emsp;&emsp;&emsp;bool image_animation_raytrace_from_center = 0; // [0, 1] enable this to disable image_animations (from the center) going through the world<br>&emsp;&emsp;&emsp;&emsp;bool image_animation_use_entity_rotation = 0; // [0, 1] if 1, image animation emission will be rotated based on entity rotation<br>&emsp;&emsp;&emsp;&emsp;bool ignore_transform_updated_msg = 0; // [0, 1] if 1, mExPosition and m_last_emit_position will not be updated when receiving Message_TransformUpdated<br>&emsp;&emsp;&emsp;&emsp;uint32 color = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;vec2 offset;<br>&emsp;&emsp;&emsp;&emsp;ValueRange area_circle_radius; //  If > 0, the particles will be emitted inside a circular area defined by the min and max bounds of 'area_circle_radius'.<br>&emsp;&emsp;&emsp;&emsp;vec2 gravity;<br>&emsp;&emsp;&emsp;&emsp;LensValue<int> count_min;<br>&emsp;&emsp;&emsp;&emsp;LensValue<int> count_max;<br>&emsp;&emsp;&emsp;&emsp;PARTICLE_EMITTER_CUSTOM_STYLE::Enum custom_style; //  NONE or FIRE<br>&emsp;&emsp;&emsp;&emsp;vec2 mExPosition; //  is used with is_trail<br>&emsp;&emsp;&emsp;&emsp;int mMaterialInventoryMax = 1024; // [0, 1] this is how we figure out the pressure, when using material_inventory<br>&emsp;&emsp;&emsp;&emsp;LensValue<int> m_material_id;<br>&emsp;&emsp;&emsp;&emsp;int m_next_emit_frame = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool m_has_emitted = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;ivec2 m_last_emit_position;<br>&emsp;&emsp;&emsp;&emsp;ParticleEmitter_Animation* m_cached_image_animation;<br>&emsp;&emsp;&emsp;&emsp;float m_image_based_animation_time = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float* m_collision_angles;<br>&emsp;&emsp;&emsp;&emsp;int16 m_particle_attractor_id = -1; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="emitted_material_name" type="xs:string" default="blood">
				<xs:annotation>
					<xs:documentation>`blood` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="create_real_particles" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>used to be emit_real_particles - creates these particles in the grid, if that happens velocity and lifetime are ignored</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="emit_real_particles" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>this creates particles that will behave like particles, but work outside of the screen</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="emit_cosmetic_particles" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>particle does have collisions, but no other physical interactions with the world. the particles are culled outside camera region</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="cosmetic_force_create" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>cosmetic particles are created inside grid cells</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="render_back" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>for cosmetic particles, if they are rendered on front or in the back...</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="render_ultrabright" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, particles made of a glowing material will be 3x as bright as usually</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="collide_with_grid" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>for cosmetic particles, if 1 the particles collide with grid and only exist in screen space</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="collide_with_gas_and_fire" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>does it collide with gas and fire, works with create_real_particles and raytraced images </xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="particle_single_width" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>for cosmetic particles, forces them (gas,fire) to be only 1 pixel wide </xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="emit_only_if_there_is_space" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>This is turned for potions after they take some damage and start leaking</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="emitter_lifetime_frames" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
					<xs:documentation>emitter lifetime in frames. -1 = infinite</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="fire_cells_dont_ignite_damagemodel" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if set, and fire cells are created, this changes their default behaviour of igniting DamageModels</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="color_is_based_on_pos" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, will get the particle color based on the world position (instead of randomizing it)</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="custom_alpha" type="xs:decimal" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if &gt;= 0, will use this as particle alpha</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="x_pos_offset_min" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-20, 20]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="y_pos_offset_min" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-20, 20]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="x_pos_offset_max" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-20, 20]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="y_pos_offset_max" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-20, 20]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="area_circle_sector_degrees" type="xs:decimal" default="360">
				<xs:annotation>
					<xs:documentation>`360` - `[0, 360]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="x_vel_min" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-100, 100]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="x_vel_max" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-100, 100]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="y_vel_min" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-100, 100]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="y_vel_max" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-100, 100]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="direction_random_deg" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 90]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="velocity_always_away_from_center" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-256, 256]`</xs:documentation>
					<xs:documentation>if set, will make the velocity's rotation always away from center of randomized aabb</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="lifetime_min" type="xs:decimal" default="5">
				<xs:annotation>
					<xs:documentation>`5` - `[0, 10]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="lifetime_max" type="xs:decimal" default="10">
				<xs:annotation>
					<xs:documentation>`10` - `[0, 10]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="airflow_force" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 6]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="airflow_time" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 2]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="airflow_scale" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 2]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="friction" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 10]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attractor_force" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 100]`</xs:documentation>
					<xs:documentation>If &gt; 0, an attractor is created at the position of the entity that owns this component</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="emission_interval_min_frames" type="xs:int" default="5">
				<xs:annotation>
					<xs:documentation>`5` - `[0, 120]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="emission_interval_max_frames" type="xs:int" default="10">
				<xs:annotation>
					<xs:documentation>`10` - `[0, 120]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="emission_chance" type="xs:int" default="100">
				<xs:annotation>
					<xs:documentation>`100` - `[0, 100]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="delay_frames" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if set will delay this many frames until starts</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_emitting" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="use_material_inventory" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if set, it'll use MaterialInventoryComponent as the source of the particles emitted</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_trail" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if set, will do a trail based on the previous position and current position</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="trail_gap" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if &gt; 0, trail particles will be generated this far from each other between our old and new position, else [count_min-count_max] particles will be generated on the line</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="render_on_grid" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if set, particle render positions will be snapped to cell grid</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="fade_based_on_lifetime" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if set, particle's position in its lifetime will determine the rendering alpha</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="draw_as_long" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if set, particle will rendered as a trail along it's movement vector</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="b2_force" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 10]`</xs:documentation>
					<xs:documentation>if 0 nothing happens, if 1 will apply a force to the physics body (if has one), also requires that we use the material inventory</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="set_magic_creation" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if set will set the magic creation 1 in the cells and do the white glow effect</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="image_animation_file" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>file to use for image-based animation</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="image_animation_colors_file" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>file to use for image-based animation</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="image_animation_speed" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 255]`</xs:documentation>
					<xs:documentation>how long do we stay on one frame of image-based animation. 0.5 means two game frames per one animation frame. 2.0 means two animation frames per one game frame, and so on. 0 means we always emit at time 0 of the animation.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="image_animation_loop" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>does image-based animation keep looping while this component is active?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="image_animation_phase" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>the point in time [0,1] where the image-based animation will start the first cycle</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="image_animation_emission_probability" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>[0,1], probability of emitting image based particles is multiplied with this</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="image_animation_raytrace_from_center" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>enable this to disable image_animations (from the center) going through the world</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="image_animation_use_entity_rotation" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, image animation emission will be rotated based on entity rotation</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ignore_transform_updated_msg" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, mExPosition and m_last_emit_position will not be updated when receiving Message_TransformUpdated</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="color" type="xs:unsignedInt" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="offset.x" type="xs:decimal" default="0" />
			<xs:attribute name="offset.y" type="xs:decimal" default="0" />
			<xs:attribute name="area_circle_radius.min" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>If &gt; 0, the particles will be emitted inside a circular area defined by the min and max bounds of 'area_circle_radius'.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="area_circle_radius.max" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>If &gt; 0, the particles will be emitted inside a circular area defined by the min and max bounds of 'area_circle_radius'.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="gravity.x" type="xs:decimal" default="0" />
			<xs:attribute name="gravity.y" type="xs:decimal" default="0" />
			<xs:attribute name="count_min" type="xs:int" default="0" />
			<xs:attribute name="count_max" type="xs:int" default="0" />
				<!-- Some Unknown Type: PARTICLE_EMITTER_CUSTOM_STYLE::Enum for custom_style -->
			<xs:attribute name="mExPosition.x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>is used with is_trail</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mExPosition.y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>is used with is_trail</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mMaterialInventoryMax" type="xs:int" default="1024">
				<xs:annotation>
					<xs:documentation>`1024` - `[0, 1]`</xs:documentation>
					<xs:documentation>this is how we figure out the pressure, when using material_inventory</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="m_material_id" type="xs:int" default="0" />
			<xs:attribute name="m_next_emit_frame" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="m_has_emitted" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="m_last_emit_position.x" type="xs:int" default="0" />
			<xs:attribute name="m_last_emit_position.y" type="xs:int" default="0" />
				<!-- Some Unknown Type: ParticleEmitter_Animation* for m_cached_image_animation -->
			<xs:attribute name="m_image_based_animation_time" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: float* for m_collision_angles -->
			<xs:attribute name="m_particle_attractor_id" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="PathFindingComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PathFindingComponent {<br>&emsp;&emsp;&emsp;&emsp;int search_depth_max_no_goal = 20; // [0, 1e+006] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;int iterations_max_no_goal = 1500; // [0, 1e+006] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;int search_depth_max_with_goal = 2500; // [0, 1e+006] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;int iterations_max_with_goal = 1500; // [0, 1e+006] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;float cost_of_flying = 20; // [0, 100000] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;int distance_to_reach_node_x = 2; // [0, 200] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;int distance_to_reach_node_y = 6; // [0, 200] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;int frames_to_get_stuck = 60; // [0, 600] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;int frames_between_searches = 30; // [0, 300] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;float y_walking_compensation = 0; // [-100, 100] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;bool can_fly = 1; // [0, 1] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;bool can_walk = 1; // [0, 1] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;bool can_jump = 0; // [0, 1] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;bool can_dive = 0; // [0, 1] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;bool can_swim_on_surface = 0; // [0, 1] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;bool never_consider_line_of_sight = 0; // [0, 1] if 1, we require a path to have an entity at the goal, having line of sight to the entity is not enough<br>&emsp;&emsp;&emsp;&emsp;float space_required = 0; // [0, 20] how far (in cells) must a point on our route be from the nearest wall to consider it passable?<br>&emsp;&emsp;&emsp;&emsp;float max_jump_distance_from_camera = 400; // [0, 400] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;float jump_speed = 200; // [0, 1000] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;float initial_jump_lob = 1; // [0, 5] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;float initial_jump_max_distance_x = 100; // [0, 1000] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;float initial_jump_max_distance_y = 80; // [0, 1000] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;int read_state = 0; // [0, 1] Read only value to get mState as an integer. Used to detect when the worst cheesers are trying to cheese our beloved squidward.<br>&emsp;&emsp;&emsp;&emsp;VECTOR_JUMPPARAMS jump_trajectories; //  TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;PathFindingInput input; //  TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;MSG_QUEUE_PATH_FINDING_RESULT job_result_receiver; //  TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;bool waiting_for = 0; // [0, 1] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;int next_search_frame = 0; // [0, 1] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;VECTOR_PATHNODE path; //  TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;PathFindingResultNode path_next_node; //  TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;vec2 path_next_node_vector_to; //  TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;float path_next_node_distance_to = 0; // [0, 1] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;PathFindingNodeHandle path_previous_node; //  TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;int path_frames_stuck = 0; // [0, 1] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;bool path_is_stuck = 0; // [0, 1] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;int path_last_frame_with_job = 0; // [0, 1] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;PathFindingLogic* mLogic; //  this defines what is an acceptable path<br>&emsp;&emsp;&emsp;&emsp;PathFindingLogic* mFallbackLogic; //  we use this to define an acceptable path if mLogic doesn't return one<br>&emsp;&emsp;&emsp;&emsp;PathFindingLogic* mSelectedLogic; //  TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;bool mEnabled = 0; // [0, 1] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;PathFindingComponentState::Enum mState; //  TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;int mTimesStuck = 0; // [0, 1] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;int mNextClearDontApproachListFrame = 0; // [0, 1] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;float mNodeProximityCheckCorrectionY = 0; // [0, 1] TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;VECTOR_PATHNODE debug_path; //  TODO: Comment<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> jump_velocity_multiplier; //  TODO: Comment<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="search_depth_max_no_goal" type="xs:int" default="20">
				<xs:annotation>
					<xs:documentation>`20` - `[0, 1e+006]`</xs:documentation>
					<xs:documentation>TODO: Comment</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="iterations_max_no_goal" type="xs:int" default="1500">
				<xs:annotation>
					<xs:documentation>`1500` - `[0, 1e+006]`</xs:documentation>
					<xs:documentation>TODO: Comment</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="search_depth_max_with_goal" type="xs:int" default="2500">
				<xs:annotation>
					<xs:documentation>`2500` - `[0, 1e+006]`</xs:documentation>
					<xs:documentation>TODO: Comment</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="iterations_max_with_goal" type="xs:int" default="1500">
				<xs:annotation>
					<xs:documentation>`1500` - `[0, 1e+006]`</xs:documentation>
					<xs:documentation>TODO: Comment</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="cost_of_flying" type="xs:decimal" default="20">
				<xs:annotation>
					<xs:documentation>`20` - `[0, 100000]`</xs:documentation>
					<xs:documentation>TODO: Comment</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="distance_to_reach_node_x" type="xs:int" default="2">
				<xs:annotation>
					<xs:documentation>`2` - `[0, 200]`</xs:documentation>
					<xs:documentation>TODO: Comment</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="distance_to_reach_node_y" type="xs:int" default="6">
				<xs:annotation>
					<xs:documentation>`6` - `[0, 200]`</xs:documentation>
					<xs:documentation>TODO: Comment</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="frames_to_get_stuck" type="xs:int" default="60">
				<xs:annotation>
					<xs:documentation>`60` - `[0, 600]`</xs:documentation>
					<xs:documentation>TODO: Comment</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="frames_between_searches" type="xs:int" default="30">
				<xs:annotation>
					<xs:documentation>`30` - `[0, 300]`</xs:documentation>
					<xs:documentation>TODO: Comment</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="y_walking_compensation" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-100, 100]`</xs:documentation>
					<xs:documentation>TODO: Comment</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="can_fly" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>TODO: Comment</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="can_walk" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>TODO: Comment</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="can_jump" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>TODO: Comment</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="can_dive" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>TODO: Comment</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="can_swim_on_surface" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>TODO: Comment</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="never_consider_line_of_sight" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, we require a path to have an entity at the goal, having line of sight to the entity is not enough</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="space_required" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 20]`</xs:documentation>
					<xs:documentation>how far (in cells) must a point on our route be from the nearest wall to consider it passable?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="max_jump_distance_from_camera" type="xs:decimal" default="400">
				<xs:annotation>
					<xs:documentation>`400` - `[0, 400]`</xs:documentation>
					<xs:documentation>TODO: Comment</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="jump_speed" type="xs:decimal" default="200">
				<xs:annotation>
					<xs:documentation>`200` - `[0, 1000]`</xs:documentation>
					<xs:documentation>TODO: Comment</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="initial_jump_lob" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 5]`</xs:documentation>
					<xs:documentation>TODO: Comment</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="initial_jump_max_distance_x" type="xs:decimal" default="100">
				<xs:annotation>
					<xs:documentation>`100` - `[0, 1000]`</xs:documentation>
					<xs:documentation>TODO: Comment</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="initial_jump_max_distance_y" type="xs:decimal" default="80">
				<xs:annotation>
					<xs:documentation>`80` - `[0, 1000]`</xs:documentation>
					<xs:documentation>TODO: Comment</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="read_state" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>Read only value to get mState as an integer. Used to detect when the worst cheesers are trying to cheese our beloved squidward.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: VECTOR_JUMPPARAMS for jump_trajectories -->
				<!-- Some Unknown Type: PathFindingInput for input -->
				<!-- Some Unknown Type: MSG_QUEUE_PATH_FINDING_RESULT for job_result_receiver -->
			<xs:attribute name="waiting_for" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>TODO: Comment</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="next_search_frame" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>TODO: Comment</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: VECTOR_PATHNODE for path -->
				<!-- Some Unknown Type: PathFindingResultNode for path_next_node -->
			<xs:attribute name="path_next_node_vector_to.x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>TODO: Comment</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="path_next_node_vector_to.y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>TODO: Comment</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="path_next_node_distance_to" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>TODO: Comment</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: PathFindingNodeHandle for path_previous_node -->
			<xs:attribute name="path_frames_stuck" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>TODO: Comment</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="path_is_stuck" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>TODO: Comment</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="path_last_frame_with_job" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>TODO: Comment</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: PathFindingLogic* for mLogic -->
				<!-- Some Unknown Type: PathFindingLogic* for mFallbackLogic -->
				<!-- Some Unknown Type: PathFindingLogic* for mSelectedLogic -->
			<xs:attribute name="mEnabled" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>TODO: Comment</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: PathFindingComponentState::Enum for mState -->
			<xs:attribute name="mTimesStuck" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>TODO: Comment</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mNextClearDontApproachListFrame" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>TODO: Comment</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mNodeProximityCheckCorrectionY" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>TODO: Comment</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: VECTOR_PATHNODE for debug_path -->
			<xs:attribute name="jump_velocity_multiplier" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>TODO: Comment</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="PathFindingGridMarkerComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PathFindingGridMarkerComponent {<br>&emsp;&emsp;&emsp;&emsp;int marker_work_flag = 0; // [0, 255] <br>&emsp;&emsp;&emsp;&emsp;float marker_offset_x = 0; // [-1000, 1000] <br>&emsp;&emsp;&emsp;&emsp;float marker_offset_y = 0; // [-1000, 1000] <br>&emsp;&emsp;&emsp;&emsp;float player_marker_radius = 0; // [0, 128] <br>&emsp;&emsp;&emsp;&emsp;PathFindingNodeHandle mNode; //  we change the work state of this node. thus we need to keep a reference to it<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="marker_work_flag" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 255]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="marker_offset_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-1000, 1000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="marker_offset_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-1000, 1000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="player_marker_radius" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 128]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: PathFindingNodeHandle for mNode -->
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="PhysicsAIComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PhysicsAIComponent {<br>&emsp;&emsp;&emsp;&emsp;float target_vec_max_len = 5; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float force_coeff = 30; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float force_balancing_coeff = 1.5; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float force_max = 100; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float torque_coeff = 50; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float torque_balancing_coeff = 0.2; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float torque_max = 50; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float torque_damaged_max = 100; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float torque_jump_random = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int damage_deactivation_probability = 80; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int damage_deactivation_time_min = 30; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int damage_deactivation_time_max = 60; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float die_on_remaining_mass_percentage = 0.3; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool levitate = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool v0_jump_logic = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool v0_swim_logic = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool v0_body_id_logic = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int swim_check_y_min = -2; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int swim_check_y_max = 2; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int swim_check_side_x = 4; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int swim_check_side_y = -2; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool keep_inside_world = 1; // [0, 1] fix to the bug in which the spiders spawned inside the holy mountain, if set will try not to go into places which aren't loaded <br>&emsp;&emsp;&emsp;&emsp;bool free_if_static = 0; // [0, 1] set true for the boss, because box2d might turn this body into a static body, if it thinks it's glitching out. <br>&emsp;&emsp;&emsp;&emsp;float rotation_speed = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float mStartingMass = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mMainBodyFound = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mNextFrameActive = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float mRotationTarget = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;vec2 mLastPositionWhenHadPath;<br>&emsp;&emsp;&emsp;&emsp;bool mHasLastPosition = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="target_vec_max_len" type="xs:decimal" default="5">
				<xs:annotation>
					<xs:documentation>`5` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="force_coeff" type="xs:decimal" default="30">
				<xs:annotation>
					<xs:documentation>`30` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="force_balancing_coeff" type="xs:decimal" default="1.5">
				<xs:annotation>
					<xs:documentation>`1.5` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="force_max" type="xs:decimal" default="100">
				<xs:annotation>
					<xs:documentation>`100` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="torque_coeff" type="xs:decimal" default="50">
				<xs:annotation>
					<xs:documentation>`50` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="torque_balancing_coeff" type="xs:decimal" default="0.2">
				<xs:annotation>
					<xs:documentation>`0.2` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="torque_max" type="xs:decimal" default="50">
				<xs:annotation>
					<xs:documentation>`50` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="torque_damaged_max" type="xs:decimal" default="100">
				<xs:annotation>
					<xs:documentation>`100` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="torque_jump_random" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="damage_deactivation_probability" type="xs:int" default="80">
				<xs:annotation>
					<xs:documentation>`80` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="damage_deactivation_time_min" type="xs:int" default="30">
				<xs:annotation>
					<xs:documentation>`30` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="damage_deactivation_time_max" type="xs:int" default="60">
				<xs:annotation>
					<xs:documentation>`60` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="die_on_remaining_mass_percentage" type="xs:decimal" default="0.3">
				<xs:annotation>
					<xs:documentation>`0.3` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="levitate" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="v0_jump_logic" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="v0_swim_logic" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="v0_body_id_logic" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="swim_check_y_min" type="xs:int" default="-2">
				<xs:annotation>
					<xs:documentation>`-2` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="swim_check_y_max" type="xs:int" default="2">
				<xs:annotation>
					<xs:documentation>`2` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="swim_check_side_x" type="xs:int" default="4">
				<xs:annotation>
					<xs:documentation>`4` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="swim_check_side_y" type="xs:int" default="-2">
				<xs:annotation>
					<xs:documentation>`-2` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="keep_inside_world" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>fix to the bug in which the spiders spawned inside the holy mountain, if set will try not to go into places which aren't loaded </xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="free_if_static" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>set true for the boss, because box2d might turn this body into a static body, if it thinks it's glitching out. </xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="rotation_speed" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mStartingMass" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mMainBodyFound" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mNextFrameActive" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mRotationTarget" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mLastPositionWhenHadPath.x" type="xs:decimal" default="0" />
			<xs:attribute name="mLastPositionWhenHadPath.y" type="xs:decimal" default="0" />
			<xs:attribute name="mHasLastPosition" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="PhysicsBody2Component">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PhysicsBody2Component {<br>&emsp;&emsp;&emsp;&emsp;b2ObjectID mBodyId = 0; // [0, 1] this is mBody->GetBodyId() - not to be confused with uid, has to be tracked separately, since the mBody pointer is not unique<br>&emsp;&emsp;&emsp;&emsp;float linear_damping = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float angular_damping = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool allow_sleep = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool fixed_rotation = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool is_bullet = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool is_static = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float buoyancy = 0.7; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool hax_fix_going_through_ground = 0; // [0, 1] if 1, will lift the body upwards if it is inside ground<br>&emsp;&emsp;&emsp;&emsp;bool hax_fix_going_through_sand = 0; // [0, 1] hax_fix_going_through_ground has to be set, if set will lift the body upwards if it is inside sand<br>&emsp;&emsp;&emsp;&emsp;bool hax_wait_till_pixel_scenes_loaded = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool go_through_sand = 0; // [0, 1] if 1, will go through sand PhysicsBridge::mGoThroughSand = 1<br>&emsp;&emsp;&emsp;&emsp;bool auto_clean = 1; // [0, 1] if 1, the simulation might destroy this body if it's hidden under sand. Problematic if you have a small piece with joint attached to something like the wheels of minecart. Set to 0 in cases like that<br>&emsp;&emsp;&emsp;&emsp;bool force_add_update_areas = 1; // [0, 1] if 1, we will mark our predicted aabb as a box2d update area.<br>&emsp;&emsp;&emsp;&emsp;bool update_entity_transform = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool kill_entity_if_body_destroyed = 1; // [0, 1] if 1, will kill the entity when physics body is destroyed<br>&emsp;&emsp;&emsp;&emsp;bool kill_entity_after_initialized = 0; // [0, 1] if 1, will destroy the entity after initialization has been done based the entity's PhysicsBodyComponents and JointComponents<br>&emsp;&emsp;&emsp;&emsp;bool manual_init = 0; // [0, 1] if 1, initialization occurs only when done via for example lua component and Physic2InitFromComponents()<br>&emsp;&emsp;&emsp;&emsp;bool destroy_body_if_entity_destroyed = 0; // [0, 1] if 1, root body is destroyed if the entity is destroyed<br>&emsp;&emsp;&emsp;&emsp;float root_offset_x = 0; // [0, 1] TODO<br>&emsp;&emsp;&emsp;&emsp;float root_offset_y = 0; // [0, 1] TODO<br>&emsp;&emsp;&emsp;&emsp;float init_offset_x = 0; // [0, 1] TODO<br>&emsp;&emsp;&emsp;&emsp;float init_offset_y = 0; // [0, 1] TODO<br>&emsp;&emsp;&emsp;&emsp;bool mActiveState = 0; // [0, 1] private variable, please don't mess around with this<br>&emsp;&emsp;&emsp;&emsp;uint32 mPixelCountOrig = 0; // [0, 1] the number of pixels the body had when it was originally created<br>&emsp;&emsp;&emsp;&emsp;vec2 mLocalPosition; //  private variable, please don't mess around with this<br>&emsp;&emsp;&emsp;&emsp;b2Body* mBody;<br>&emsp;&emsp;&emsp;&emsp;bool mInitialized = 0; // [0, 1] private variable, please don't mess around with this<br>&emsp;&emsp;&emsp;&emsp;uint32 mPixelCount = 0; // [0, 1] if set, tracks the number of csolidcells the body has<br>&emsp;&emsp;&emsp;&emsp;bool mRefreshed = 0; // [0, 1] this is sure the bodies are only parsed once<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
				<!-- Some Unknown Type: b2ObjectID for mBodyId -->
			<xs:attribute name="linear_damping" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="angular_damping" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="allow_sleep" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="fixed_rotation" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_bullet" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_static" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="buoyancy" type="xs:decimal" default="0.7">
				<xs:annotation>
					<xs:documentation>`0.7` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="hax_fix_going_through_ground" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, will lift the body upwards if it is inside ground</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="hax_fix_going_through_sand" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>hax_fix_going_through_ground has to be set, if set will lift the body upwards if it is inside sand</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="hax_wait_till_pixel_scenes_loaded" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="go_through_sand" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, will go through sand PhysicsBridge::mGoThroughSand = 1</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="auto_clean" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, the simulation might destroy this body if it's hidden under sand. Problematic if you have a small piece with joint attached to something like the wheels of minecart. Set to 0 in cases like that</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="force_add_update_areas" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, we will mark our predicted aabb as a box2d update area.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="update_entity_transform" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="kill_entity_if_body_destroyed" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, will kill the entity when physics body is destroyed</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="kill_entity_after_initialized" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, will destroy the entity after initialization has been done based the entity's PhysicsBodyComponents and JointComponents</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="manual_init" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, initialization occurs only when done via for example lua component and Physic2InitFromComponents()</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="destroy_body_if_entity_destroyed" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, root body is destroyed if the entity is destroyed</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="root_offset_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>TODO</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="root_offset_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>TODO</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="init_offset_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>TODO</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="init_offset_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>TODO</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mActiveState" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>private variable, please don't mess around with this</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mPixelCountOrig" type="xs:unsignedInt" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>the number of pixels the body had when it was originally created</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mLocalPosition.x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>private variable, please don't mess around with this</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mLocalPosition.y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>private variable, please don't mess around with this</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: b2Body* for mBody -->
			<xs:attribute name="mInitialized" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>private variable, please don't mess around with this</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mPixelCount" type="xs:unsignedInt" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if set, tracks the number of csolidcells the body has</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mRefreshed" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>this is sure the bodies are only parsed once</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="PhysicsBodyCollisionDamageComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PhysicsBodyCollisionDamageComponent {<br>&emsp;&emsp;&emsp;&emsp;float speed_threshold = 60; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;float damage_multiplier = 0.016667; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="speed_threshold" type="xs:decimal" default="60">
				<xs:annotation>
					<xs:documentation>`60` - `[0, 100]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="damage_multiplier" type="xs:decimal" default="0.016667">
				<xs:annotation>
					<xs:documentation>`0.016667` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="PhysicsBodyComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PhysicsBodyComponent {<br>&emsp;&emsp;&emsp;&emsp;bool is_external = 0; // [0, 1] if mBody is set from outside, will ignore all the things<br>&emsp;&emsp;&emsp;&emsp;bool hax_fix_going_through_ground = 0; // [0, 1] if set will lift the body upwards if it is inside ground<br>&emsp;&emsp;&emsp;&emsp;bool hax_fix_going_through_sand = 0; // [0, 1] hax_fix_going_through_ground has to be set, if set will lift the body upwards if it is inside sand<br>&emsp;&emsp;&emsp;&emsp;bool hax_wait_till_pixel_scenes_loaded = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int uid = 0; // [0, 1000] if the entity has multiple physics bodies and has specific shapes for those and possible joints, you should use this. 0 is default for shapes<br>&emsp;&emsp;&emsp;&emsp;bool is_enabled = 1; // [0, 1] Use this to kill the physics body of. if is_enabled is set to false, will destroy the physics body<br>&emsp;&emsp;&emsp;&emsp;float linear_damping = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float angular_damping = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool allow_sleep = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool fixed_rotation = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float buoyancy = 0.7; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float gravity_scale_if_has_no_image_shapes = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool is_bullet = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool is_static = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool is_kinematic = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool is_character = 0; // [0, 1] if it is a character, then we need to few interesting things from time to time<br>&emsp;&emsp;&emsp;&emsp;bool go_through_sand = 0; // [0, 1] if set, will go through sand PhysicsBridge::mGoThroughSand = 1<br>&emsp;&emsp;&emsp;&emsp;bool gridworld_box2d = 1; // [0, 1] default is 1. You should only change this if you know the body isn't going to touch gridworld<br>&emsp;&emsp;&emsp;&emsp;bool auto_clean = 1; // [0, 1] if set, the simulation might destroy this body if it's hidden under sand. Problematic if you have a small piece with joint attached to something like the wheels of minecart. Set to 0 in cases like that<br>&emsp;&emsp;&emsp;&emsp;bool on_death_leave_physics_body = 0; // [0, 1] if set, will leave the b2body into the world, even if the entity is killed<br>&emsp;&emsp;&emsp;&emsp;bool on_death_really_leave_body = 0; // [0, 1] camera bound... god damn... we need something special when we want to leave the body<br>&emsp;&emsp;&emsp;&emsp;bool update_entity_transform = 1; // [0, 1] WARNING! Don't touch this unless you know what you're doing. If false, doesn't update the entitys transform to match the physics body. This is used with multi body entities, to use the correct body to update the entity, e.g. minecart<br>&emsp;&emsp;&emsp;&emsp;bool force_add_update_areas = 0; // [0, 1] if 1, we will mark our predicted aabb as a box2d update area.<br>&emsp;&emsp;&emsp;&emsp;bool kills_entity = 1; // [0, 1] if set, will kill the entity when physics body is destroyed<br>&emsp;&emsp;&emsp;&emsp;bool projectiles_rotate_toward_velocity = 0; // [0, 1] for physics projectiles, if true will initially rotate the body based on the velocity<br>&emsp;&emsp;&emsp;&emsp;bool randomize_init_velocity = 0; // [0, 1] randomizes the init velocity<br>&emsp;&emsp;&emsp;&emsp;bool mActiveState = 0; // [0, 1] private variable, please don't mess around with this<br>&emsp;&emsp;&emsp;&emsp;vec2 initial_velocity; //  if you want a velocity at the start, set it here<br>&emsp;&emsp;&emsp;&emsp;b2Body* mBody;<br>&emsp;&emsp;&emsp;&emsp;b2ObjectID mBodyId = 0; // [0, 1] this is mBody->GetBodyId() - not to be confused with uid shit, has to be tracked separately, since the mBody pointer is not unique<br>&emsp;&emsp;&emsp;&emsp;int mPixelCount = 0; // [0, 1] if set, tracks the number of csolidcells the body has<br>&emsp;&emsp;&emsp;&emsp;b2Vec2 mLocalPosition;<br>&emsp;&emsp;&emsp;&emsp;bool mRefreshed = 0; // [0, 1] this is sure the bodies are only parsed once<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="is_external" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if mBody is set from outside, will ignore all the things</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="hax_fix_going_through_ground" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if set will lift the body upwards if it is inside ground</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="hax_fix_going_through_sand" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>hax_fix_going_through_ground has to be set, if set will lift the body upwards if it is inside sand</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="hax_wait_till_pixel_scenes_loaded" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="uid" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1000]`</xs:documentation>
					<xs:documentation>if the entity has multiple physics bodies and has specific shapes for those and possible joints, you should use this. 0 is default for shapes</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_enabled" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>Use this to kill the physics body of. if is_enabled is set to false, will destroy the physics body</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="linear_damping" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="angular_damping" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="allow_sleep" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="fixed_rotation" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="buoyancy" type="xs:decimal" default="0.7">
				<xs:annotation>
					<xs:documentation>`0.7` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="gravity_scale_if_has_no_image_shapes" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_bullet" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_static" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_kinematic" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_character" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if it is a character, then we need to few interesting things from time to time</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="go_through_sand" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if set, will go through sand PhysicsBridge::mGoThroughSand = 1</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="gridworld_box2d" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>default is 1. You should only change this if you know the body isn't going to touch gridworld</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="auto_clean" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if set, the simulation might destroy this body if it's hidden under sand. Problematic if you have a small piece with joint attached to something like the wheels of minecart. Set to 0 in cases like that</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="on_death_leave_physics_body" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if set, will leave the b2body into the world, even if the entity is killed</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="on_death_really_leave_body" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>camera bound... god damn... we need something special when we want to leave the body</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="update_entity_transform" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>WARNING! Don't touch this unless you know what you're doing. If false, doesn't update the entitys transform to match the physics body. This is used with multi body entities, to use the correct body to update the entity, e.g. minecart</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="force_add_update_areas" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, we will mark our predicted aabb as a box2d update area.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="kills_entity" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if set, will kill the entity when physics body is destroyed</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="projectiles_rotate_toward_velocity" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>for physics projectiles, if true will initially rotate the body based on the velocity</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="randomize_init_velocity" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>randomizes the init velocity</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mActiveState" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>private variable, please don't mess around with this</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="initial_velocity.x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>if you want a velocity at the start, set it here</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="initial_velocity.y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>if you want a velocity at the start, set it here</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: b2Body* for mBody -->
				<!-- Some Unknown Type: b2ObjectID for mBodyId -->
			<xs:attribute name="mPixelCount" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if set, tracks the number of csolidcells the body has</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: b2Vec2 for mLocalPosition -->
			<xs:attribute name="mRefreshed" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>this is sure the bodies are only parsed once</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="PhysicsImageShapeComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PhysicsImageShapeComponent {<br>&emsp;&emsp;&emsp;&emsp;bool is_root = 0; // [0, 1] if 1, PhysicsBody2Component will use this to figure out where the entity is located<br>&emsp;&emsp;&emsp;&emsp;int body_id = 0; // [0, 1000] used to figure out which bodies are attached to each other when creating joints<br>&emsp;&emsp;&emsp;&emsp;bool use_sprite = 0; // [0, 1] will try to find the SpriteComponent and use that<br>&emsp;&emsp;&emsp;&emsp;bool is_circle = 0; // [0, 1] tries to fit this into a circle, looks at bounding box of the pixels and sets the circle to the center of that with radius being the line from there to a straight edge<br>&emsp;&emsp;&emsp;&emsp;bool centered = 0; // [0, 1] if this is true, moves offset to be in the center of the image, overwrites the offset_x, offset_y<br>&emsp;&emsp;&emsp;&emsp;float offset_x = 0; // [0, 1] offset x in pixels<br>&emsp;&emsp;&emsp;&emsp;float offset_y = 0; // [0, 1] offset y in pixels<br>&emsp;&emsp;&emsp;&emsp;float z = 0; // [0, 1] offset in the z direction<br>&emsp;&emsp;&emsp;&emsp;std::string image_file; //  the png file from which the body is created from<br>&emsp;&emsp;&emsp;&emsp;int material = 0; // [0, 1] the material from which the body is created<br>&emsp;&emsp;&emsp;&emsp;b2Body* mBody; //  used in joint creation phase<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="is_root" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, PhysicsBody2Component will use this to figure out where the entity is located</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="body_id" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1000]`</xs:documentation>
					<xs:documentation>used to figure out which bodies are attached to each other when creating joints</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="use_sprite" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>will try to find the SpriteComponent and use that</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_circle" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>tries to fit this into a circle, looks at bounding box of the pixels and sets the circle to the center of that with radius being the line from there to a straight edge</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="centered" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if this is true, moves offset to be in the center of the image, overwrites the offset_x, offset_y</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="offset_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>offset x in pixels</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="offset_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>offset y in pixels</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="z" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>offset in the z direction</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="image_file" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>the png file from which the body is created from</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="material" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>the material from which the body is created</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: b2Body* for mBody -->
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="PhysicsJoint2Component">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PhysicsJoint2Component {<br>&emsp;&emsp;&emsp;&emsp;uint16 joint_id = 0; // [0, 1000] Use this to create a relation between PhysicsJointMutator and a joint. The PhysicsJointMutator must exist when the physics objects are initialized for the first time. This id should be unique inside one entity. Defaults to 0<br>&emsp;&emsp;&emsp;&emsp;float break_force = 1.3; // [0, 1] if > 0, will break if theres a force too strong.<br>&emsp;&emsp;&emsp;&emsp;float break_distance = 1.4142; // [0, 1] if > 0, will break if the anchors on the bodies get further than this.<br>&emsp;&emsp;&emsp;&emsp;bool break_on_body_modified = 0; // [0, 1] if > 1, will break if an attached body is modified<br>&emsp;&emsp;&emsp;&emsp;float break_on_shear_angle_deg = 0; // [0, 1] if > 0, will break if the angle between the linked bodies becomes greater than this<br>&emsp;&emsp;&emsp;&emsp;int body1_id = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int body2_id = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float offset_x = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float offset_y = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float ray_x = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float ray_y = -10; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float surface_attachment_offset_x = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float surface_attachment_offset_y = 2.5; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;JOINT_TYPE::Enum type; //  Enum - REVOLUTE_JOINT, WELD_JOINT, REVOLUTE_JOINT_ATTACH_TO_NEARBY_SURFACE or WELD_JOINT_ATTACH_TO_NEARBY_SURFACE<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="joint_id" type="xs:unsignedInt" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1000]`</xs:documentation>
					<xs:documentation>Use this to create a relation between PhysicsJointMutator and a joint. The PhysicsJointMutator must exist when the physics objects are initialized for the first time. This id should be unique inside one entity. Defaults to 0</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="break_force" type="xs:decimal" default="1.3">
				<xs:annotation>
					<xs:documentation>`1.3` - `[0, 1]`</xs:documentation>
					<xs:documentation>if &gt; 0, will break if theres a force too strong.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="break_distance" type="xs:decimal" default="1.4142">
				<xs:annotation>
					<xs:documentation>`1.4142` - `[0, 1]`</xs:documentation>
					<xs:documentation>if &gt; 0, will break if the anchors on the bodies get further than this.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="break_on_body_modified" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if &gt; 1, will break if an attached body is modified</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="break_on_shear_angle_deg" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if &gt; 0, will break if the angle between the linked bodies becomes greater than this</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="body1_id" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="body2_id" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="offset_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="offset_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ray_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ray_y" type="xs:decimal" default="-10">
				<xs:annotation>
					<xs:documentation>`-10` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="surface_attachment_offset_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="surface_attachment_offset_y" type="xs:decimal" default="2.5">
				<xs:annotation>
					<xs:documentation>`2.5` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: JOINT_TYPE::Enum for type -->
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="PhysicsJoint2MutatorComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PhysicsJoint2MutatorComponent {<br>&emsp;&emsp;&emsp;&emsp;uint16 joint_id = 0; // [0, 1000] Use this to create a relation between PhysicsJointMutator and a joint created by PhysicsJoint2Component. The PhysicsJoint2Mutator must exist when the physics objects are initialized for the first time.<br>&emsp;&emsp;&emsp;&emsp;bool destroy = 0; // [0, 1] if 1, the joint will break and this component will be destroyed.<br>&emsp;&emsp;&emsp;&emsp;float motor_speed = 0; // [0, 1] if != 0 and this is linked to a revolute joint, the joint motor will be enabled at this speed<br>&emsp;&emsp;&emsp;&emsp;float motor_max_torque = 1; // [0, 1] max torque for motor<br>&emsp;&emsp;&emsp;&emsp;uint64 mBox2DJointId = 0; // [0, 1] Private, don't touch this! Stores the joint's id in the physics engine.<br>&emsp;&emsp;&emsp;&emsp;float mPreviousMotorSpeed = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float mPreviousMotorMaxTorque = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="joint_id" type="xs:unsignedInt" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1000]`</xs:documentation>
					<xs:documentation>Use this to create a relation between PhysicsJointMutator and a joint created by PhysicsJoint2Component. The PhysicsJoint2Mutator must exist when the physics objects are initialized for the first time.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="destroy" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, the joint will break and this component will be destroyed.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="motor_speed" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if != 0 and this is linked to a revolute joint, the joint motor will be enabled at this speed</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="motor_max_torque" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>max torque for motor</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mBox2DJointId" type="xs:unsignedInt" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>Private, don't touch this! Stores the joint's id in the physics engine.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mPreviousMotorSpeed" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mPreviousMotorMaxTorque" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="PhysicsJointComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PhysicsJointComponent {<br>&emsp;&emsp;&emsp;&emsp;bool nail_to_wall = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool grid_joint = 0; // [0, 1] if 1, will do a grid joint that works correctly with a body when it is destroyed / chipped away<br>&emsp;&emsp;&emsp;&emsp;bool breakable = 0; // [0, 1] if 1, will break if theres a force too strong<br>&emsp;&emsp;&emsp;&emsp;int body1_id = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int body2_id = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float pos_x = 0; // [0, 3.5] <br>&emsp;&emsp;&emsp;&emsp;float pos_y = 0; // [0, 3.5] <br>&emsp;&emsp;&emsp;&emsp;float delta_x = 0; // [-10, 10] For mouse joint only ... moves the mouse joint by *dt <br>&emsp;&emsp;&emsp;&emsp;float delta_y = 0; // [-10, 10] For mouse joint only ... moves the mouse joint by *dt <br>&emsp;&emsp;&emsp;&emsp;bool mMotorEnabled = 0; // [0, 1] enable motor, by setting this to true<br>&emsp;&emsp;&emsp;&emsp;float mMotorSpeed = 0; // [0, 20] if enabled this gets set to speed<br>&emsp;&emsp;&emsp;&emsp;float mMaxMotorTorque = 1; // [0, 1] max torque for motor<br>&emsp;&emsp;&emsp;&emsp;JOINT_TYPE::Enum type; //  Enum - JOINT_TYPE<br>&emsp;&emsp;&emsp;&emsp;b2Joint* mJoint;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="nail_to_wall" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="grid_joint" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, will do a grid joint that works correctly with a body when it is destroyed / chipped away</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="breakable" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, will break if theres a force too strong</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="body1_id" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="body2_id" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="pos_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 3.5]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="pos_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 3.5]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="delta_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-10, 10]`</xs:documentation>
					<xs:documentation>For mouse joint only ... moves the mouse joint by *dt </xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="delta_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-10, 10]`</xs:documentation>
					<xs:documentation>For mouse joint only ... moves the mouse joint by *dt </xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mMotorEnabled" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>enable motor, by setting this to true</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mMotorSpeed" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 20]`</xs:documentation>
					<xs:documentation>if enabled this gets set to speed</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mMaxMotorTorque" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>max torque for motor</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: JOINT_TYPE::Enum for type -->
				<!-- Some Unknown Type: b2Joint* for mJoint -->
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="PhysicsKeepInWorldComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PhysicsKeepInWorldComponent {<br>&emsp;&emsp;&emsp;&emsp;bool check_whole_aabb = 0; // [0, 1] All that is needed is to include one of the components with PhysicsBodyComponent or PhysicsBody2Component and it will be frozen when it hits outer edges of the world. NOTE! This will override the auto_clean variable, auto_clean will be set to false. If this is true, will check all the 4 corners of the bounding box<br>&emsp;&emsp;&emsp;&emsp;bool predict_aabb = 0; // [0, 1] Will add the velocity * 1.5 to the aabb to predict where the body will end up at. This will greatly help keep the body inside simulated world.<br>&emsp;&emsp;&emsp;&emsp;bool keep_at_last_valid_pos = 0; // [0, 1] Will try to keep the object at the latest valid position<br>&emsp;&emsp;&emsp;&emsp;vec2 mExPosition;<br>&emsp;&emsp;&emsp;&emsp;float mExRotation = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="check_whole_aabb" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>All that is needed is to include one of the components with PhysicsBodyComponent or PhysicsBody2Component and it will be frozen when it hits outer edges of the world. NOTE! This will override the auto_clean variable, auto_clean will be set to false. If this is true, will check all the 4 corners of the bounding box</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="predict_aabb" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>Will add the velocity * 1.5 to the aabb to predict where the body will end up at. This will greatly help keep the body inside simulated world.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="keep_at_last_valid_pos" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>Will try to keep the object at the latest valid position</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mExPosition.x" type="xs:decimal" default="0" />
			<xs:attribute name="mExPosition.y" type="xs:decimal" default="0" />
			<xs:attribute name="mExRotation" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="PhysicsPickUpComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PhysicsPickUpComponent {<br>&emsp;&emsp;&emsp;&emsp;float pick_up_strength = 200; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;types::xform transform;<br>&emsp;&emsp;&emsp;&emsp;vec2 original_left_joint_pos;<br>&emsp;&emsp;&emsp;&emsp;vec2 original_right_joint_pos;<br>&emsp;&emsp;&emsp;&emsp;bool isBroken = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;vec2 leftJointPos;<br>&emsp;&emsp;&emsp;&emsp;vec2 rightJointPos;<br>&emsp;&emsp;&emsp;&emsp;b2WeldJoint* leftJoint;<br>&emsp;&emsp;&emsp;&emsp;b2WeldJoint* rightJoint;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:sequence minOccurs="0"> <xs:element name="transform" type="Transform" /></xs:sequence>
			<xs:attribute name="pick_up_strength" type="xs:decimal" default="200">
				<xs:annotation>
					<xs:documentation>`200` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="original_left_joint_pos.x" type="xs:decimal" default="0" />
			<xs:attribute name="original_left_joint_pos.y" type="xs:decimal" default="0" />
			<xs:attribute name="original_right_joint_pos.x" type="xs:decimal" default="0" />
			<xs:attribute name="original_right_joint_pos.y" type="xs:decimal" default="0" />
			<xs:attribute name="isBroken" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="leftJointPos.x" type="xs:decimal" default="0" />
			<xs:attribute name="leftJointPos.y" type="xs:decimal" default="0" />
			<xs:attribute name="rightJointPos.x" type="xs:decimal" default="0" />
			<xs:attribute name="rightJointPos.y" type="xs:decimal" default="0" />
				<!-- Some Unknown Type: b2WeldJoint* for leftJoint -->
				<!-- Some Unknown Type: b2WeldJoint* for rightJoint -->
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="PhysicsRagdollComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PhysicsRagdollComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string filename; //  file that should include just a list of other files, that have all the parts<br>&emsp;&emsp;&emsp;&emsp;std::string filenames; //  a list of body parts as png images, separate the files by ','. e.g. 'data/temp/ragdoll/leg.png, data/temp/ragdoll/head.png,...'<br>&emsp;&emsp;&emsp;&emsp;float offset_x = 0; // [0, 20] offset of where the ragdoll will be created<br>&emsp;&emsp;&emsp;&emsp;float offset_y = 0; // [0, 20] offset of where the ragdoll will be created<br>&emsp;&emsp;&emsp;&emsp;std::vector<b2Body*>* bodies;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="filename" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>file that should include just a list of other files, that have all the parts</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="filenames" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>a list of body parts as png images, separate the files by ','. e.g. 'data/temp/ragdoll/leg.png, data/temp/ragdoll/head.png,...'</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="offset_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 20]`</xs:documentation>
					<xs:documentation>offset of where the ragdoll will be created</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="offset_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 20]`</xs:documentation>
					<xs:documentation>offset of where the ragdoll will be created</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: std::vector<b2Body*>* for bodies -->
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="PhysicsShapeComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PhysicsShapeComponent {<br>&emsp;&emsp;&emsp;&emsp;bool recreate = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool is_circle = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool is_box = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool is_capsule = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool is_based_on_sprite = 0; // [0, 1] if set, will use sprite component to figure out a box that fits this<br>&emsp;&emsp;&emsp;&emsp;float friction = 0.75; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float restitution = 0.1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float density = 0.75; // [0, 5] <br>&emsp;&emsp;&emsp;&emsp;float local_position_x = 0; // [-5, 5] <br>&emsp;&emsp;&emsp;&emsp;float local_position_y = 0; // [-5, 5] <br>&emsp;&emsp;&emsp;&emsp;float radius_x = 1; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;float radius_y = 1; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;float capsule_x_percent = 0.25; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float capsule_y_percent = 0.3; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int material = 0; // [0, 1] the material to use for collision audio<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="recreate" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_circle" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_box" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_capsule" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_based_on_sprite" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if set, will use sprite component to figure out a box that fits this</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="friction" type="xs:decimal" default="0.75">
				<xs:annotation>
					<xs:documentation>`0.75` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="restitution" type="xs:decimal" default="0.1">
				<xs:annotation>
					<xs:documentation>`0.1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="density" type="xs:decimal" default="0.75">
				<xs:annotation>
					<xs:documentation>`0.75` - `[0, 5]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="local_position_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-5, 5]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="local_position_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-5, 5]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="radius_x" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 10]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="radius_y" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 10]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="capsule_x_percent" type="xs:decimal" default="0.25">
				<xs:annotation>
					<xs:documentation>`0.25` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="capsule_y_percent" type="xs:decimal" default="0.3">
				<xs:annotation>
					<xs:documentation>`0.3` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="material" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>the material to use for collision audio</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="PhysicsThrowableComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PhysicsThrowableComponent {<br>&emsp;&emsp;&emsp;&emsp;float throw_force_coeff = 1; // [0, 2] <br>&emsp;&emsp;&emsp;&emsp;float max_throw_speed = 180; // [0, 256] <br>&emsp;&emsp;&emsp;&emsp;float min_torque = 0.5; // [0, 20] <br>&emsp;&emsp;&emsp;&emsp;float max_torque = 8; // [0, 20] <br>&emsp;&emsp;&emsp;&emsp;float tip_check_offset_min = 3; // [0, 20] <br>&emsp;&emsp;&emsp;&emsp;float tip_check_offset_max = 5; // [0, 20] <br>&emsp;&emsp;&emsp;&emsp;float tip_check_random_rotation_deg = 9; // [0, 180] <br>&emsp;&emsp;&emsp;&emsp;float attach_min_speed = 70; // [0, 180] <br>&emsp;&emsp;&emsp;&emsp;bool attach_to_surfaces_knife_style = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int hp = 100; // [0, 200] WIP WIP<br>&emsp;&emsp;&emsp;&emsp;bool mHasJoint = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="throw_force_coeff" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 2]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="max_throw_speed" type="xs:decimal" default="180">
				<xs:annotation>
					<xs:documentation>`180` - `[0, 256]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="min_torque" type="xs:decimal" default="0.5">
				<xs:annotation>
					<xs:documentation>`0.5` - `[0, 20]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="max_torque" type="xs:decimal" default="8">
				<xs:annotation>
					<xs:documentation>`8` - `[0, 20]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="tip_check_offset_min" type="xs:decimal" default="3">
				<xs:annotation>
					<xs:documentation>`3` - `[0, 20]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="tip_check_offset_max" type="xs:decimal" default="5">
				<xs:annotation>
					<xs:documentation>`5` - `[0, 20]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="tip_check_random_rotation_deg" type="xs:decimal" default="9">
				<xs:annotation>
					<xs:documentation>`9` - `[0, 180]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attach_min_speed" type="xs:decimal" default="70">
				<xs:annotation>
					<xs:documentation>`70` - `[0, 180]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attach_to_surfaces_knife_style" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="hp" type="xs:int" default="100">
				<xs:annotation>
					<xs:documentation>`100` - `[0, 200]`</xs:documentation>
					<xs:documentation>WIP WIP</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mHasJoint" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="PixelSceneComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PixelSceneComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string pixel_scene; //  loads this pixel scene file<br>&emsp;&emsp;&emsp;&emsp;std::string pixel_scene_visual; //  this is the colors that get used for the pixels, if empty will use material colors<br>&emsp;&emsp;&emsp;&emsp;std::string pixel_scene_background; //  this is the background file that gets loaded, if empty won't do anything<br>&emsp;&emsp;&emsp;&emsp;int background_z_index = 50; // [0, 1] the standard z_index of pixel scene backgrounds<br>&emsp;&emsp;&emsp;&emsp;float offset_x = 0; // [-30, 30] how much off from the entity x,y will this be. Top left corner is where it loads the pixel scene<br>&emsp;&emsp;&emsp;&emsp;float offset_y = 0; // [-30, 30] <br>&emsp;&emsp;&emsp;&emsp;bool skip_biome_checks = 0; // [0, 1] biome check is on by default - it will check that pixel scene is loaded so that every corner is in the same biome<br>&emsp;&emsp;&emsp;&emsp;bool skip_edge_textures = 0; // [0, 1] if on - won't do the edge textures for the pixel scene<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="pixel_scene" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>loads this pixel scene file</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="pixel_scene_visual" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>this is the colors that get used for the pixels, if empty will use material colors</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="pixel_scene_background" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>this is the background file that gets loaded, if empty won't do anything</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="background_z_index" type="xs:int" default="50">
				<xs:annotation>
					<xs:documentation>`50` - `[0, 1]`</xs:documentation>
					<xs:documentation>the standard z_index of pixel scene backgrounds</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="offset_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-30, 30]`</xs:documentation>
					<xs:documentation>how much off from the entity x,y will this be. Top left corner is where it loads the pixel scene</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="offset_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-30, 30]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="skip_biome_checks" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>biome check is on by default - it will check that pixel scene is loaded so that every corner is in the same biome</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="skip_edge_textures" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if on - won't do the edge textures for the pixel scene</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="PixelSpriteComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PixelSpriteComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string image_file; //  loads pixelsprite based on this file<br>&emsp;&emsp;&emsp;&emsp;int anchor_x = 0; // [0, 3.5] the anchor and center_offset<br>&emsp;&emsp;&emsp;&emsp;int anchor_y = 0; // [0, 3.5] the anchor and center_offset<br>&emsp;&emsp;&emsp;&emsp;std::string material = "wood_loose"; // [0, 1] what's the material that things are made out of, TODO - change this into MetaCustom<br>&emsp;&emsp;&emsp;&emsp;bool diggable = 1; // [0, 1] if 1, this can be broken with digger<br>&emsp;&emsp;&emsp;&emsp;bool clean_overlapping_pixels = 1; // [0, 1] cleans up the pixels that are ovelapping in the world<br>&emsp;&emsp;&emsp;&emsp;bool kill_when_sprite_dies = 1; // [0, 1] kills the entity, if the pixel sprite is dead (empty)<br>&emsp;&emsp;&emsp;&emsp;bool create_box2d_bodies = 0; // [0, 1] if true, will create new pixel sprites with box2d bodies, instead of gridworld cells<br>&emsp;&emsp;&emsp;&emsp;PixelSprite* mPixelSprite;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="image_file" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>loads pixelsprite based on this file</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="anchor_x" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 3.5]`</xs:documentation>
					<xs:documentation>the anchor and center_offset</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="anchor_y" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 3.5]`</xs:documentation>
					<xs:documentation>the anchor and center_offset</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="material" type="xs:string" default="wood_loose">
				<xs:annotation>
					<xs:documentation>`wood_loose` - `[0, 1]`</xs:documentation>
					<xs:documentation>what's the material that things are made out of, TODO - change this into MetaCustom</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="diggable" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, this can be broken with digger</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="clean_overlapping_pixels" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>cleans up the pixels that are ovelapping in the world</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="kill_when_sprite_dies" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>kills the entity, if the pixel sprite is dead (empty)</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="create_box2d_bodies" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, will create new pixel sprites with box2d bodies, instead of gridworld cells</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: PixelSprite* for mPixelSprite -->
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="PlatformShooterPlayerComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PlatformShooterPlayerComponent {<br>&emsp;&emsp;&emsp;&emsp;float aiming_reticle_distance_from_character = 40; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;float camera_max_distance_from_character = 25; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;float alcohol_drunken_speed = 0.005; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;float blood_fungi_drunken_speed = 0.006; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;float blood_worm_drunken_speed = 0.006; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;int eating_cells_per_frame = 1; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;int eating_probability = 5; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;int eating_delay_frames = 30; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;float stoned_speed = 0.1; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;bool center_camera_on_this_entity = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool move_camera_with_aim = 1; // [0, 1] if true, moves camera with the aim.<br>&emsp;&emsp;&emsp;&emsp;ivec2 eating_area_min;<br>&emsp;&emsp;&emsp;&emsp;ivec2 eating_area_max;<br>&emsp;&emsp;&emsp;&emsp;vec2 mSmoothedCameraPosition;<br>&emsp;&emsp;&emsp;&emsp;vec2 mSmoothedAimingVector;<br>&emsp;&emsp;&emsp;&emsp;float mCameraRecoil = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float mCameraRecoilTarget = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mCrouching = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float mCameraDistanceLerped = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mRequireTriggerPull = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mWarpDelay = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mItemTemporarilyHidden = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;vec2 mDesiredCameraPos;<br>&emsp;&emsp;&emsp;&emsp;bool mHasGamepadControlsPrev = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mForceFireOnNextUpdate = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float mFastMovementParticlesAlphaSmoothed = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;uint64 mTeleBoltFramesDuringLastSecond = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float mCamCorrectionTeleSmoothed = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;vec2 mCamCorrectionGainSmoothed;<br>&emsp;&emsp;&emsp;&emsp;Vec2ArrayInline mCameraErrorPrev;<br>&emsp;&emsp;&emsp;&emsp;vec2 mCamErrorAveraged;<br>&emsp;&emsp;&emsp;&emsp;bool mCamMovingFastPrev = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mCamFrameStartedMovingFast = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mCamFrameLastMovingFastExplosion = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mCessationDo = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mCessationLifetime = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="aiming_reticle_distance_from_character" type="xs:decimal" default="40">
				<xs:annotation>
					<xs:documentation>`40` - `[0, 1000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="camera_max_distance_from_character" type="xs:decimal" default="25">
				<xs:annotation>
					<xs:documentation>`25` - `[0, 1000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="alcohol_drunken_speed" type="xs:decimal" default="0.005">
				<xs:annotation>
					<xs:documentation>`0.005` - `[0, 1000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="blood_fungi_drunken_speed" type="xs:decimal" default="0.006">
				<xs:annotation>
					<xs:documentation>`0.006` - `[0, 1000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="blood_worm_drunken_speed" type="xs:decimal" default="0.006">
				<xs:annotation>
					<xs:documentation>`0.006` - `[0, 1000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="eating_cells_per_frame" type="xs:int" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 100]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="eating_probability" type="xs:int" default="5">
				<xs:annotation>
					<xs:documentation>`5` - `[0, 100]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="eating_delay_frames" type="xs:int" default="30">
				<xs:annotation>
					<xs:documentation>`30` - `[0, 100]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="stoned_speed" type="xs:decimal" default="0.1">
				<xs:annotation>
					<xs:documentation>`0.1` - `[0, 1000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="center_camera_on_this_entity" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="move_camera_with_aim" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, moves camera with the aim.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="eating_area_min.x" type="xs:int" default="0" />
			<xs:attribute name="eating_area_min.y" type="xs:int" default="0" />
			<xs:attribute name="eating_area_max.x" type="xs:int" default="0" />
			<xs:attribute name="eating_area_max.y" type="xs:int" default="0" />
			<xs:attribute name="mSmoothedCameraPosition.x" type="xs:decimal" default="0" />
			<xs:attribute name="mSmoothedCameraPosition.y" type="xs:decimal" default="0" />
			<xs:attribute name="mSmoothedAimingVector.x" type="xs:decimal" default="0" />
			<xs:attribute name="mSmoothedAimingVector.y" type="xs:decimal" default="0" />
			<xs:attribute name="mCameraRecoil" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mCameraRecoilTarget" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mCrouching" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mCameraDistanceLerped" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mRequireTriggerPull" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mWarpDelay" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mItemTemporarilyHidden" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mDesiredCameraPos.x" type="xs:decimal" default="0" />
			<xs:attribute name="mDesiredCameraPos.y" type="xs:decimal" default="0" />
			<xs:attribute name="mHasGamepadControlsPrev" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mForceFireOnNextUpdate" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mFastMovementParticlesAlphaSmoothed" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mTeleBoltFramesDuringLastSecond" type="xs:unsignedInt" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mCamCorrectionTeleSmoothed" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mCamCorrectionGainSmoothed.x" type="xs:decimal" default="0" />
			<xs:attribute name="mCamCorrectionGainSmoothed.y" type="xs:decimal" default="0" />
				<!-- Some Unknown Type: Vec2ArrayInline for mCameraErrorPrev -->
			<xs:attribute name="mCamErrorAveraged.x" type="xs:decimal" default="0" />
			<xs:attribute name="mCamErrorAveraged.y" type="xs:decimal" default="0" />
			<xs:attribute name="mCamMovingFastPrev" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mCamFrameStartedMovingFast" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mCamFrameLastMovingFastExplosion" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mCessationDo" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mCessationLifetime" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="PlayerCollisionComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PlayerCollisionComponent {<br>&emsp;&emsp;&emsp;&emsp;int getting_crushed_threshold = 5; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;int moving_up_before_getting_crushed_threshold = 3; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;int getting_crushed_counter = 0; // [0, 1] 1.12.2018 - Is this still used?<br>&emsp;&emsp;&emsp;&emsp;int stuck_in_ground_counter = 0; // [0, 1] used this mostly for player to figure out if it's stuck in ground<br>&emsp;&emsp;&emsp;&emsp;int DEBUG_stuck_in_static_ground = 0; // [0, 1] used to report error + also to free the player in case something horrible has gone wrong<br>&emsp;&emsp;&emsp;&emsp;bool mCollidedHorizontally = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;b2Body* mPhysicsCollisionHax; //  hax<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="getting_crushed_threshold" type="xs:int" default="5">
				<xs:annotation>
					<xs:documentation>`5` - `[0, 100]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="moving_up_before_getting_crushed_threshold" type="xs:int" default="3">
				<xs:annotation>
					<xs:documentation>`3` - `[0, 100]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="getting_crushed_counter" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>1.12.2018 - Is this still used?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="stuck_in_ground_counter" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>used this mostly for player to figure out if it's stuck in ground</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="DEBUG_stuck_in_static_ground" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>used to report error + also to free the player in case something horrible has gone wrong</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mCollidedHorizontally" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: b2Body* for mPhysicsCollisionHax -->
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="PlayerStatsComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PlayerStatsComponent {<br>&emsp;&emsp;&emsp;&emsp;int lives = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float max_hp = 4; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float speed = 1; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="lives" type="xs:int" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="max_hp" type="xs:decimal" default="4">
				<xs:annotation>
					<xs:documentation>`4` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="speed" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="PositionSeedComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PositionSeedComponent {<br>&emsp;&emsp;&emsp;&emsp;float pos_x = 0; // [0, 3.5] <br>&emsp;&emsp;&emsp;&emsp;float pos_y = 0; // [0, 3.5] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="pos_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 3.5]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="pos_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 3.5]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="PotionComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PotionComponent {<br>&emsp;&emsp;&emsp;&emsp;float spray_velocity_coeff = 1; // [0, 2] <br>&emsp;&emsp;&emsp;&emsp;float spray_velocity_normalized_min = 0.5; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool body_colored = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool throw_bunch = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int throw_how_many = 5; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool dont_spray_static_materials = 0; // [0, 1] NOTE( Petri ): 15.8.2023 - if this is set to true, will only spray dynamic materials, that dont cause bugs (i.e. will not spray hard rock, box2d materials)<br>&emsp;&emsp;&emsp;&emsp;bool dont_spray_just_leak_gas_materials = 0; // [0, 1] NOTE( Petri ): 15.8.2023 - if this is set to true, will only leak gas materials instead of 'spraying' them.<br>&emsp;&emsp;&emsp;&emsp;bool never_color = 0; // [0, 1] Petri: body_colored didn't seem to work, so I added never_color. It can be set to true if you never want the potion to be colored<br>&emsp;&emsp;&emsp;&emsp;int custom_color_material = 0; // [0, 1] if set, will always use the color from this material<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="spray_velocity_coeff" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 2]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="spray_velocity_normalized_min" type="xs:decimal" default="0.5">
				<xs:annotation>
					<xs:documentation>`0.5` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="body_colored" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="throw_bunch" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="throw_how_many" type="xs:int" default="5">
				<xs:annotation>
					<xs:documentation>`5` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="dont_spray_static_materials" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>NOTE( Petri ): 15.8.2023 - if this is set to true, will only spray dynamic materials, that dont cause bugs (i.e. will not spray hard rock, box2d materials)</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="dont_spray_just_leak_gas_materials" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>NOTE( Petri ): 15.8.2023 - if this is set to true, will only leak gas materials instead of 'spraying' them.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="never_color" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>Petri: body_colored didn't seem to work, so I added never_color. It can be set to true if you never want the potion to be colored</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="custom_color_material" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if set, will always use the color from this material</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="PressurePlateComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class PressurePlateComponent {<br>&emsp;&emsp;&emsp;&emsp;int check_every_x_frames = 30; // [0, 1] how often do we check the world<br>&emsp;&emsp;&emsp;&emsp;int state = 0; // [0, 1] 0 is up, 1 is down<br>&emsp;&emsp;&emsp;&emsp;float material_percent = 0.75; // [0, 1] how much material should there be in the aabbs that we go down <br>&emsp;&emsp;&emsp;&emsp;vec2 aabb_min;<br>&emsp;&emsp;&emsp;&emsp;vec2 aabb_max;<br>&emsp;&emsp;&emsp;&emsp;int mNextFrame = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="check_every_x_frames" type="xs:int" default="30">
				<xs:annotation>
					<xs:documentation>`30` - `[0, 1]`</xs:documentation>
					<xs:documentation>how often do we check the world</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="state" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>0 is up, 1 is down</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="material_percent" type="xs:decimal" default="0.75">
				<xs:annotation>
					<xs:documentation>`0.75` - `[0, 1]`</xs:documentation>
					<xs:documentation>how much material should there be in the aabbs that we go down </xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="aabb_min.x" type="xs:decimal" default="0" />
			<xs:attribute name="aabb_min.y" type="xs:decimal" default="0" />
			<xs:attribute name="aabb_max.x" type="xs:decimal" default="0" />
			<xs:attribute name="aabb_max.y" type="xs:decimal" default="0" />
			<xs:attribute name="mNextFrame" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="ProjectileComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ProjectileComponent {<br>&emsp;&emsp;&emsp;&emsp;int lifetime = -1; // [0, 1] lifetime, -1 means it's endless, otherwise it's the frame count<br>&emsp;&emsp;&emsp;&emsp;int lifetime_randomness = 0; // [0, 1] final lifetime will be lifetime + random(-lifetime_randomness,lifetime_randomness)<br>&emsp;&emsp;&emsp;&emsp;bool on_lifetime_out_explode = 0; // [0, 1] when lifetime runs out, should we explode?<br>&emsp;&emsp;&emsp;&emsp;bool collide_with_world = 1; // [0, 1] true by default. Some projectiles you don't want to collide with the world, e.g. blackholes<br>&emsp;&emsp;&emsp;&emsp;float speed_min = 60; // [0, 60000] <br>&emsp;&emsp;&emsp;&emsp;float speed_max = 60; // [0, 60000] <br>&emsp;&emsp;&emsp;&emsp;float friction = 0; // [0, 60000] <br>&emsp;&emsp;&emsp;&emsp;float direction_random_rad = 0; // [0, 3.14151] when fired, randomizes the velocity -this, this<br>&emsp;&emsp;&emsp;&emsp;float direction_nonrandom_rad = 0; // [-3.14, 3.14] when fired, multiplies this with projectile_i and adds it to direction<br>&emsp;&emsp;&emsp;&emsp;float lob_min = 0.5; // [0, 60000] <br>&emsp;&emsp;&emsp;&emsp;float lob_max = 0.8; // [0, 60000] <br>&emsp;&emsp;&emsp;&emsp;float camera_shake_when_shot = 0; // [0, 60000] <br>&emsp;&emsp;&emsp;&emsp;float shoot_light_flash_radius = 0; // [0, 60000] <br>&emsp;&emsp;&emsp;&emsp;unsigned int shoot_light_flash_r = 255; // [0, 255] <br>&emsp;&emsp;&emsp;&emsp;unsigned int shoot_light_flash_g = 180; // [0, 255] <br>&emsp;&emsp;&emsp;&emsp;unsigned int shoot_light_flash_b = 150; // [0, 255] <br>&emsp;&emsp;&emsp;&emsp;bool create_shell_casing = 0; // [0, 1] should we create shell casings?<br>&emsp;&emsp;&emsp;&emsp;std::string shell_casing_material = "brass"; // [0, 1] material of the shell casing<br>&emsp;&emsp;&emsp;&emsp;std::string muzzle_flash_file; //  this entity is created along with the projectile, oriented along the projectile's path<br>&emsp;&emsp;&emsp;&emsp;int bounces_left = 0; // [0, 1e+008] <br>&emsp;&emsp;&emsp;&emsp;float bounce_energy = 0.5; // [0, 1] when bouncing, velocity is multiplied by this<br>&emsp;&emsp;&emsp;&emsp;bool bounce_always = 0; // [0, 1] if true, will do a fake bounce if can't do the proper bounce, but will always try to bounce<br>&emsp;&emsp;&emsp;&emsp;bool bounce_at_any_angle = 0; // [0, 1] if true, will bounce at any reflection angle<br>&emsp;&emsp;&emsp;&emsp;bool attach_to_parent_trigger = 0; // [0, 1] if true, will attach to the projectile entity that created this projectile via a trigger<br>&emsp;&emsp;&emsp;&emsp;std::string bounce_fx_file; //  this entity is created at the bounce position. it gets the bounce angle as rotation.<br>&emsp;&emsp;&emsp;&emsp;float angular_velocity = 0; // [-3.1415, 3.1415] this is only applied if velocity_sets_rotation == false<br>&emsp;&emsp;&emsp;&emsp;bool velocity_sets_rotation = 1; // [0, 1] whether we set the rotation based on velocity, as in spear or if we update the rotation with angular_velocity<br>&emsp;&emsp;&emsp;&emsp;bool velocity_sets_scale = 0; // [0, 1] if true, the sprite width is made equal to the distance traveled since last frame<br>&emsp;&emsp;&emsp;&emsp;float velocity_sets_scale_coeff = 1; // [0, 1] Larger value means velocity affects the scale more<br>&emsp;&emsp;&emsp;&emsp;bool velocity_sets_y_flip = 0; // [0, 1] if true, the sprite is flipped based on which side the projectile is currently traveling<br>&emsp;&emsp;&emsp;&emsp;float velocity_updates_animation = 0; // [0, 1] updates the animation based on far the sprite moved<br>&emsp;&emsp;&emsp;&emsp;float ground_penetration_coeff = 0; // [0, 5] if > 0, this, along with VelocityComponent.mass affects how far we penetrate in materials<br>&emsp;&emsp;&emsp;&emsp;int ground_penetration_max_durability_to_destroy = 0; // [0, 1] if 0, will not penetrate into materials with durability greater than this<br>&emsp;&emsp;&emsp;&emsp;std::string go_through_this_material; //  if set, we never collide with this material<br>&emsp;&emsp;&emsp;&emsp;bool do_moveto_update = 1; // [0, 1] this should probably be true, to get normal projectile behaviour, but you might want to disable this for some physics-based projectiles, like bombs<br>&emsp;&emsp;&emsp;&emsp;int on_death_duplicate_remaining = 0; // [0, 1] if greater than 0, the projectile creates two clones of itself on death. 'on_death_duplicate_remaining' on the clones is reduced by one<br>&emsp;&emsp;&emsp;&emsp;bool on_death_gfx_leave_sprite = 1; // [0, 1] if true, finds all the sprites and leaves as sand cells into the grid<br>&emsp;&emsp;&emsp;&emsp;bool on_death_explode = 0; // [0, 1] if true, does explosion with config_explosion<br>&emsp;&emsp;&emsp;&emsp;bool on_death_emit_particle = 0; // [0, 1] if true, emits on_death_emit_particle_type on death<br>&emsp;&emsp;&emsp;&emsp;int on_death_emit_particle_count = 1; // [0, 1] how many particles should we emit<br>&emsp;&emsp;&emsp;&emsp;bool die_on_liquid_collision = 0; // [0, 1] if true, dies on collision with liquids<br>&emsp;&emsp;&emsp;&emsp;bool die_on_low_velocity = 0; // [0, 1] if true, dies when speed goes below die_on_low_velocity_limit<br>&emsp;&emsp;&emsp;&emsp;float die_on_low_velocity_limit = 50; // [0, 1] please see die_on_low_velocity<br>&emsp;&emsp;&emsp;&emsp;std::string on_death_emit_particle_type;<br>&emsp;&emsp;&emsp;&emsp;bool on_death_particle_check_concrete = 0; // [0, 1] if you want it to stick as concrete, you should enable this<br>&emsp;&emsp;&emsp;&emsp;bool ground_collision_fx = 1; // [0, 1] if 1, spurt some particles when colliding with mortals<br>&emsp;&emsp;&emsp;&emsp;bool explosion_dont_damage_shooter = 0; // [0, 1] if true, explosion doesn't damage the entity who shot this<br>&emsp;&emsp;&emsp;&emsp;float on_death_item_pickable_radius = 0; // [0, 1] if > 0, makes items closer than this radius pickable on death<br>&emsp;&emsp;&emsp;&emsp;bool penetrate_world = 0; // [0, 1] if true, the projectile doesn't collide with ground, liquids, physical objects etc<br>&emsp;&emsp;&emsp;&emsp;float penetrate_world_velocity_coeff = 0.6; // [0, 1] if 'penetrate_world' is true, the projectile moves with a velocity multiplied by this value when inside world<br>&emsp;&emsp;&emsp;&emsp;bool penetrate_entities = 0; // [0, 1] if true, the projectile doesn't stop when it collides with entities. damages each entity only once<br>&emsp;&emsp;&emsp;&emsp;bool on_collision_die = 1; // [0, 1] if true, this is killed as soon as it hits the ground<br>&emsp;&emsp;&emsp;&emsp;bool on_collision_remove_projectile = 0; // [0, 1] if true, ProjectileComponent is removed from the entitiy<br>&emsp;&emsp;&emsp;&emsp;bool on_collision_spawn_entity = 1; // [0, 1] if true, spawns the spawn_entity<br>&emsp;&emsp;&emsp;&emsp;std::string spawn_entity; //  this is spawned if hit something an on_collision_spawn_entity = 1<br>&emsp;&emsp;&emsp;&emsp;bool spawn_entity_is_projectile = 0; // [0, 1] if true, will use ShootProjectile instead of LoadEntity()<br>&emsp;&emsp;&emsp;&emsp;float physics_impulse_coeff = 300; // [0, 1] projectile applies an impulse to physics bodies it hits. Impulse = physics_impulse_coeff * velocity<br>&emsp;&emsp;&emsp;&emsp;int damage_every_x_frames = -1; // [0, 1] if set != -1, will only do damage every x frames, used for fields and such, which would otherwise do damage every frame<br>&emsp;&emsp;&emsp;&emsp;bool damage_scaled_by_speed = 0; // [0, 1] if 1, damage is multiplied by (projectile speed / original projectile speed) ratio<br>&emsp;&emsp;&emsp;&emsp;float damage_scale_max_speed = 0; // [0, 1] if > 0 and damage_scaled_by_speed = 1, will use this instead of mInitialSpeed when calculating the damage<br>&emsp;&emsp;&emsp;&emsp;bool collide_with_entities = 1; // [0, 1] if 1, looks for entities with tag, collide_with_tag and collides with them, giving them damage<br>&emsp;&emsp;&emsp;&emsp;std::string collide_with_tag = "hittable"; // [0, 1] default: mortal, if you needed can be changed to something more specific<br>&emsp;&emsp;&emsp;&emsp;std::string dont_collide_with_tag; //  if set will ignore entities with this tag<br>&emsp;&emsp;&emsp;&emsp;int collide_with_shooter_frames = -1; // [0, 1] remember friendly_fire 1, if -1 won't collide with shooter at all, otherwise uses the value as frame count and while it's running won't damage the shooter <br>&emsp;&emsp;&emsp;&emsp;bool friendly_fire = 0; // [0, 1] if true, will damage same herd id<br>&emsp;&emsp;&emsp;&emsp;float damage = 1; // [0, 1] how much Projectile damage does this do when it hits something<br>&emsp;&emsp;&emsp;&emsp;float knockback_force = 0; // [0, 1] How far do entities get thrown if a knockback occurs. final_knockback = ProjectileComponent.knockback_force * VelocityComponent.mVelocity * VelocityComponent.mass / who_we_hit.mass<br>&emsp;&emsp;&emsp;&emsp;float ragdoll_force_multiplier = 0.025; // [0, 1] velocity * ragdoll_force_multiplier is applied to any ragdolls that are created by entities killed by this<br>&emsp;&emsp;&emsp;&emsp;float hit_particle_force_multiplier = 0.1; // [0, 1] hit particle velocity = projectile_velocity * hit_particle_force_multiplier * some randomness<br>&emsp;&emsp;&emsp;&emsp;float blood_count_multiplier = 1; // [0, 1] how much blood does this projectile cause<br>&emsp;&emsp;&emsp;&emsp;std::string damage_game_effect_entities; //  a list of game_effects entities separated with ','. e.g. 'data/entities/misc/effect_electrocution.xml,data/entities/misc/effect_on_fire.xml' <br>&emsp;&emsp;&emsp;&emsp;bool never_hit_player = 0; // [0, 1] If 1, does not hit player no matter what herds this and player belong to<br>&emsp;&emsp;&emsp;&emsp;bool collect_materials_to_shooter = 0; // [0, 1] if 1, looks up the 'who_shot' entity and its MaterialInventoryComponent on destruction and updates it based on the cells destroyed on our explosion.<br>&emsp;&emsp;&emsp;&emsp;bool play_damage_sounds = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mLastFrameDamaged = -1024; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;ConfigGunActionInfo config;<br>&emsp;&emsp;&emsp;&emsp;ConfigExplosion config_explosion; //  if we have explosion, it's the setup for it<br>&emsp;&emsp;&emsp;&emsp;ConfigDamagesByType damage_by_type; //  the amounts of different types of damage this does<br>&emsp;&emsp;&emsp;&emsp;ConfigDamageCritical damage_critical; //  config for critical hit<br>&emsp;&emsp;&emsp;&emsp;PROJECTILE_TYPE::Enum projectile_type;<br>&emsp;&emsp;&emsp;&emsp;vec2 shell_casing_offset; //  where the shell casing will be created relative to projectile, y is flipped if projectile direction is to the left.<br>&emsp;&emsp;&emsp;&emsp;RAGDOLL_FX::Enum ragdoll_fx_on_collision; //  if not NORMAL, do a special ragdoll<br>&emsp;&emsp;&emsp;&emsp;EntityID mWhoShot = 0; // [0, 1] entity (creature) that shot this<br>&emsp;&emsp;&emsp;&emsp;EntityTypeID mWhoShotEntityTypeID = 0; // [0, 1] used for stats<br>&emsp;&emsp;&emsp;&emsp;int mShooterHerdId = 0; // [0, 1] the herdid of mWhoShot, unless friendly fire<br>&emsp;&emsp;&emsp;&emsp;int mStartingLifetime = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;EntityID mEntityThatShot = 0; // [0, 1] for triggers, if shot from a trigger this should point to the projectile entity that shot this. Otherwise this should be the same as mWhoShot. NOTE! Not really tested properly so might break.<br>&emsp;&emsp;&emsp;&emsp;ProjectileTriggers mTriggers;<br>&emsp;&emsp;&emsp;&emsp;VEC_ENTITY mDamagedEntities;<br>&emsp;&emsp;&emsp;&emsp;float mInitialSpeed = -1; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="lifetime" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
					<xs:documentation>lifetime, -1 means it's endless, otherwise it's the frame count</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="lifetime_randomness" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>final lifetime will be lifetime + random(-lifetime_randomness,lifetime_randomness)</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="on_lifetime_out_explode" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>when lifetime runs out, should we explode?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="collide_with_world" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>true by default. Some projectiles you don't want to collide with the world, e.g. blackholes</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="speed_min" type="xs:decimal" default="60">
				<xs:annotation>
					<xs:documentation>`60` - `[0, 60000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="speed_max" type="xs:decimal" default="60">
				<xs:annotation>
					<xs:documentation>`60` - `[0, 60000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="friction" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 60000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="direction_random_rad" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 3.14151]`</xs:documentation>
					<xs:documentation>when fired, randomizes the velocity -this, this</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="direction_nonrandom_rad" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-3.14, 3.14]`</xs:documentation>
					<xs:documentation>when fired, multiplies this with projectile_i and adds it to direction</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="lob_min" type="xs:decimal" default="0.5">
				<xs:annotation>
					<xs:documentation>`0.5` - `[0, 60000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="lob_max" type="xs:decimal" default="0.8">
				<xs:annotation>
					<xs:documentation>`0.8` - `[0, 60000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="camera_shake_when_shot" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 60000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="shoot_light_flash_radius" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 60000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="shoot_light_flash_r" type="xs:unsignedInt" default="255">
				<xs:annotation>
					<xs:documentation>`255` - `[0, 255]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="shoot_light_flash_g" type="xs:unsignedInt" default="180">
				<xs:annotation>
					<xs:documentation>`180` - `[0, 255]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="shoot_light_flash_b" type="xs:unsignedInt" default="150">
				<xs:annotation>
					<xs:documentation>`150` - `[0, 255]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="create_shell_casing" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>should we create shell casings?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="shell_casing_material" type="xs:string" default="brass">
				<xs:annotation>
					<xs:documentation>`brass` - `[0, 1]`</xs:documentation>
					<xs:documentation>material of the shell casing</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="muzzle_flash_file" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>this entity is created along with the projectile, oriented along the projectile's path</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="bounces_left" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1e+008]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="bounce_energy" type="xs:decimal" default="0.5">
				<xs:annotation>
					<xs:documentation>`0.5` - `[0, 1]`</xs:documentation>
					<xs:documentation>when bouncing, velocity is multiplied by this</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="bounce_always" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, will do a fake bounce if can't do the proper bounce, but will always try to bounce</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="bounce_at_any_angle" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, will bounce at any reflection angle</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="attach_to_parent_trigger" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, will attach to the projectile entity that created this projectile via a trigger</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="bounce_fx_file" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>this entity is created at the bounce position. it gets the bounce angle as rotation.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="angular_velocity" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-3.1415, 3.1415]`</xs:documentation>
					<xs:documentation>this is only applied if velocity_sets_rotation == false</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="velocity_sets_rotation" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>whether we set the rotation based on velocity, as in spear or if we update the rotation with angular_velocity</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="velocity_sets_scale" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, the sprite width is made equal to the distance traveled since last frame</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="velocity_sets_scale_coeff" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>Larger value means velocity affects the scale more</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="velocity_sets_y_flip" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, the sprite is flipped based on which side the projectile is currently traveling</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="velocity_updates_animation" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>updates the animation based on far the sprite moved</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ground_penetration_coeff" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 5]`</xs:documentation>
					<xs:documentation>if &gt; 0, this, along with VelocityComponent.mass affects how far we penetrate in materials</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ground_penetration_max_durability_to_destroy" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 0, will not penetrate into materials with durability greater than this</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="go_through_this_material" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>if set, we never collide with this material</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="do_moveto_update" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>this should probably be true, to get normal projectile behaviour, but you might want to disable this for some physics-based projectiles, like bombs</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="on_death_duplicate_remaining" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if greater than 0, the projectile creates two clones of itself on death. 'on_death_duplicate_remaining' on the clones is reduced by one</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="on_death_gfx_leave_sprite" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, finds all the sprites and leaves as sand cells into the grid</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="on_death_explode" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, does explosion with config_explosion</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="on_death_emit_particle" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, emits on_death_emit_particle_type on death</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="on_death_emit_particle_count" type="xs:int" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>how many particles should we emit</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="die_on_liquid_collision" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, dies on collision with liquids</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="die_on_low_velocity" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, dies when speed goes below die_on_low_velocity_limit</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="die_on_low_velocity_limit" type="xs:decimal" default="50">
				<xs:annotation>
					<xs:documentation>`50` - `[0, 1]`</xs:documentation>
					<xs:documentation>please see die_on_low_velocity</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="on_death_emit_particle_type" type="xs:string" default="" />
			<xs:attribute name="on_death_particle_check_concrete" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if you want it to stick as concrete, you should enable this</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ground_collision_fx" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, spurt some particles when colliding with mortals</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="explosion_dont_damage_shooter" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, explosion doesn't damage the entity who shot this</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="on_death_item_pickable_radius" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if &gt; 0, makes items closer than this radius pickable on death</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="penetrate_world" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, the projectile doesn't collide with ground, liquids, physical objects etc</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="penetrate_world_velocity_coeff" type="xs:decimal" default="0.6">
				<xs:annotation>
					<xs:documentation>`0.6` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 'penetrate_world' is true, the projectile moves with a velocity multiplied by this value when inside world</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="penetrate_entities" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, the projectile doesn't stop when it collides with entities. damages each entity only once</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="on_collision_die" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, this is killed as soon as it hits the ground</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="on_collision_remove_projectile" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, ProjectileComponent is removed from the entitiy</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="on_collision_spawn_entity" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, spawns the spawn_entity</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="spawn_entity" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>this is spawned if hit something an on_collision_spawn_entity = 1</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="spawn_entity_is_projectile" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, will use ShootProjectile instead of LoadEntity()</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="physics_impulse_coeff" type="xs:decimal" default="300">
				<xs:annotation>
					<xs:documentation>`300` - `[0, 1]`</xs:documentation>
					<xs:documentation>projectile applies an impulse to physics bodies it hits. Impulse = physics_impulse_coeff * velocity</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="damage_every_x_frames" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if set != -1, will only do damage every x frames, used for fields and such, which would otherwise do damage every frame</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="damage_scaled_by_speed" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, damage is multiplied by (projectile speed / original projectile speed) ratio</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="damage_scale_max_speed" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if &gt; 0 and damage_scaled_by_speed = 1, will use this instead of mInitialSpeed when calculating the damage</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="collide_with_entities" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, looks for entities with tag, collide_with_tag and collides with them, giving them damage</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="collide_with_tag" type="xs:string" default="hittable">
				<xs:annotation>
					<xs:documentation>`hittable` - `[0, 1]`</xs:documentation>
					<xs:documentation>default: mortal, if you needed can be changed to something more specific</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="dont_collide_with_tag" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>if set will ignore entities with this tag</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="collide_with_shooter_frames" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
					<xs:documentation>remember friendly_fire 1, if -1 won't collide with shooter at all, otherwise uses the value as frame count and while it's running won't damage the shooter </xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="friendly_fire" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, will damage same herd id</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="damage" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>how much Projectile damage does this do when it hits something</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="knockback_force" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>How far do entities get thrown if a knockback occurs. final_knockback = ProjectileComponent.knockback_force * VelocityComponent.mVelocity * VelocityComponent.mass / who_we_hit.mass</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ragdoll_force_multiplier" type="xs:decimal" default="0.025">
				<xs:annotation>
					<xs:documentation>`0.025` - `[0, 1]`</xs:documentation>
					<xs:documentation>velocity * ragdoll_force_multiplier is applied to any ragdolls that are created by entities killed by this</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="hit_particle_force_multiplier" type="xs:decimal" default="0.1">
				<xs:annotation>
					<xs:documentation>`0.1` - `[0, 1]`</xs:documentation>
					<xs:documentation>hit particle velocity = projectile_velocity * hit_particle_force_multiplier * some randomness</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="blood_count_multiplier" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>how much blood does this projectile cause</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="damage_game_effect_entities" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>a list of game_effects entities separated with ','. e.g. 'data/entities/misc/effect_electrocution.xml,data/entities/misc/effect_on_fire.xml' </xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="never_hit_player" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>If 1, does not hit player no matter what herds this and player belong to</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="collect_materials_to_shooter" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, looks up the 'who_shot' entity and its MaterialInventoryComponent on destruction and updates it based on the cells destroyed on our explosion.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="play_damage_sounds" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mLastFrameDamaged" type="xs:int" default="-1024">
				<xs:annotation>
					<xs:documentation>`-1024` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: ConfigGunActionInfo for config -->
				<!-- Some Unknown Type: ConfigExplosion for config_explosion -->
				<!-- Some Unknown Type: ConfigDamagesByType for damage_by_type -->
				<!-- Some Unknown Type: ConfigDamageCritical for damage_critical -->
				<!-- Some Unknown Type: PROJECTILE_TYPE::Enum for projectile_type -->
			<xs:attribute name="shell_casing_offset.x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>where the shell casing will be created relative to projectile, y is flipped if projectile direction is to the left.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="shell_casing_offset.y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>where the shell casing will be created relative to projectile, y is flipped if projectile direction is to the left.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: RAGDOLL_FX::Enum for ragdoll_fx_on_collision -->
				<!-- Some Unknown Type: EntityID for mWhoShot -->
				<!-- Some Unknown Type: EntityTypeID for mWhoShotEntityTypeID -->
			<xs:attribute name="mShooterHerdId" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>the herdid of mWhoShot, unless friendly fire</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mStartingLifetime" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: EntityID for mEntityThatShot -->
				<!-- Some Unknown Type: ProjectileTriggers for mTriggers -->
				<!-- Some Unknown Type: VEC_ENTITY for mDamagedEntities -->
			<xs:attribute name="mInitialSpeed" type="xs:decimal" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="RotateTowardsComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class RotateTowardsComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string entity_with_tag = "player_unit"; // [0, 1] will rotate this entity towards the closest entity with tag<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="entity_with_tag" type="xs:string" default="player_unit">
				<xs:annotation>
					<xs:documentation>`player_unit` - `[0, 1]`</xs:documentation>
					<xs:documentation>will rotate this entity towards the closest entity with tag</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="SetLightAlphaFromVelocityComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class SetLightAlphaFromVelocityComponent {<br>&emsp;&emsp;&emsp;&emsp;float max_velocity = 50; // [1, 150] <br>&emsp;&emsp;&emsp;&emsp;vec2 mPrevPosition;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="max_velocity" type="xs:decimal" default="50">
				<xs:annotation>
					<xs:documentation>`50` - `[1, 150]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mPrevPosition.x" type="xs:decimal" default="0" />
			<xs:attribute name="mPrevPosition.y" type="xs:decimal" default="0" />
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="SetStartVelocityComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class SetStartVelocityComponent {<br>&emsp;&emsp;&emsp;&emsp;vec2 velocity; //  This is added together with random velocity<br>&emsp;&emsp;&emsp;&emsp;ValueRange randomize_angle; //  Random angle min max range in radians, clockwise. 0.0 points directly rightward.<br>&emsp;&emsp;&emsp;&emsp;ValueRange randomize_speed; //  Random speed min max range<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="velocity.x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>This is added together with random velocity</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="velocity.y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>This is added together with random velocity</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="randomize_angle.min" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>Random angle min max range in radians, clockwise. 0.0 points directly rightward.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="randomize_angle.max" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>Random angle min max range in radians, clockwise. 0.0 points directly rightward.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="randomize_speed.min" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>Random speed min max range</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="randomize_speed.max" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>Random speed min max range</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="ShotEffectComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class ShotEffectComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string extra_modifier; //  name of modifier function executed per projectile from 'gun_extra_modifiers.lua'<br>&emsp;&emsp;&emsp;&emsp;GAME_EFFECT::Enum condition_effect; //  Shooting entity needs to have this 'GAME_EFFECT' for effects to apply. If both 'condition_effect' and 'condition_status' are set, they are combined with AND logic<br>&emsp;&emsp;&emsp;&emsp;StatusEffectType condition_status = 0; // [0, 1] Shooting entity needs to have this 'STATUS_EFFECT' for effects to apply<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="extra_modifier" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>name of modifier function executed per projectile from 'gun_extra_modifiers.lua'</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: GAME_EFFECT::Enum for condition_effect -->
				<!-- Some Unknown Type: StatusEffectType for condition_status -->
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="SimplePhysicsComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class SimplePhysicsComponent {<br>&emsp;&emsp;&emsp;&emsp;bool can_go_up = 1; // [0, 1] if set, will not try to move this upwards<br>&emsp;&emsp;&emsp;&emsp;vec2 mOldPosition; //  used for box2d simple physics<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="can_go_up" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if set, will not try to move this upwards</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mOldPosition.x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>used for box2d simple physics</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mOldPosition.y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>used for box2d simple physics</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="SineWaveComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class SineWaveComponent {<br>&emsp;&emsp;&emsp;&emsp;float sinewave_freq = 1; // [0, 1] sinewave_m * sinf( sinewave_freq * lifetime++)<br>&emsp;&emsp;&emsp;&emsp;float sinewave_m = 0.6; // [0, 1] sinewave_m * sinf( sinewave_freq * lifetime++)<br>&emsp;&emsp;&emsp;&emsp;int lifetime = -1; // [0, 1] -1 seems to fix some problems with this... sinewave_m * sinf( sinewave_freq * lifetime++)<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="sinewave_freq" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>sinewave_m * sinf( sinewave_freq * lifetime++)</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="sinewave_m" type="xs:decimal" default="0.6">
				<xs:annotation>
					<xs:documentation>`0.6` - `[0, 1]`</xs:documentation>
					<xs:documentation>sinewave_m * sinf( sinewave_freq * lifetime++)</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="lifetime" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
					<xs:documentation>-1 seems to fix some problems with this... sinewave_m * sinf( sinewave_freq * lifetime++)</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="SpriteAnimatorComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class SpriteAnimatorComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string target_sprite_comp_name = "character"; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool rotate_to_surface_normal = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;STACK_ANIMATIONSTATE mStates;<br>&emsp;&emsp;&emsp;&emsp;ComponentTags mCachedTargetSpriteTag;<br>&emsp;&emsp;&emsp;&emsp;std::string mSendOnFinishedMessageName;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="target_sprite_comp_name" type="xs:string" default="character">
				<xs:annotation>
					<xs:documentation>`character` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="rotate_to_surface_normal" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: STACK_ANIMATIONSTATE for mStates -->
				<!-- Some Unknown Type: ComponentTags for mCachedTargetSpriteTag -->
			<xs:attribute name="mSendOnFinishedMessageName" type="xs:string" default="" />
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="SpriteComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class SpriteComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string image_file = "data/temp/temp_gun.png"; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool ui_is_parent = 0; // [0, 1] Adds this to the GG.GetUISprite() as a child, instead of the mSpriteContainer<br>&emsp;&emsp;&emsp;&emsp;bool is_text_sprite = 0; // [0, 1] if you want to load a text sprite, set this to true and image_file to a font file<br>&emsp;&emsp;&emsp;&emsp;float offset_x = 0; // [-24, 24] <br>&emsp;&emsp;&emsp;&emsp;float offset_y = 0; // [-24, 24] <br>&emsp;&emsp;&emsp;&emsp;float alpha = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool visible = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool emissive = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool additive = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool fog_of_war_hole = 0; // [0, 1] if 1, the alpha channel of this texture punctures a hole in the fog of war<br>&emsp;&emsp;&emsp;&emsp;bool smooth_filtering = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;std::string rect_animation;<br>&emsp;&emsp;&emsp;&emsp;std::string next_rect_animation;<br>&emsp;&emsp;&emsp;&emsp;std::string text;<br>&emsp;&emsp;&emsp;&emsp;float z_index = 1; // [-256, 256] 0 = world grid, -1 = enemies, -1.5 = items in world, player = 0.6<br>&emsp;&emsp;&emsp;&emsp;bool update_transform = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool update_transform_rotation = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool kill_entity_after_finished = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool has_special_scale = 0; // [0, 1] if this is set, sets special_scale_x and _y to scale<br>&emsp;&emsp;&emsp;&emsp;float special_scale_x = 1; // [0, 1] this overrides the scale of the entity, if has_special_scale<br>&emsp;&emsp;&emsp;&emsp;float special_scale_y = 1; // [0, 1] this overrides the scale of the entity, if has_special_scale<br>&emsp;&emsp;&emsp;&emsp;bool never_ragdollify_on_death = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;vec2 transform_offset;<br>&emsp;&emsp;&emsp;&emsp;vec2 offset_animator_offset; //  used by SpriteOffsetAnimator<br>&emsp;&emsp;&emsp;&emsp;as::Sprite* mSprite;<br>&emsp;&emsp;&emsp;&emsp;SpriteRenderList* mRenderList;<br>&emsp;&emsp;&emsp;&emsp;int32 mRenderListHandle = -1; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="image_file" type="xs:string" default="data/temp/temp_gun.png">
				<xs:annotation>
					<xs:documentation>`data/temp/temp_gun.png` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ui_is_parent" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>Adds this to the GG.GetUISprite() as a child, instead of the mSpriteContainer</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_text_sprite" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if you want to load a text sprite, set this to true and image_file to a font file</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="offset_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-24, 24]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="offset_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-24, 24]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="alpha" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="visible" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="emissive" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="additive" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="fog_of_war_hole" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, the alpha channel of this texture punctures a hole in the fog of war</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="smooth_filtering" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="rect_animation" type="xs:string" default="" />
			<xs:attribute name="next_rect_animation" type="xs:string" default="" />
			<xs:attribute name="text" type="xs:string" default="" />
			<xs:attribute name="z_index" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[-256, 256]`</xs:documentation>
					<xs:documentation>0 = world grid, -1 = enemies, -1.5 = items in world, player = 0.6</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="update_transform" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="update_transform_rotation" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="kill_entity_after_finished" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="has_special_scale" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if this is set, sets special_scale_x and _y to scale</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="special_scale_x" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>this overrides the scale of the entity, if has_special_scale</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="special_scale_y" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>this overrides the scale of the entity, if has_special_scale</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="never_ragdollify_on_death" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="transform_offset.x" type="xs:decimal" default="0" />
			<xs:attribute name="transform_offset.y" type="xs:decimal" default="0" />
			<xs:attribute name="offset_animator_offset.x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>used by SpriteOffsetAnimator</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="offset_animator_offset.y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>used by SpriteOffsetAnimator</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: as::Sprite* for mSprite -->
				<!-- Some Unknown Type: SpriteRenderList* for mRenderList -->
			<xs:attribute name="mRenderListHandle" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="SpriteOffsetAnimatorComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class SpriteOffsetAnimatorComponent {<br>&emsp;&emsp;&emsp;&emsp;float x_amount = 0; // [0, 5] <br>&emsp;&emsp;&emsp;&emsp;float x_speed = 0; // [0, 5] <br>&emsp;&emsp;&emsp;&emsp;float y_amount = 2; // [0, 5] <br>&emsp;&emsp;&emsp;&emsp;float y_speed = 2; // [0, 5] <br>&emsp;&emsp;&emsp;&emsp;int sprite_id = 0; // [0, 8] <br>&emsp;&emsp;&emsp;&emsp;float x_phase = 16; // [0, 32] <br>&emsp;&emsp;&emsp;&emsp;float x_phase_offset = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="x_amount" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 5]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="x_speed" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 5]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="y_amount" type="xs:decimal" default="2">
				<xs:annotation>
					<xs:documentation>`2` - `[0, 5]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="y_speed" type="xs:decimal" default="2">
				<xs:annotation>
					<xs:documentation>`2` - `[0, 5]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="sprite_id" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 8]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="x_phase" type="xs:decimal" default="16">
				<xs:annotation>
					<xs:documentation>`16` - `[0, 32]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="x_phase_offset" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="SpriteParticleEmitterComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class SpriteParticleEmitterComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string sprite_file; //  filepath to the sprite(s), supports the $[0-3] syntax<br>&emsp;&emsp;&emsp;&emsp;bool sprite_centered = 0; // [0, 1] sets the offset to the center of the image<br>&emsp;&emsp;&emsp;&emsp;bool sprite_random_rotation = 0; // [0, 1] rotates the sprite randomly in 90 degree angles<br>&emsp;&emsp;&emsp;&emsp;bool render_back = 0; // [0, 1] if true, will set this particle to be behind entities (won't emit light)<br>&emsp;&emsp;&emsp;&emsp;float delay = 0; // [0, 1] delay in seconds...<br>&emsp;&emsp;&emsp;&emsp;float lifetime = 0; // [0, 1] lifetime in seconds...<br>&emsp;&emsp;&emsp;&emsp;bool additive = 0; // [0, 1] if 1, the sprites will be rendered using additive blending<br>&emsp;&emsp;&emsp;&emsp;bool emissive = 0; // [0, 1] if 1, the sprites will be rendered onto the emissive render target<br>&emsp;&emsp;&emsp;&emsp;float velocity_slowdown = 0; // [0, 1] what percent of the velocity is slowed by *dt<br>&emsp;&emsp;&emsp;&emsp;float rotation = 0; // [0, 1] original rotation in rads<br>&emsp;&emsp;&emsp;&emsp;float angular_velocity = 0; // [0, 1] how much rotation there is in a second<br>&emsp;&emsp;&emsp;&emsp;bool use_velocity_as_rotation = 0; // [0, 1] do we rotate the sprite based on the velocity<br>&emsp;&emsp;&emsp;&emsp;bool use_rotation_from_velocity_component = 0; // [0, 1] if set, will set the initial rotation based on the velocity component's velocity<br>&emsp;&emsp;&emsp;&emsp;bool use_rotation_from_entity = 0; // [0, 1] if set, will 'inherit' rotation from the entity<br>&emsp;&emsp;&emsp;&emsp;float entity_velocity_multiplier = 0; // [0, 1] 0 = doesn't use the velocity from spawning entity at all, 1 = uses all<br>&emsp;&emsp;&emsp;&emsp;float z_index = 0; // [0, 1] Depth of created particles<br>&emsp;&emsp;&emsp;&emsp;bool randomize_position_inside_hitbox = 0; // [0, 1] if set, will randomize position inside the hitbox aabb<br>&emsp;&emsp;&emsp;&emsp;bool velocity_always_away_from_center = 0; // [0, 1] if set, will make the velocity's rotation always away from center of randomized aabb<br>&emsp;&emsp;&emsp;&emsp;bool camera_bound = 1; // [0, 1] if true, will be culled if not near the camera<br>&emsp;&emsp;&emsp;&emsp;float camera_distance = 75; // [0, 1] if the distance from camera (edges) is higher than this, this will be culled<br>&emsp;&emsp;&emsp;&emsp;bool is_emitting = 1; // [0, 1] disable this from emitting...<br>&emsp;&emsp;&emsp;&emsp;int count_min = 0; // [0, 1] how many particles do we spawn at one time<br>&emsp;&emsp;&emsp;&emsp;int count_max = 1; // [0, 1] how many particles do we spawn at one time<br>&emsp;&emsp;&emsp;&emsp;int emission_interval_min_frames = 5; // [0, 200] how often do we emit particles<br>&emsp;&emsp;&emsp;&emsp;int emission_interval_max_frames = 10; // [0, 200] how often do we emit particles<br>&emsp;&emsp;&emsp;&emsp;std::string entity_file; //  if set, this entity is loaded to the emission position by the emitter when it emits<br>&emsp;&emsp;&emsp;&emsp;types::fcolor color; //  original color<br>&emsp;&emsp;&emsp;&emsp;types::fcolor color_change; //  how much the color changes in a second<br>&emsp;&emsp;&emsp;&emsp;vec2 velocity; //  original velocity<br>&emsp;&emsp;&emsp;&emsp;vec2 gravity; //  gravity<br>&emsp;&emsp;&emsp;&emsp;vec2 scale; //  original scale<br>&emsp;&emsp;&emsp;&emsp;vec2 scale_velocity; //  scale velocity per second<br>&emsp;&emsp;&emsp;&emsp;ValueRange randomize_lifetime; //  this is added to the lifetime<br>&emsp;&emsp;&emsp;&emsp;types::aabb randomize_position; //  random offset for pos<br>&emsp;&emsp;&emsp;&emsp;types::aabb randomize_velocity; //  add this randomized velocity inside this o the velocity<br>&emsp;&emsp;&emsp;&emsp;types::aabb randomize_scale; //  add this randomized vector2 to scale<br>&emsp;&emsp;&emsp;&emsp;ValueRange randomize_rotation; //  this is added to the rotation <br>&emsp;&emsp;&emsp;&emsp;ValueRange randomize_angular_velocity; //  this is added to angular_velocity<br>&emsp;&emsp;&emsp;&emsp;ValueRange randomize_alpha; //  this is added to the alpha<br>&emsp;&emsp;&emsp;&emsp;ValueRange randomize_animation_speed_coeff; //  if set, animation speed is multiplied by a random value inside this range<br>&emsp;&emsp;&emsp;&emsp;vec2 expand_randomize_position; //  will add dt*this to randomize_position_aabb every frame<br>&emsp;&emsp;&emsp;&emsp;int mNextEmitFrame = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="sprite_file" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>filepath to the sprite(s), supports the $[0-3] syntax</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="sprite_centered" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>sets the offset to the center of the image</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="sprite_random_rotation" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>rotates the sprite randomly in 90 degree angles</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="render_back" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, will set this particle to be behind entities (won't emit light)</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="delay" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>delay in seconds...</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="lifetime" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>lifetime in seconds...</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="additive" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, the sprites will be rendered using additive blending</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="emissive" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, the sprites will be rendered onto the emissive render target</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="velocity_slowdown" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>what percent of the velocity is slowed by *dt</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="rotation" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>original rotation in rads</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="angular_velocity" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>how much rotation there is in a second</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="use_velocity_as_rotation" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>do we rotate the sprite based on the velocity</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="use_rotation_from_velocity_component" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if set, will set the initial rotation based on the velocity component's velocity</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="use_rotation_from_entity" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if set, will 'inherit' rotation from the entity</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="entity_velocity_multiplier" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>0 = doesn't use the velocity from spawning entity at all, 1 = uses all</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="z_index" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>Depth of created particles</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="randomize_position_inside_hitbox" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if set, will randomize position inside the hitbox aabb</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="velocity_always_away_from_center" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if set, will make the velocity's rotation always away from center of randomized aabb</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="camera_bound" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, will be culled if not near the camera</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="camera_distance" type="xs:decimal" default="75">
				<xs:annotation>
					<xs:documentation>`75` - `[0, 1]`</xs:documentation>
					<xs:documentation>if the distance from camera (edges) is higher than this, this will be culled</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_emitting" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>disable this from emitting...</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="count_min" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>how many particles do we spawn at one time</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="count_max" type="xs:int" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>how many particles do we spawn at one time</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="emission_interval_min_frames" type="xs:int" default="5">
				<xs:annotation>
					<xs:documentation>`5` - `[0, 200]`</xs:documentation>
					<xs:documentation>how often do we emit particles</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="emission_interval_max_frames" type="xs:int" default="10">
				<xs:annotation>
					<xs:documentation>`10` - `[0, 200]`</xs:documentation>
					<xs:documentation>how often do we emit particles</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="entity_file" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>if set, this entity is loaded to the emission position by the emitter when it emits</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="color.r" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>original color</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="color.g" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>original color</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="color.b" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>original color</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="color.a" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>original color</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="color_change.r" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>how much the color changes in a second</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="color_change.g" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>how much the color changes in a second</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="color_change.b" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>how much the color changes in a second</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="color_change.a" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>how much the color changes in a second</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="velocity.x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>original velocity</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="velocity.y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>original velocity</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="gravity.x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>gravity</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="gravity.y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>gravity</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="scale.x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>original scale</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="scale.y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>original scale</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="scale_velocity.x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>scale velocity per second</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="scale_velocity.y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>scale velocity per second</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="randomize_lifetime.min" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>this is added to the lifetime</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="randomize_lifetime.max" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>this is added to the lifetime</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="randomize_position.min_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>random offset for pos</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="randomize_position.min_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>random offset for pos</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="randomize_position.max_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>random offset for pos</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="randomize_position.max_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>random offset for pos</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="randomize_velocity.min_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>add this randomized velocity inside this o the velocity</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="randomize_velocity.min_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>add this randomized velocity inside this o the velocity</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="randomize_velocity.max_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>add this randomized velocity inside this o the velocity</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="randomize_velocity.max_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>add this randomized velocity inside this o the velocity</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="randomize_scale.min_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>add this randomized vector2 to scale</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="randomize_scale.min_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>add this randomized vector2 to scale</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="randomize_scale.max_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>add this randomized vector2 to scale</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="randomize_scale.max_y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>add this randomized vector2 to scale</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="randomize_rotation.min" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>this is added to the rotation </xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="randomize_rotation.max" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>this is added to the rotation </xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="randomize_angular_velocity.min" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>this is added to angular_velocity</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="randomize_angular_velocity.max" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>this is added to angular_velocity</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="randomize_alpha.min" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>this is added to the alpha</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="randomize_alpha.max" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>this is added to the alpha</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="randomize_animation_speed_coeff.min" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>if set, animation speed is multiplied by a random value inside this range</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="randomize_animation_speed_coeff.max" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>if set, animation speed is multiplied by a random value inside this range</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="expand_randomize_position.x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>will add dt*this to randomize_position_aabb every frame</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="expand_randomize_position.y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>will add dt*this to randomize_position_aabb every frame</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mNextEmitFrame" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="SpriteStainsComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class SpriteStainsComponent {<br>&emsp;&emsp;&emsp;&emsp;int sprite_id = 0; // [0, 10] which sprite (in the order in which they appear in the entity) are we going to stain?<br>&emsp;&emsp;&emsp;&emsp;bool fade_stains_towards_srite_top = 1; // [0, 1] if 1, shades get less opaque near the top of the sprite<br>&emsp;&emsp;&emsp;&emsp;LensValue<int> stain_shaken_drop_chance_multiplier; //  how quickly stains are dropped relative to normal drop speed<br>&emsp;&emsp;&emsp;&emsp;SpriteStains* mData;<br>&emsp;&emsp;&emsp;&emsp;VirtualTextureHandle mTextureHandle;<br>&emsp;&emsp;&emsp;&emsp;SpriteStainsState mState;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="sprite_id" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 10]`</xs:documentation>
					<xs:documentation>which sprite (in the order in which they appear in the entity) are we going to stain?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="fade_stains_towards_srite_top" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, shades get less opaque near the top of the sprite</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="stain_shaken_drop_chance_multiplier" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>how quickly stains are dropped relative to normal drop speed</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: SpriteStains* for mData -->
				<!-- Some Unknown Type: VirtualTextureHandle for mTextureHandle -->
				<!-- Some Unknown Type: SpriteStainsState for mState -->
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="StatusEffectDataComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class StatusEffectDataComponent {<br>&emsp;&emsp;&emsp;&emsp;VECTOR_FLOAT stain_effects;<br>&emsp;&emsp;&emsp;&emsp;VECTOR_INT32 stain_effect_cooldowns;<br>&emsp;&emsp;&emsp;&emsp;VECTOR_FLOAT effects_previous;<br>&emsp;&emsp;&emsp;&emsp;VECTOR_FLOAT ingestion_effects;<br>&emsp;&emsp;&emsp;&emsp;VEC_OF_MATERIALS ingestion_effect_causes;<br>&emsp;&emsp;&emsp;&emsp;VECTOR_INT32 ingestion_effect_causes_many;<br>&emsp;&emsp;&emsp;&emsp;int mLastAttackingPlayerFrame = -99999; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;VECTOR_FLOAT mStainEffectsSmoothedForUI;<br>&emsp;&emsp;&emsp;&emsp;bool mHasChildIconsCached = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
				<!-- Some Unknown Type: VECTOR_FLOAT for stain_effects -->
				<!-- Some Unknown Type: VECTOR_INT32 for stain_effect_cooldowns -->
				<!-- Some Unknown Type: VECTOR_FLOAT for effects_previous -->
				<!-- Some Unknown Type: VECTOR_FLOAT for ingestion_effects -->
				<!-- Some Unknown Type: VEC_OF_MATERIALS for ingestion_effect_causes -->
				<!-- Some Unknown Type: VECTOR_INT32 for ingestion_effect_causes_many -->
			<xs:attribute name="mLastAttackingPlayerFrame" type="xs:int" default="-99999">
				<xs:annotation>
					<xs:documentation>`-99999` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: VECTOR_FLOAT for mStainEffectsSmoothedForUI -->
			<xs:attribute name="mHasChildIconsCached" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="StreamingKeepAliveComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class StreamingKeepAliveComponent {<br>&emsp;&emsp;&emsp;&emsp;float TEMP_TEMPY = 0; // [0, 3.5] <br>&emsp;&emsp;&emsp;&emsp;float TEMP_TEMP_TEMP = 0; // [0, 3.5] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="TEMP_TEMPY" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 3.5]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="TEMP_TEMP_TEMP" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 3.5]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="TelekinesisComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class TelekinesisComponent {<br>&emsp;&emsp;&emsp;&emsp;uint32 min_size = 7; // [0, 1] Minimum size of physics body that can be grabbed, in cells/pixels<br>&emsp;&emsp;&emsp;&emsp;uint32 max_size = 1500; // [0, 1] Maximum size of physics body that can be grabbed, in cells/pixels<br>&emsp;&emsp;&emsp;&emsp;float radius = 250; // [0, 300] Maximum object search distance<br>&emsp;&emsp;&emsp;&emsp;float throw_speed = 25; // [0, 300] Affects object speed when it is thrown<br>&emsp;&emsp;&emsp;&emsp;float target_distance = 6; // [0, 30] Affects how far objects float from owner when held. Object size will also affect the floating distance.<br>&emsp;&emsp;&emsp;&emsp;bool kick_to_use = 1; // [0, 1] If 1, telekinesis interaction will occur when kick input is detected in root entity's ControlsComponent<br>&emsp;&emsp;&emsp;&emsp;int32 mState = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;uint64 mBodyID = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float mStartBodyMaxExtent = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float mStartAimAngle = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float mStartBodyAngle = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float mStartBodyDistance = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float mStartTime = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float mMinBodyDistance = 340282000000000014192072600942972764160; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mInteract = 0; // [0, 1] If set to true, telekinesis interaction will occur. Will automatically turn to false at the end of component update.<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="min_size" type="xs:unsignedInt" default="7">
				<xs:annotation>
					<xs:documentation>`7` - `[0, 1]`</xs:documentation>
					<xs:documentation>Minimum size of physics body that can be grabbed, in cells/pixels</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="max_size" type="xs:unsignedInt" default="1500">
				<xs:annotation>
					<xs:documentation>`1500` - `[0, 1]`</xs:documentation>
					<xs:documentation>Maximum size of physics body that can be grabbed, in cells/pixels</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="radius" type="xs:decimal" default="250">
				<xs:annotation>
					<xs:documentation>`250` - `[0, 300]`</xs:documentation>
					<xs:documentation>Maximum object search distance</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="throw_speed" type="xs:decimal" default="25">
				<xs:annotation>
					<xs:documentation>`25` - `[0, 300]`</xs:documentation>
					<xs:documentation>Affects object speed when it is thrown</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="target_distance" type="xs:decimal" default="6">
				<xs:annotation>
					<xs:documentation>`6` - `[0, 30]`</xs:documentation>
					<xs:documentation>Affects how far objects float from owner when held. Object size will also affect the floating distance.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="kick_to_use" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>If 1, telekinesis interaction will occur when kick input is detected in root entity's ControlsComponent</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mState" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mBodyID" type="xs:unsignedInt" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mStartBodyMaxExtent" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mStartAimAngle" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mStartBodyAngle" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mStartBodyDistance" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mStartTime" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mMinBodyDistance" type="xs:decimal" default="340282000000000014192072600942972764160">
				<xs:annotation>
					<xs:documentation>`3.40282e+038` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mInteract" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>If set to true, telekinesis interaction will occur. Will automatically turn to false at the end of component update.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="TeleportComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class TeleportComponent {<br>&emsp;&emsp;&emsp;&emsp;bool target_x_is_absolute_position = 0; // [0, 1] If set, target position x is in world coordinates, otherwise it's an offset<br>&emsp;&emsp;&emsp;&emsp;bool target_y_is_absolute_position = 0; // [0, 1] If set, target position y is in world coordinates, otherwise it's an offset<br>&emsp;&emsp;&emsp;&emsp;std::string source_particle_fx_file = "data/entities/particles/teleportation_source.xml"; // [0, 1] This entity is loaded at the source position when teleportation occurs<br>&emsp;&emsp;&emsp;&emsp;std::string target_particle_fx_file = "data/entities/particles/teleportation_target.xml"; // [0, 1] This entity is loaded at the target position when teleportation occurs<br>&emsp;&emsp;&emsp;&emsp;bool load_collapse_entity = 1; // [0, 1] if we don't want things to collapse after the teleport<br>&emsp;&emsp;&emsp;&emsp;vec2 target; //  Where should we teleport<br>&emsp;&emsp;&emsp;&emsp;int safety_counter = 0; // [0, 1] used to keep track that we're not stuck in waiting for a pixel scene to load, that is not going to be loaded<br>&emsp;&emsp;&emsp;&emsp;TeleportComponentState::Enum state;<br>&emsp;&emsp;&emsp;&emsp;ENTITY_VEC teleported_entities;<br>&emsp;&emsp;&emsp;&emsp;types::aabb source_location_camera_aabb;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="target_x_is_absolute_position" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>If set, target position x is in world coordinates, otherwise it's an offset</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="target_y_is_absolute_position" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>If set, target position y is in world coordinates, otherwise it's an offset</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="source_particle_fx_file" type="xs:string" default="data/entities/particles/teleportation_source.xml">
				<xs:annotation>
					<xs:documentation>`data/entities/particles/teleportation_source.xml` - `[0, 1]`</xs:documentation>
					<xs:documentation>This entity is loaded at the source position when teleportation occurs</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="target_particle_fx_file" type="xs:string" default="data/entities/particles/teleportation_target.xml">
				<xs:annotation>
					<xs:documentation>`data/entities/particles/teleportation_target.xml` - `[0, 1]`</xs:documentation>
					<xs:documentation>This entity is loaded at the target position when teleportation occurs</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="load_collapse_entity" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if we don't want things to collapse after the teleport</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="target.x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>Where should we teleport</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="target.y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>Where should we teleport</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="safety_counter" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>used to keep track that we're not stuck in waiting for a pixel scene to load, that is not going to be loaded</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: TeleportComponentState::Enum for state -->
				<!-- Some Unknown Type: ENTITY_VEC for teleported_entities -->
			<xs:attribute name="source_location_camera_aabb.min_x" type="xs:decimal" default="0" />
			<xs:attribute name="source_location_camera_aabb.min_y" type="xs:decimal" default="0" />
			<xs:attribute name="source_location_camera_aabb.max_x" type="xs:decimal" default="0" />
			<xs:attribute name="source_location_camera_aabb.max_y" type="xs:decimal" default="0" />
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="TeleportProjectileComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class TeleportProjectileComponent {<br>&emsp;&emsp;&emsp;&emsp;float min_distance_from_wall = 16; // [0, 16] <br>&emsp;&emsp;&emsp;&emsp;int actionable_lifetime = 3; // [0, 20] <br>&emsp;&emsp;&emsp;&emsp;bool reset_shooter_y_vel = 1; // [0, 1] If 1, will set shooter y velocity to 0 on teleport<br>&emsp;&emsp;&emsp;&emsp;EntityID mWhoShot = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="min_distance_from_wall" type="xs:decimal" default="16">
				<xs:annotation>
					<xs:documentation>`16` - `[0, 16]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="actionable_lifetime" type="xs:int" default="3">
				<xs:annotation>
					<xs:documentation>`3` - `[0, 20]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="reset_shooter_y_vel" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>If 1, will set shooter y velocity to 0 on teleport</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: EntityID for mWhoShot -->
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="TextLogComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class TextLogComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string key;<br>&emsp;&emsp;&emsp;&emsp;std::string image_filename;<br>&emsp;&emsp;&emsp;&emsp;std::string mCachedName;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="key" type="xs:string" default="" />
			<xs:attribute name="image_filename" type="xs:string" default="" />
			<xs:attribute name="mCachedName" type="xs:string" default="" />
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="TorchComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class TorchComponent {<br>&emsp;&emsp;&emsp;&emsp;int probability_of_ignition_attempt = 15; // [0, 100] how likely are we to ignite colliding cells<br>&emsp;&emsp;&emsp;&emsp;float suffocation_check_offset_y = -2; // [-10, 10] check offset in world coordinates from our position<br>&emsp;&emsp;&emsp;&emsp;int frames_suffocated_to_extinguish = 5; // [0, 30] how many frames the torch needs to be suffocated before it stops emitting fire<br>&emsp;&emsp;&emsp;&emsp;bool extinguishable = 1; // [0, 1] if 1, the torch needs to be re-ignited in case it is turned off<br>&emsp;&emsp;&emsp;&emsp;float fire_audio_weight = 0; // [0, 2] how loud is the sound of our fire? 0 = no sound<br>&emsp;&emsp;&emsp;&emsp;float mFlickerOffset = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mFramesSuffocated = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mIsOn = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mFireIsBurningPrev = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="probability_of_ignition_attempt" type="xs:int" default="15">
				<xs:annotation>
					<xs:documentation>`15` - `[0, 100]`</xs:documentation>
					<xs:documentation>how likely are we to ignite colliding cells</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="suffocation_check_offset_y" type="xs:decimal" default="-2">
				<xs:annotation>
					<xs:documentation>`-2` - `[-10, 10]`</xs:documentation>
					<xs:documentation>check offset in world coordinates from our position</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="frames_suffocated_to_extinguish" type="xs:int" default="5">
				<xs:annotation>
					<xs:documentation>`5` - `[0, 30]`</xs:documentation>
					<xs:documentation>how many frames the torch needs to be suffocated before it stops emitting fire</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="extinguishable" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, the torch needs to be re-ignited in case it is turned off</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="fire_audio_weight" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 2]`</xs:documentation>
					<xs:documentation>how loud is the sound of our fire? 0 = no sound</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mFlickerOffset" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mFramesSuffocated" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mIsOn" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mFireIsBurningPrev" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="UIIconComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class UIIconComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string icon_sprite_file;<br>&emsp;&emsp;&emsp;&emsp;std::string name;<br>&emsp;&emsp;&emsp;&emsp;std::string description;<br>&emsp;&emsp;&emsp;&emsp;bool display_above_head = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool display_in_hud = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool is_perk = 1; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="icon_sprite_file" type="xs:string" default="" />
			<xs:attribute name="name" type="xs:string" default="" />
			<xs:attribute name="description" type="xs:string" default="" />
			<xs:attribute name="display_above_head" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="display_in_hud" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="is_perk" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="UIInfoComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class UIInfoComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string name;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="name" type="xs:string" default="" />
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="VariableStorageComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class VariableStorageComponent {<br>&emsp;&emsp;&emsp;&emsp;std::string name;<br>&emsp;&emsp;&emsp;&emsp;std::string value_string;<br>&emsp;&emsp;&emsp;&emsp;int value_int = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool value_bool = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float value_float = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="name" type="xs:string" default="" />
			<xs:attribute name="value_string" type="xs:string" default="" />
			<xs:attribute name="value_int" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="value_bool" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="value_float" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="VelocityComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class VelocityComponent {<br>&emsp;&emsp;&emsp;&emsp;float gravity_x = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float gravity_y = 400; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float mass = 0.05; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;float air_friction = 0.55; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float terminal_velocity = 1000; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool apply_terminal_velocity = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool updates_velocity = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool displace_liquid = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool affect_physics_bodies = 0; // [0, 1] if true, will move the physics body by the difference of mVelocity to the previous frame<br>&emsp;&emsp;&emsp;&emsp;bool limit_to_max_velocity = 1; // [0, 1] if true will limit the velocity to 61440. You can turn this off, but it's not recommended, since there are some nasty bugs that can happen with extremely high velocities.<br>&emsp;&emsp;&emsp;&emsp;int liquid_death_threshold = 0; // [0, 1] if > 0, entity will die if liquid hit count is greater than this.<br>&emsp;&emsp;&emsp;&emsp;float liquid_drag = 1; // [0, 1] 1 = slows down in liquid, 0 = doesn't slow down at all<br>&emsp;&emsp;&emsp;&emsp;vec2 mVelocity;<br>&emsp;&emsp;&emsp;&emsp;vec2 mPrevVelocity; //  used to update physics bodies<br>&emsp;&emsp;&emsp;&emsp;int mLatestLiquidHitCount = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mAverageLiquidHitCount = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;ivec2 mPrevPosition;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="gravity_x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="gravity_y" type="xs:decimal" default="400">
				<xs:annotation>
					<xs:documentation>`400` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mass" type="xs:decimal" default="0.05">
				<xs:annotation>
					<xs:documentation>`0.05` - `[0, 10]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="air_friction" type="xs:decimal" default="0.55">
				<xs:annotation>
					<xs:documentation>`0.55` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="terminal_velocity" type="xs:decimal" default="1000">
				<xs:annotation>
					<xs:documentation>`1000` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="apply_terminal_velocity" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="updates_velocity" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="displace_liquid" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="affect_physics_bodies" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, will move the physics body by the difference of mVelocity to the previous frame</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="limit_to_max_velocity" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true will limit the velocity to 61440. You can turn this off, but it's not recommended, since there are some nasty bugs that can happen with extremely high velocities.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="liquid_death_threshold" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if &gt; 0, entity will die if liquid hit count is greater than this.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="liquid_drag" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
					<xs:documentation>1 = slows down in liquid, 0 = doesn't slow down at all</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mVelocity.x" type="xs:decimal" default="0" />
			<xs:attribute name="mVelocity.y" type="xs:decimal" default="0" />
			<xs:attribute name="mPrevVelocity.x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>used to update physics bodies</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mPrevVelocity.y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>used to update physics bodies</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mLatestLiquidHitCount" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mAverageLiquidHitCount" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mPrevPosition.x" type="xs:int" default="0" />
			<xs:attribute name="mPrevPosition.y" type="xs:int" default="0" />
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="VerletPhysicsComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class VerletPhysicsComponent {<br>&emsp;&emsp;&emsp;&emsp;int num_points = 2; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int num_links = 2; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int width = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float resting_distance = 2; // [0, 16] <br>&emsp;&emsp;&emsp;&emsp;float mass_min = 0.8; // [0.03, 2] <br>&emsp;&emsp;&emsp;&emsp;float mass_max = 1; // [0.03, 2] <br>&emsp;&emsp;&emsp;&emsp;float stiffness = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float velocity_dampening = 0.99; // [0.2, 1] <br>&emsp;&emsp;&emsp;&emsp;float liquid_damping = 0.7; // [0, 1] how much we dampen when in liquid<br>&emsp;&emsp;&emsp;&emsp;float gets_entity_velocity_coeff = 0; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;bool collide_with_cells = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool simulate_gravity = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool simulate_wind = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float wind_change_speed = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool constrain_stretching = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool pixelate_sprite_transforms = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool scale_sprite_x = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool follow_entity_transform = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float animation_amount = 2; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float animation_speed = 5; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float animation_energy = 0.6; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float cloth_sprite_z_index = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int stain_cells_probability = 0; // [0, 1] 0 = never, 1 = most likely, 10 = less likely - and so on<br>&emsp;&emsp;&emsp;&emsp;bool m_is_culled_previous = 0; // [0, 1] Developer note: this needs to be serialized in case we serialize SpriteComponent.is_visible<br>&emsp;&emsp;&emsp;&emsp;VERLET_TYPE::Enum type;<br>&emsp;&emsp;&emsp;&emsp;vec2 animation_target_offset;<br>&emsp;&emsp;&emsp;&emsp;uint32 cloth_color_edge = 4288376730; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;uint32 cloth_color = 4286534774; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;vec2 m_position_previous;<br>&emsp;&emsp;&emsp;&emsp;UintArrayInline colors;<br>&emsp;&emsp;&emsp;&emsp;UintArrayInline materials;<br>&emsp;&emsp;&emsp;&emsp;FloatArrayInline masses;<br>&emsp;&emsp;&emsp;&emsp;Vec2ArrayInline positions;<br>&emsp;&emsp;&emsp;&emsp;Vec2ArrayInline positions_prev;<br>&emsp;&emsp;&emsp;&emsp;Vec2ArrayInline velocities;<br>&emsp;&emsp;&emsp;&emsp;FloatArrayInline dampenings;<br>&emsp;&emsp;&emsp;&emsp;FloatArrayInline freedoms;<br>&emsp;&emsp;&emsp;&emsp;VerletLinkArrayInline links;<br>&emsp;&emsp;&emsp;&emsp;VerletSprite* sprite;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="num_points" type="xs:int" default="2">
				<xs:annotation>
					<xs:documentation>`2` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="num_links" type="xs:int" default="2">
				<xs:annotation>
					<xs:documentation>`2` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="width" type="xs:int" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="resting_distance" type="xs:decimal" default="2">
				<xs:annotation>
					<xs:documentation>`2` - `[0, 16]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mass_min" type="xs:decimal" default="0.8">
				<xs:annotation>
					<xs:documentation>`0.8` - `[0.03, 2]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mass_max" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0.03, 2]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="stiffness" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="velocity_dampening" type="xs:decimal" default="0.99">
				<xs:annotation>
					<xs:documentation>`0.99` - `[0.2, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="liquid_damping" type="xs:decimal" default="0.7">
				<xs:annotation>
					<xs:documentation>`0.7` - `[0, 1]`</xs:documentation>
					<xs:documentation>how much we dampen when in liquid</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="gets_entity_velocity_coeff" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 10]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="collide_with_cells" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="simulate_gravity" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="simulate_wind" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="wind_change_speed" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="constrain_stretching" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="pixelate_sprite_transforms" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="scale_sprite_x" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="follow_entity_transform" type="NoitaBool" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="animation_amount" type="xs:decimal" default="2">
				<xs:annotation>
					<xs:documentation>`2` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="animation_speed" type="xs:decimal" default="5">
				<xs:annotation>
					<xs:documentation>`5` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="animation_energy" type="xs:decimal" default="0.6">
				<xs:annotation>
					<xs:documentation>`0.6` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="cloth_sprite_z_index" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="stain_cells_probability" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>0 = never, 1 = most likely, 10 = less likely - and so on</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="m_is_culled_previous" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>Developer note: this needs to be serialized in case we serialize SpriteComponent.is_visible</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: VERLET_TYPE::Enum for type -->
			<xs:attribute name="animation_target_offset.x" type="xs:decimal" default="0" />
			<xs:attribute name="animation_target_offset.y" type="xs:decimal" default="0" />
			<xs:attribute name="cloth_color_edge" type="xs:unsignedInt" default="4288376730">
				<xs:annotation>
					<xs:documentation>`4288376730` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="cloth_color" type="xs:unsignedInt" default="4286534774">
				<xs:annotation>
					<xs:documentation>`4286534774` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="m_position_previous.x" type="xs:decimal" default="0" />
			<xs:attribute name="m_position_previous.y" type="xs:decimal" default="0" />
				<!-- Some Unknown Type: UintArrayInline for colors -->
				<!-- Some Unknown Type: UintArrayInline for materials -->
				<!-- Some Unknown Type: FloatArrayInline for masses -->
				<!-- Some Unknown Type: Vec2ArrayInline for positions -->
				<!-- Some Unknown Type: Vec2ArrayInline for positions_prev -->
				<!-- Some Unknown Type: Vec2ArrayInline for velocities -->
				<!-- Some Unknown Type: FloatArrayInline for dampenings -->
				<!-- Some Unknown Type: FloatArrayInline for freedoms -->
				<!-- Some Unknown Type: VerletLinkArrayInline for links -->
				<!-- Some Unknown Type: VerletSprite* for sprite -->
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="VerletWeaponComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class VerletWeaponComponent {<br>&emsp;&emsp;&emsp;&emsp;float damage_radius = 5; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;float physics_force_radius = 3; // [0, 10] <br>&emsp;&emsp;&emsp;&emsp;float damage_min_step = 0.01; // [0, 3.5] <br>&emsp;&emsp;&emsp;&emsp;float damage_max = 1; // [0, 3.5] <br>&emsp;&emsp;&emsp;&emsp;float damage_coeff = 1; // [0, 3.5] <br>&emsp;&emsp;&emsp;&emsp;float impulse_coeff = 1; // [0, 3.5] <br>&emsp;&emsp;&emsp;&emsp;int fade_duration_frames = 10; // [0, 100] <br>&emsp;&emsp;&emsp;&emsp;float physics_impulse_coeff = 1; // [0, 3.5] <br>&emsp;&emsp;&emsp;&emsp;int mPlayerCooldownEnd = -1; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="damage_radius" type="xs:decimal" default="5">
				<xs:annotation>
					<xs:documentation>`5` - `[0, 10]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="physics_force_radius" type="xs:decimal" default="3">
				<xs:annotation>
					<xs:documentation>`3` - `[0, 10]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="damage_min_step" type="xs:decimal" default="0.01">
				<xs:annotation>
					<xs:documentation>`0.01` - `[0, 3.5]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="damage_max" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 3.5]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="damage_coeff" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 3.5]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="impulse_coeff" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 3.5]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="fade_duration_frames" type="xs:int" default="10">
				<xs:annotation>
					<xs:documentation>`10` - `[0, 100]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="physics_impulse_coeff" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 3.5]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mPlayerCooldownEnd" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>`-1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="VerletWorldJointComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class VerletWorldJointComponent {<br>&emsp;&emsp;&emsp;&emsp;int verlet_point_index = 0; // [0, 32] Index of the verlet point we attach<br>&emsp;&emsp;&emsp;&emsp;vec2 world_position; //  Where we attach the verlet point<br>&emsp;&emsp;&emsp;&emsp;bool mUpdated = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;grid::ICell* mCell;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="verlet_point_index" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 32]`</xs:documentation>
					<xs:documentation>Index of the verlet point we attach</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="world_position.x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>Where we attach the verlet point</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="world_position.y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>Where we attach the verlet point</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mUpdated" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: grid::ICell* for mCell -->
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="WalletComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class WalletComponent {<br>&emsp;&emsp;&emsp;&emsp;int64 money = 0; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;int64 money_spent = 0; // [0, 1] tracks how much money the player has spent<br>&emsp;&emsp;&emsp;&emsp;int64 mMoneyPrevFrame = 0; // [0, 1] HAX to give player towards infinite moneys<br>&emsp;&emsp;&emsp;&emsp;bool mHasReachedInf = 0; // [0, 1] once it hits this value... keep it there<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="money" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="money_spent" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>tracks how much money the player has spent</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mMoneyPrevFrame" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>HAX to give player towards infinite moneys</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mHasReachedInf" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>once it hits this value... keep it there</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="WalletValuableComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class WalletValuableComponent {<br>&emsp;&emsp;&emsp;&emsp;int money_value = 10; // [0, 100] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="money_value" type="xs:int" default="10">
				<xs:annotation>
					<xs:documentation>`10` - `[0, 100]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="WorldStateComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class WorldStateComponent {<br>&emsp;&emsp;&emsp;&emsp;bool is_initialized = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float time = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float time_total = 0; // [0, 1000] <br>&emsp;&emsp;&emsp;&emsp;float time_dt = 1; // [0, 1000] to make the time go really fast or slow?<br>&emsp;&emsp;&emsp;&emsp;int day_count = 0; // [0, 3.5] <br>&emsp;&emsp;&emsp;&emsp;float rain = 0; // [0, 1] should be called clouds, controls amount of cloud cover in the sky<br>&emsp;&emsp;&emsp;&emsp;float rain_target = 0; // [0, 1] should be called clouds_target, controls amount of cloud cover in the sky<br>&emsp;&emsp;&emsp;&emsp;float fog = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float fog_target = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool intro_weather = 0; // [0, 1] if set, will set the weather to be nice all the time<br>&emsp;&emsp;&emsp;&emsp;float wind = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float wind_speed = 2; // [-50, 50] <br>&emsp;&emsp;&emsp;&emsp;float wind_speed_sin_t = 10; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float wind_speed_sin = 3; // [-50, 50] <br>&emsp;&emsp;&emsp;&emsp;float clouds_01_target = 0; // [-27, 100] <br>&emsp;&emsp;&emsp;&emsp;float clouds_02_target = 0; // [-100, 185] <br>&emsp;&emsp;&emsp;&emsp;float gradient_sky_alpha_target = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float sky_sunset_alpha_target = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int lightning_count = 0; // [0, 100] this gets decreased to 0, this is the frame count of how many times do we do our awesome lightning effect<br>&emsp;&emsp;&emsp;&emsp;uint32 next_portal_id = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;std::string session_stat_file; //  if empty, we'll create one. This tracks the play time, death, kills... etch<br>&emsp;&emsp;&emsp;&emsp;int player_polymorph_count = 0; // [0, 1] how many times player has been polymorphed<br>&emsp;&emsp;&emsp;&emsp;int player_polymorph_random_count = 0; // [0, 1] how many times player has been random polymorphed<br>&emsp;&emsp;&emsp;&emsp;int player_did_infinite_spell_count = 0; // [0, 1] how many times player has done a secret trick<br>&emsp;&emsp;&emsp;&emsp;int player_did_damage_over_1milj = 0; // [0, 1] how many times player has player done damage of over 1000000<br>&emsp;&emsp;&emsp;&emsp;int player_living_with_minus_hp = 0; // [0, 1] how many times player has been detected with minus health<br>&emsp;&emsp;&emsp;&emsp;float global_genome_relations_modifier = 0; // [0, 1] Genome_GetHerdRelation adds this value to the results. 100 = good relations, 0 is bad <br>&emsp;&emsp;&emsp;&emsp;bool mods_have_been_active_during_this_run = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool twitch_has_been_active_during_this_run = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;uint32 next_cut_through_world_id = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool perk_infinite_spells = 0; // [0, 1] if true, almost all spells will have unlimited uses. (black holes, matter eater, heals excluded<br>&emsp;&emsp;&emsp;&emsp;bool perk_trick_kills_blood_money = 0; // [0, 1] if true, trick kills will produce blood money (heals player)<br>&emsp;&emsp;&emsp;&emsp;int perk_hp_drop_chance = 0; // [0, 1] if > 0, then there's chance that killing an enemy will drop bloodmoney_50<br>&emsp;&emsp;&emsp;&emsp;bool perk_gold_is_forever = 0; // [0, 1] drop_money.lua - checks if this is true and removes Lifetime_Component from gold nuggets<br>&emsp;&emsp;&emsp;&emsp;bool perk_rats_player_friendly = 0; // [0, 1] if 1, rats don't attack player herd and the other way round. this is a persistent change<br>&emsp;&emsp;&emsp;&emsp;bool EVERYTHING_TO_GOLD = 0; // [0, 1] if true everything will be gold + used to track if the wallet should go to infinite<br>&emsp;&emsp;&emsp;&emsp;std::string material_everything_to_gold = "gold"; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;std::string material_everything_to_gold_static = "gold_static"; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool INFINITE_GOLD_HAPPENING = 0; // [0, 1] the secret ending with infinite gold<br>&emsp;&emsp;&emsp;&emsp;bool ENDING_HAPPINESS_HAPPENING = 0; // [0, 1] if true, will do the animations for happiness ending<br>&emsp;&emsp;&emsp;&emsp;int ENDING_HAPPINESS_FRAMES = 0; // [0, 1] to keep track of the animation<br>&emsp;&emsp;&emsp;&emsp;bool ENDING_HAPPINESS = 0; // [0, 1] this is set if ending happiness has happened<br>&emsp;&emsp;&emsp;&emsp;float mFlashAlpha = 0; // [0, 1] to keep track of the animation<br>&emsp;&emsp;&emsp;&emsp;int DEBUG_LOADED_FROM_AUTOSAVE = 0; // [0, 1] how many times have loaded from autosaves<br>&emsp;&emsp;&emsp;&emsp;int DEBUG_LOADED_FROM_OLD_VERSION = 0; // [0, 1] how many times have we loaded from an old version of the game<br>&emsp;&emsp;&emsp;&emsp;vec2 player_spawn_location;<br>&emsp;&emsp;&emsp;&emsp;MAP_STRING_STRING lua_globals;<br>&emsp;&emsp;&emsp;&emsp;VEC_PENDINGPORTAL pending_portals;<br>&emsp;&emsp;&emsp;&emsp;VECTOR_INT32 apparitions_per_level;<br>&emsp;&emsp;&emsp;&emsp;VEC_NPCPARTY npc_parties;<br>&emsp;&emsp;&emsp;&emsp;VECTOR_INT32 orbs_found_thisrun;<br>&emsp;&emsp;&emsp;&emsp;VECTOR_STRING flags;<br>&emsp;&emsp;&emsp;&emsp;VECTOR_STRING changed_materials; //  pairs of materials changed via ConvertMaterialEverywhere(). stored so these can be restored when loading a save<br>&emsp;&emsp;&emsp;&emsp;VEC_CUTTHROUGHWORLD cuts_through_world;<br>&emsp;&emsp;&emsp;&emsp;LensValue<int> gore_multiplier;<br>&emsp;&emsp;&emsp;&emsp;LensValue<int> trick_kill_gold_multiplier;<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> damage_flash_multiplier;<br>&emsp;&emsp;&emsp;&emsp;LensValue<bool> open_fog_of_war_everywhere; //  same as the trailer mode, open fog of war everywhere<br>&emsp;&emsp;&emsp;&emsp;LensValue<bool> consume_actions; //  same as the trailer mode, spells with limited uses are not consumed if this is false<br>&emsp;&emsp;&emsp;&emsp;float rain_target_extra = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float fog_target_extra = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool perk_rats_player_friendly_prev = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="is_initialized" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="time" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="time_total" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="time_dt" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1000]`</xs:documentation>
					<xs:documentation>to make the time go really fast or slow?</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="day_count" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 3.5]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="rain" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>should be called clouds, controls amount of cloud cover in the sky</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="rain_target" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>should be called clouds_target, controls amount of cloud cover in the sky</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="fog" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="fog_target" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="intro_weather" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if set, will set the weather to be nice all the time</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="wind" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="wind_speed" type="xs:decimal" default="2">
				<xs:annotation>
					<xs:documentation>`2` - `[-50, 50]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="wind_speed_sin_t" type="xs:decimal" default="10">
				<xs:annotation>
					<xs:documentation>`10` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="wind_speed_sin" type="xs:decimal" default="3">
				<xs:annotation>
					<xs:documentation>`3` - `[-50, 50]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="clouds_01_target" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-27, 100]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="clouds_02_target" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[-100, 185]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="gradient_sky_alpha_target" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="sky_sunset_alpha_target" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="lightning_count" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 100]`</xs:documentation>
					<xs:documentation>this gets decreased to 0, this is the frame count of how many times do we do our awesome lightning effect</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="next_portal_id" type="xs:unsignedInt" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="session_stat_file" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>if empty, we'll create one. This tracks the play time, death, kills... etch</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="player_polymorph_count" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>how many times player has been polymorphed</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="player_polymorph_random_count" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>how many times player has been random polymorphed</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="player_did_infinite_spell_count" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>how many times player has done a secret trick</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="player_did_damage_over_1milj" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>how many times player has player done damage of over 1000000</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="player_living_with_minus_hp" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>how many times player has been detected with minus health</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="global_genome_relations_modifier" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>Genome_GetHerdRelation adds this value to the results. 100 = good relations, 0 is bad </xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mods_have_been_active_during_this_run" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="twitch_has_been_active_during_this_run" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="next_cut_through_world_id" type="xs:unsignedInt" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="perk_infinite_spells" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, almost all spells will have unlimited uses. (black holes, matter eater, heals excluded</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="perk_trick_kills_blood_money" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, trick kills will produce blood money (heals player)</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="perk_hp_drop_chance" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if &gt; 0, then there's chance that killing an enemy will drop bloodmoney_50</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="perk_gold_is_forever" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>drop_money.lua - checks if this is true and removes Lifetime_Component from gold nuggets</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="perk_rats_player_friendly" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if 1, rats don't attack player herd and the other way round. this is a persistent change</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="EVERYTHING_TO_GOLD" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true everything will be gold + used to track if the wallet should go to infinite</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="material_everything_to_gold" type="xs:string" default="gold">
				<xs:annotation>
					<xs:documentation>`gold` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="material_everything_to_gold_static" type="xs:string" default="gold_static">
				<xs:annotation>
					<xs:documentation>`gold_static` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="INFINITE_GOLD_HAPPENING" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>the secret ending with infinite gold</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ENDING_HAPPINESS_HAPPENING" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, will do the animations for happiness ending</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ENDING_HAPPINESS_FRAMES" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>to keep track of the animation</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ENDING_HAPPINESS" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>this is set if ending happiness has happened</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mFlashAlpha" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>to keep track of the animation</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="DEBUG_LOADED_FROM_AUTOSAVE" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>how many times have loaded from autosaves</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="DEBUG_LOADED_FROM_OLD_VERSION" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>how many times have we loaded from an old version of the game</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="player_spawn_location.x" type="xs:decimal" default="0" />
			<xs:attribute name="player_spawn_location.y" type="xs:decimal" default="0" />
				<!-- Some Unknown Type: MAP_STRING_STRING for lua_globals -->
				<!-- Some Unknown Type: VEC_PENDINGPORTAL for pending_portals -->
				<!-- Some Unknown Type: VECTOR_INT32 for apparitions_per_level -->
				<!-- Some Unknown Type: VEC_NPCPARTY for npc_parties -->
				<!-- Some Unknown Type: VECTOR_INT32 for orbs_found_thisrun -->
				<!-- Some Unknown Type: VECTOR_STRING for flags -->
				<!-- Some Unknown Type: VECTOR_STRING for changed_materials -->
				<!-- Some Unknown Type: VEC_CUTTHROUGHWORLD for cuts_through_world -->
			<xs:attribute name="gore_multiplier" type="xs:int" default="0" />
			<xs:attribute name="trick_kill_gold_multiplier" type="xs:int" default="0" />
			<xs:attribute name="damage_flash_multiplier" type="xs:decimal" default="0" />
			<xs:attribute name="open_fog_of_war_everywhere" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>same as the trailer mode, open fog of war everywhere</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="consume_actions" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>same as the trailer mode, spells with limited uses are not consumed if this is false</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="rain_target_extra" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="fog_target_extra" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="perk_rats_player_friendly_prev" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="WormAIComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class WormAIComponent {<br>&emsp;&emsp;&emsp;&emsp;float speed = 1; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float speed_hunt = 3; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float direction_adjust_speed = 1; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float direction_adjust_speed_hunt = 1; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float random_target_box_radius = 512; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;int new_hunt_target_check_every = 30; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;int new_random_target_check_every = 120; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float hunt_box_radius = 512; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;int cocoon_food_required = 30; // [0, 1] how much food do we need to consume before we can cocoon<br>&emsp;&emsp;&emsp;&emsp;std::string cocoon_entity; //  if empty, won't cocoon, if set it'll spawn this after it's eaten enough<br>&emsp;&emsp;&emsp;&emsp;float give_up_area_radius = 50; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;int give_up_time_frames = 300; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;bool debug_follow_mouse = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;vec2 mRandomTarget;<br>&emsp;&emsp;&emsp;&emsp;int mTargetEntityId = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mNextTargetCheckFrame = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mNextHuntTargetCheckFrame = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mGiveUpStarted = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mGiveUpAreaMinX = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mGiveUpAreaMinY = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mGiveUpAreaMaxX = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mGiveUpAreaMaxY = 0; // [0, 1] <br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="speed" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="speed_hunt" type="xs:decimal" default="3">
				<xs:annotation>
					<xs:documentation>`3` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="direction_adjust_speed" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="direction_adjust_speed_hunt" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="random_target_box_radius" type="xs:decimal" default="512">
				<xs:annotation>
					<xs:documentation>`512` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="new_hunt_target_check_every" type="xs:int" default="30">
				<xs:annotation>
					<xs:documentation>`30` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="new_random_target_check_every" type="xs:int" default="120">
				<xs:annotation>
					<xs:documentation>`120` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="hunt_box_radius" type="xs:decimal" default="512">
				<xs:annotation>
					<xs:documentation>`512` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="cocoon_food_required" type="xs:int" default="30">
				<xs:annotation>
					<xs:documentation>`30` - `[0, 1]`</xs:documentation>
					<xs:documentation>how much food do we need to consume before we can cocoon</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="cocoon_entity" type="xs:string" default="">
				<xs:annotation>
					<xs:documentation>if empty, won't cocoon, if set it'll spawn this after it's eaten enough</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="give_up_area_radius" type="xs:decimal" default="50">
				<xs:annotation>
					<xs:documentation>`50` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="give_up_time_frames" type="xs:int" default="300">
				<xs:annotation>
					<xs:documentation>`300` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="debug_follow_mouse" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mRandomTarget.x" type="xs:decimal" default="0" />
			<xs:attribute name="mRandomTarget.y" type="xs:decimal" default="0" />
			<xs:attribute name="mTargetEntityId" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mNextTargetCheckFrame" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mNextHuntTargetCheckFrame" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mGiveUpStarted" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mGiveUpAreaMinX" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mGiveUpAreaMinY" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mGiveUpAreaMaxX" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mGiveUpAreaMaxY" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="WormAttractorComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class WormAttractorComponent {<br>&emsp;&emsp;&emsp;&emsp;int direction = 1; // [-1, 1] 1 = attracts worms, -1 detracts worms<br>&emsp;&emsp;&emsp;&emsp;float radius = 50; // [0, 100] radius of detracting worms<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="direction" type="xs:int" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[-1, 1]`</xs:documentation>
					<xs:documentation>1 = attracts worms, -1 detracts worms</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="radius" type="xs:decimal" default="50">
				<xs:annotation>
					<xs:documentation>`50` - `[0, 100]`</xs:documentation>
					<xs:documentation>radius of detracting worms</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="WormComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class WormComponent {<br>&emsp;&emsp;&emsp;&emsp;float speed = 1; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float acceleration = 3; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float gravity = 3; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float tail_gravity = 30; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float part_distance = 10; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;int ground_check_offset = 0; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float hitbox_radius = 1; // [0, 1e+006] <br>&emsp;&emsp;&emsp;&emsp;float bite_damage = 1; // [0, 10] how much damage does this do when it hits an entity<br>&emsp;&emsp;&emsp;&emsp;float target_kill_radius = 1; // [0, 1e+006] <br>&emsp;&emsp;&emsp;&emsp;float target_kill_ragdoll_force = 1; // [0, 1e+006] <br>&emsp;&emsp;&emsp;&emsp;float jump_cam_shake = 4; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float jump_cam_shake_distance = 256; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;float eat_anim_wait_mult = 0.05; // [0, 10000] <br>&emsp;&emsp;&emsp;&emsp;std::string ragdoll_filename;<br>&emsp;&emsp;&emsp;&emsp;bool is_water_worm = 0; // [0, 1] if true, tries to stay in liquids<br>&emsp;&emsp;&emsp;&emsp;float max_speed = 25; // [0, 1] max speed, used when attracted to a point<br>&emsp;&emsp;&emsp;&emsp;LensValue<float> ground_decceleration;<br>&emsp;&emsp;&emsp;&emsp;vec2 mTargetVec;<br>&emsp;&emsp;&emsp;&emsp;float mGravVelocity = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float mSpeed = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;vec2 mTargetPosition;<br>&emsp;&emsp;&emsp;&emsp;float mTargetSpeed = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;bool mOnGroundPrev = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mMaterialIdPrev = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;int mFrameNextDamage = 0; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;float mDirectionAdjustSpeed = 1; // [0, 1] <br>&emsp;&emsp;&emsp;&emsp;WormPartPositions mPrevPositions;<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="speed" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="acceleration" type="xs:decimal" default="3">
				<xs:annotation>
					<xs:documentation>`3` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="gravity" type="xs:decimal" default="3">
				<xs:annotation>
					<xs:documentation>`3` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="tail_gravity" type="xs:decimal" default="30">
				<xs:annotation>
					<xs:documentation>`30` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="part_distance" type="xs:decimal" default="10">
				<xs:annotation>
					<xs:documentation>`10` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ground_check_offset" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="hitbox_radius" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1e+006]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="bite_damage" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 10]`</xs:documentation>
					<xs:documentation>how much damage does this do when it hits an entity</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="target_kill_radius" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1e+006]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="target_kill_ragdoll_force" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1e+006]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="jump_cam_shake" type="xs:decimal" default="4">
				<xs:annotation>
					<xs:documentation>`4` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="jump_cam_shake_distance" type="xs:decimal" default="256">
				<xs:annotation>
					<xs:documentation>`256` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="eat_anim_wait_mult" type="xs:decimal" default="0.05">
				<xs:annotation>
					<xs:documentation>`0.05` - `[0, 10000]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ragdoll_filename" type="xs:string" default="" />
			<xs:attribute name="is_water_worm" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
					<xs:documentation>if true, tries to stay in liquids</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="max_speed" type="xs:decimal" default="25">
				<xs:annotation>
					<xs:documentation>`25` - `[0, 1]`</xs:documentation>
					<xs:documentation>max speed, used when attracted to a point</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ground_decceleration" type="xs:decimal" default="0" />
			<xs:attribute name="mTargetVec.x" type="xs:decimal" default="0" />
			<xs:attribute name="mTargetVec.y" type="xs:decimal" default="0" />
			<xs:attribute name="mGravVelocity" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mSpeed" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mTargetPosition.x" type="xs:decimal" default="0" />
			<xs:attribute name="mTargetPosition.y" type="xs:decimal" default="0" />
			<xs:attribute name="mTargetSpeed" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mOnGroundPrev" type="NoitaBool" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mMaterialIdPrev" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mFrameNextDamage" type="xs:int" default="0">
				<xs:annotation>
					<xs:documentation>`0` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mDirectionAdjustSpeed" type="xs:decimal" default="1">
				<xs:annotation>
					<xs:documentation>`1` - `[0, 1]`</xs:documentation>
				</xs:annotation>
			</xs:attribute>
				<!-- Some Unknown Type: WormPartPositions for mPrevPositions -->
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
	<xs:element name="WormPlayerComponent">
		<xs:annotation> <xs:documentation> <![CDATA[```cpp<br>class WormPlayerComponent {<br>&emsp;&emsp;&emsp;&emsp;vec2 mPrevPosition;<br>&emsp;&emsp;&emsp;&emsp;vec2 mDirection; //  if mDirection == 0,0 nothings works<br>};<br>```]]> </xs:documentation> </xs:annotation>
		<xs:complexType mixed="true">
			<xs:attribute name="mPrevPosition.x" type="xs:decimal" default="0" />
			<xs:attribute name="mPrevPosition.y" type="xs:decimal" default="0" />
			<xs:attribute name="mDirection.x" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>if mDirection == 0,0 nothings works</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="mDirection.y" type="xs:decimal" default="0">
				<xs:annotation>
					<xs:documentation>if mDirection == 0,0 nothings works</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="_tags" type="xs:string" default="" />
			<xs:attribute name="_enabled" type="NoitaBool" default="1" />
		</xs:complexType>
	</xs:element>
</xs:schema>